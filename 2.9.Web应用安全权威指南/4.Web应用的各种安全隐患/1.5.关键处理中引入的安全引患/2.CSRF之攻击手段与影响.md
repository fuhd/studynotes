CSRF之攻击手段与影响
=================================================================
首先让我们来看一下针对`CSRF`漏洞实施的 **两种典型的攻击模式**。即 **“输入－执行”这种简单模式下的攻击手段** 以及
**中途包含确认页面时的攻击方法**。

### “输入－执行”模式的CSRF攻击
此处用更改密码页面作为“输入－执行”模式下关键处理的例子。以下`PHP`脚本展示了更改密码处理的概要。
```php
//代码清单：/45/45-001.php（登录脚本）

<?php   //用来确认用户已登录的脚本
    session_start();
    $id = @$_GET['id'];
    if(! $id) $id = 'yamada';
    $_SESSION['id'] = $id;
?>
<body>
已登录 (id:<?php echo
    htmlspecialchars($id, ENT_NOQUOTES 'UTF-8'); ?>) <br>
<a href="45-002.php">更改密码</a>
</body>
```
```php
//代码清单：/45/45-002.php（密码输入页面）

<?php
    session_start();
    //确认登录 省略
?>
<body>
<form action="45-003.php" method="POST">
新密码 <input name="pwd" type="password"><br>
<input type="submit" value="更改密码">
</form>
</body>
```
```php
//代码清单：/45/45-003.php（执行更改密码）

<?php
    function ex($s) {       //用于防范XSS的HTML转义及显示处理函数
        echo htmlspecialhars($s, ENT_COMPAT, 'UTF-8');
    }
    session_start();
    $id = $_SESSION['id'];  //取得用户名
    //确认登录 省略
    $pwd = $_POST['pwd'];   //取得用户密码
    //更改密码处理 将用户$id的密码更改为$pwd
?>
<body>
<?php ex($id); ?>
</body>
```
可见，密码在最后的`45-003.php`中被更改。然而，通过此脚本更改密码，还需要满足以下3个条件：
+ 使用`POST`方法请求45-003.php
+ 保持登录状态
+ 使用`POST`参数中的`pwd`指定新密码

而使浏览器发送满足以上条件的请求的攻击即为`CSRF`攻击。**下面就是用来实施`CSRF`攻击的`HTML`文件**。
```php
//代码清单：/45/45-900.html

<body onload="document.forms[0].submit()">
<form action="http://example.jp/45/45-003.php" method="POST">
<input type="hidden" name="pwd" value="cracked">
</form>
</body>
```
**这段代码为实施`CSRF`攻击的恶意网页的`HTML`源代码。攻击者将其置于互联网上，并在其中添加攻击对象网站
用户可能感兴趣的内容，以引诱网站的用户前来浏览**。

用户浏览此`HTML`时的情形如下：
1. 用户登录`example.jp`
2. 攻击者设下圈套。
3. 受害人浏览恶意网站而触发圈套。
4. 攻击者使用恶意网站中的`JavaScript`，使受害人的浏览器向攻击对象网站发送将密码变更为`cracked`的`POST`请求
5. 密码被更改

这种情况下，因为先前列举的变更密码所需条件都已满足，所以正规用户的密码就被成功更改为了`cracked`。

**攻击者在实际发动攻击时，为了使攻击显得隐蔽，通常会采用不可见的`iframe`来布置恶意网页。
此时，根据同源策略，从`iframe`的外层（恶意网页）无法读取到内层（攻击对象）的内容，因此，`CSRF`攻击虽然
能够以正规用户的权限恶意使用攻击对象网站中的关键处理，却无法获取网页中显示的内容**。

#### 密码被更改也会导致信息泄漏
由于`CSRF`攻击者不能获取攻击对象页面，因此便无法窃取信息。但是，在使用`CSRF`攻击成功更改用户密码后，
攻击者就知道了更改后的密码，从而也就能够登录应用来窃取被害人的信息了。

### CSRF攻击与XSS攻击
**`CSRF`与（反射型）`XSS`不仅名称相似，攻击流程也如出一辙，甚至连攻击的影响也有相同之处，因此将两者混淆的人不在少数**。
为了区分两者，我们可以看下面所展示的`CSRF`和反射型`XSS`的攻击流程：
1. 浏览恶意网站
2. 返回恶意`HTML`
3. 发送攻击用请求
4. 返回攻击用响应内容

**`CSRF`** 是指恶意使用服务器对步骤3中请求的处理，**恶意使用的内容仅限于服务器端提供的处理**。

而`XSS`的情况下，步骤3的请求中包含的脚本则被原封不动地以响应步骤4的形式返回，随后该恶意脚本在用户的浏览器中被执行。
由于攻击者能够在用户的浏览器上执行自己准备的`HTML`或`JavaScript`，因此只要是浏览器能做到的事都可以被用作攻击手段。
攻击者甚至还能够通过`Javascript`恶意使用服务器端的功能。

由此可见，就攻击范围来说，`XSS`的威胁更大，但针对`CSRF`漏洞则特别需要注意如下两点：
+ **`CSRF`需要在设计阶段就考虑防范策略**。
+ **开发者对`CSRF`的认知度要低于`XSS`，`CSRF`对策方面也没有太大进展**。

### 存在确认页面时的CSRF攻击









