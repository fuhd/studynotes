变量声明之静态变量
================================================================================
Rust中可以用`static`关键字声明静态变量。如下所示：
```rust
static GLOBAL: i32 = 0;
```
**与`let`语句一样，`static`语句同样也是一个模式匹配**。与`let`语句不同的是，**用`static`声
明的变量的生命周期是整个程序，从启动到退出**。`static`变量的生命周期永远是`static`，它占用的内
存空间也不会在执行过程中回收。**这也是Rust中唯一的声明全局变量的方法**。

**由于Rust非常注重内存安全，因此全局变量的使用有许多限制**。这些限制都是为了防止程序员写出不安全
的代码：
+ **全局变量必须在声明的时候马上初始化**；
+ **全局变量的初始化必须是编译期可确定的常量，不能包括执行期才能确定的表达式、语句和函数调用**；
+ **带有`mut`修饰的全局变量，在使用的时候必须使用`unsafe`关键字**；

示例如下：
```rust
fn main() {
    //局部变量声明，可以留待后面初始化，只要保证使用前已经初始化即可
    let x;
    let y = 1_i32;
    x = 2_i32;
    println!("{} {}", x, y);

    //全局变量必须声明的时候初始化，因为全局变量可以写到函数外面，被任意一个函数使用
    static G1: i32 = 3;
    println!("{}", G1);

    //可变全局变量无论读写都必须用unsafe修饰
    static mut G2: i32 = 4;
    unsafe {
        G2 = 5;
        println!("{}", G2);
    }
    //全局变量的内存不是分配在当前函数栈，函数退出的时候，并不会销毁全局变量占用的内存空间，程序退出才会回收
}
```
**Rust禁止在声明`static`变量的时候调用普通函数，或者利用语句块调用其他非`const`代码**：
```rust
fn main() {
    //这样是允许的
    static array: [i32; 3] = [1,2,3];
    //这样是不允许的，错误的
    static vec: Vec<i32> = {let mut v = Vec::new(); v.push(1); v};
}
```
**调用`const fn`是允许的**：
```rust
#![feature(const_fn)]
fn main() {
    use std::sync::atomic::AtomicBool;
    static FLAG: AtomicBool = AtomicBool::new(true);
    println!("{:?}", FLAG);
}
```
**因为`const fn`是编译期执行的。这个功能在编写本书的时候目前还没有`stable`，因此需要使用
`nightly`版本并打开`feature gate`才能使用**。

**Rust不允许用户在`main`函数之前或者之后执行自己的代码。所以，比较复杂的`static`变量的初始化
一般需要使用`lazy`方式，在第一次使用的时候初始化。在Rust中，如果用户需要使用比较复杂的全局变量
初始化，推荐使用`lazy_static`库**。
