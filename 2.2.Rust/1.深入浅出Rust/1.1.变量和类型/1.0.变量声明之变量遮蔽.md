变量声明之变量遮蔽
================================================================================
Rust允许在同一个代码块中声明同样名字的变量。如果这样做，后面声明的变量会将前面声明的变量“遮蔽”
（`Shadowing`）起来。
```rust
fn main() {
    let x = "hello";
    println!("x is {}", x);

    let x = 5;
    println!("x is {}", x);
}
```
**上面这个程序是可以编译通过的。请注意第5行的代码，它不是`x=5;`，它前面有一个`let`关键字。如果
没有这个`let`关键字，这条件语句就是对`x`的重新绑定（重新赋值）。而有了这个`let`关键字，就是又声
明了一个新的变量，只是它的名字恰巧与前面一个变量相同而已**。

但是这两个`x`代表的内存空间完全不同，类型也完全不同，**它们实际上是两个不同的变量。从第5行开始，
一直到这个代码块结束，我们没有任何办法再去访问前一个`x`变量，因为它的名字已经被遮蔽了**。

变量遮蔽在某些情况下非常有用，比如，**我们需要在同一个函数内部把一个变量转换为另一个类型的变量，
但又不想给它们起不同的名字**。再比如，**在同一个函数内部，需要修改一个变量绑定的可变性**。例如，
我们对一个可变数组执行初始化，希望此时它是可读写的，但是初始化完成后，我们希望它是只读的。可以这
样做：
```rust
//注意：这段代码只是演示变量遮蔽功能，并不是Vec类型的最佳初始化方法
fn main() {
    //v必须是mut修饰，因为我们需要对它写入数据    
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);
    //从这里往下，v成了只读变量，可读写变量v已经被遮蔽，无法再访问
    let v = v;
    for i in &v {
        println!("{}", i);
    }
}
```
反过来，**如果一个变量是不可变的，我们也可以通过变量遮蔽创建一个新的、可变的同名变量**。
```rust
fn main() {
    let v = Vec::new();
    let mut v = v;
    v.push(1);
    println!("{:?}", v);
}
```
请注意，这个过程是符合“内存安全”的。”内存安全“的概念一直是Rust关注的重点。在上面这个示例中，我们
需要理解的是，**一个“不可变绑定”依然是一个”变量“。虽然我们没办法通过这个”变量绑定“修改变量的值，
但是我们重新使用“可变绑定”之后，还是有机会修改的。这样做并不会产生内存安全问题，因为我们对这块内
存拥有完整的所有权，且此时没有任何其他引用指向这个变量，对这个变量的修改是完全合法的。Rust的可变
性控制规则与其他语言不一样**。
