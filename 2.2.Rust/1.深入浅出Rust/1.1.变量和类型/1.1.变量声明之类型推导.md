变量声明之类型推导
================================================================================
**Rust的类型推导功能是比较强大的**。它不仅可以 **从变量声明的当前语句中获取信息进行推导**，而且
还能 **通过上下文信息进行推导**。
```rust
fn main() {
    //没有明确标出变量的类型，但是通过字面量的后缀，编译器知道elem的类型为u8
    let elem = 5u8;
    //创建一个动态数组，数组内包含的是什么元素类型可以不写
    let mut vec = Vec::new();
    //下面调了push函数，通过elem变量的类型，编译器可以推导出vec的实际类型是Vec<u8>
    vec.push(elem);
    println!("{:?}", vec);
}
```
**我们甚至还可以只写一部分类型，剩下的部分让编译器去推导**，比如下面的这个程序，我们只知道`players`
变量是`Vec`动态数组类型，但是里面包含什么元素类型并不清楚，**可以在尖括号中用下划线来代替**：
```rust
fn main() {
    let player_scores = [("Jack", 20), ("Jane", 23), ("Jill", 18), ("John", 19)];
    //players是动态数组，内部成员的类型没有指定，交给编译器自动推导
    let players: Vec<_> = player_scores
        .iter()
        .map(|&(player, _score)| player)
        .collect();
    println!("{:?}", players);
}
```
自动类型推导和“动态类型系统”是两码事。**Rust依然是静态类型的。一个变量的类型必须在编译阶段确定，
且无法更改，只是某些时候不需要在源码中显式写出来而已。这只是编译器给我们提供的一个辅助工具**。

**Rust只允许“局部变量/全局变量”实现类型推导，而函数签名（参数与返回值？）等场景下是不允许的**，
这是故意这样设计的。**这是因为局部变量只有局部的影响，全局变量必须当场初始化而函数签名具有全局性
影响**。函数签名如果使用自动类型推导，可能导致某个调用的地方使用方式发生变化，它的参数、返回值类
型就发生了变化，进而导致远处另一个地方的编译错误，这是设计者不希望看到的情况。
