Hello, Cargo!
================================================================================
**`Cargo`是Rust的构建系统和包管理工具**，它负责构建代码、下载依赖库并编译。我们把代码需要的库叫
做依赖（`dependencies`）。

最简单的Rust程序，比如我们刚刚编写的，并没有任何依赖，所以我们只使用了`Cargo`构建代码的功能。随着
更复杂程序的编写，你会想要 **添加依赖**，如果你使用`Cargo`开始的话，这将会变得简单许多。

之前介绍的 **官方安装包，它自带`Cargo`**，可以在终端输入如下命令，检查是否安装了`Cargo`：
```shell
$ cargo --version
```

### 使用Cargo创建项目
让我们使用`Cargo`来创建一个新项目：
```shell
$ cd ~/projects
$ cargo new hello_cargo --bin
$ cd hello_cargo
```
第二行命令新建了名为hello_cargo的 **二进制可执行程序**。我们向 **`cargo new`** 传递了
**`--bin`** ，因为我们的目标是 **生成一个可执行程序，而不是一个库**。可执行程序是二进制可执行
文件，通常就叫做 **二进制文件**（`binaries`）。项目的名称被定为`hello_cargo`，同时`Cargo`在
一个 **同名目录** 中创建它的文件，接着我们可以进入查看。

如果列出`hello_cargo`目录中的文件，将会看到`Cargo`生成了一个文件和一个目录：**`Cargo.toml`**
文件和一个 **`src`** 目录，`main.rs`文件位于目录中。它也在`hello_cargo`目录初始化了一个
**`git`仓库**，以及一个 **`.gitignore`文件**。

使用文本编辑器（`IDE`）打开`Cargo.toml`文件。它应该看起来像这样：
```ini
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["fuhd <sandy_cn_@hotmail.com>"]

[dependencies]

```
**这个文件使用`TOML`格式。TOML类似于INI，不过一些额外的改进之处，并且被用作`Cargo`的配置文件的
格式**。

第一行，**`[package]`是一个段落标题，表明下面的语句用来配置一个包**。随着我们在这个文件增加更多
的信息，还将增加其他段落。

最后一行，**`[dependencies]`是项目依赖的`crates`（Rust代码包）** 的段落的开始，**这样`Cargo`
就知道下载和编译它们了**。这个项目并不需要任何其他`crate`。

现在看看`src/main.rs`：
```rust
fn main() {
    println!("Hello, world!");
}
```
`Cargo`为你生成了一个“Hello, world"，正如我们之前编写的那个！目前为止，之前项目与`Cargo`生成项目区别有：
+ 代码位于`src`目录；
+ 项目根目录包含一个`Cargo.toml`配置文件；

**`Cargo`期望源文件位于`src`目录，将项目根目录留给`README`、`license`信息、配置文件和其他跟代码无关的文件**。
这样，`Cargo`帮且你保持项目干净整洁，一切井井有条。

### 构建并运行Cargo项目
现在让我们看看通过`Cargo`构建和运行Hello World程序有什么不同。为此，输入如下命令：
```shell
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///home/fuhd/work/workspace/rust_projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 5.40 secs
```
这应该创建`target/debug/hello_cargo`可执行文件，可以通过这个命令运行：
```shell
$ ./target/debug/hello_cargo
Hello, world!
```
**首次运行`cargo build`的时候，`Cargo`会在项目根目录创建一个新文件`Cargo.lock`**，它看起来像这样：
```ini
[root]
name = "hello_cargo"
version = "0.1.0"
```
**`Cargo`使用`Cargo.lock`来记录程序的依赖**。这个项目并没有依赖，所以内容比较少。事实上，**你自己永远也不需要
碰这个文件**，让`Cargo`处理它就行了。

我们刚刚使用`cargo build`构建了项目并使用`./target/debug/hello_cargo`运行了它，**也可以使用`cargo run`
编译并运行**：
```shell
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
注意这一次并没有出现“正在编译hello_cargo”的输出。`Cargo`发现文件并没有被改变，直接运行了二进制文件。
如果修改了源文件的话，将会出现像这样的输出：
```shell
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///home/fuhd/work/workspace/rust_projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.94 secs
     Running `/home/fuhd/work/workspace/rust_projects/hello_cargo/target/debug/hello_cargo`
Hello, world!!!!!!!!!!!!!!!!
```

### 发布构建
**当项目最终准备好发布了，可以使用`cargo build --release`来优化编译项目。这会在`target/release`
下生成可执行文件，而不是`target/debug`。优化可以让Rust代码运行的更快，然而也需要更长的编译时间。
因此产生了两种不同的配置：一种为了开发，你需要快速重新构建；另一种构建给用户的最终程序，不会重新构建，
并且程序运行得越快越好。如果你在测试代码的运行时间，请确保运行`cargo build --release`并使用
`target/release`下的可执行文件**。

### 把Cargo当作习惯
对于简单项目，`Cargo`并不比`rustc`更有价值，不过随着开发的进行终将体现它的价值。**对于拥有多个`crate`的
复杂项目，让`Cargo`来协调构建将更简单**。有了`Cargo`，只需运行`cargo build`，然后一切将有序运行。
即便这个项目很简单，它也使用了很多你之后的Rust生涯会用得上的实用工具。
