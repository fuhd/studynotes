示例：hello world
==================================================================
Rust安装好之后，让我们来编写第一个程序。当学习一门新语言的时候，使用该语言在屏幕上打印“Hello,world!“
是一项传统。

### 创建项目目录
首先，创建一个存放代码的文件夹。这里我们在`home`目录下创建一个`projects`目录，并把我的所有项目
放在这里。打开Linux终端，输入如下命令：
```shell
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

### 编写并运行Rust程序
新建一个叫`main.rs`的文件。**Rust源代码总是以`.rs`后缀结尾。如果文件名包含多个单词，使用下划线分隔它们**。
例如`my_program.rs`，而不是`myprogram.rs`。

现在打开刚创建的`main.rs`文件，输入如下代码：
```rust
fn main() {
    println!("Hello, world!");
}
```
保存文件，并回到Linux终端窗口。输入如下命令：
```shell
$ rustc main.rs
$ ./main
Hello, world!
```
你已经在终端看到`hello, world!`字样。

### 分析Rust程序
```rust
fn main() {

}
```
这几行定义了一个 **Rust函数**。一个叫`main`的函数，没有参数也没有返回值。如果有参数的话，它们出现
在括弧中，`(`和`)`之间。**`main`函数是特殊的：它是每一个可执行的Rust程序的入口点**。

还须主意函数体被包裹在花括号中，`{`和`}`之间。所有函数体都要用花括号包裹起来（有些语言，当函数体只
有一行时可以省略花括号，但在Rust中是不行的）。一般来说，**将左括号与函数声明置于一行，并以空格分隔，
是良好的代码风格**。

在编写本书的时候，一个叫做 **rustfmt** 的 **自动格式化工具** 正在开发中。如果你希望在Rust项目中
保持一种标准风格，**rustfmt会将代码格式化为特定的风格**。Rust团队计划最终将其包含在标准Rust发行版
中，就像rustc。

在`main()`函数中：
```rust
println!("Hello, world!");
```
这行代码在屏幕上打印文本。这里有很多细节需要注意。首先Rust使用 **4个空格的缩进风格**，而不是一个
制表符（`tab`）。

第二个重要的部分是 **`println!()`**。这是 **宏（macro）**，**`Rust`元编程**（`metaprogramming`）
的关键所在。**而调用一个函数，则要像这样：`println`（没有`!`）**。后面再讨论宏，现在你只需要记住，
**当看到符号`!`的时候，调用的是宏而不是普通函数**。

该行以 **分号** 结尾（`;`）。**`;`** 代表一个表达式的结束和下一个表达式的开始。大部分Rust代码行以`;`结尾。

### 编译和运行是两个步骤
运行一个Rust程序之前，必须先编译它。可以通过 **`rustc`命令** 来使用Rust编译器，并传递源文件的名字给它，如下：
```shell
$ rustc main.rs
```
如果有`C`或`C++`背景，就会发现这与`gcc`和`clang`类似。**编译成功后，Rust应该会输出一个二进制可执行文件**。
**Rust是一种预编译静态类型语言，这意味着编译好程序后，把它给任何人，他们不需要安装Rust就可运行**。

使用`rustc`编译简单程序是没有问题的，不过随着项目的增长，你可能需要控制你项目的方方面面，并且更容易地
将代码分享给其它人或项目。所以接下来，我们要介绍一个叫做 **`Cargo`** 的工具，它会帮助你编写真实世界中的Rust程序。

### Hello, Cargo!
**`Cargo`是Rust的构建系统和包管理工具**，它负责构建代码、下载依赖库并编译。我们把代码需要的库叫做依赖（`dependencies`）。

最简单的Rust程序，比如我们刚刚编写的，并没有任何依赖，所以我们只使用了`Cargo`构建代码的功能。
随着更复杂程序的编写，你会想要 **添加依赖**，如果你使用`Cargo`开始的话，这将会变得简单许多。

之前介绍的官方安装包，它自带`Cargo`，可以在终端输入如下命令，检查是否安装了`Cargo`：
```shell
$ cargo --version
```

### 使用Cargo创建项目
让我们使用`Cargo`来创建一个新项目：
```shell
$ cd ~/projects
$ cargo new hello_cargo --bin
$ cd hello_cargo
```
我们向 **`cargo new`** 传递了 **`--bin`** ，因为我们的目标是 **生成一个可执行程序，而不是一个库**。
可执行程序是二进制可执行文件，通常就叫做 **二进制文件**（`binaries`）。项目的名称被定为`hello_cargo`，
同时`Cargo`在一个 **同名目录** 中创建它的文件，接着我们可以进入查看。

如果列出`hello_cargo`目录中的文件，将会看到`Cargo`生成了一个文件和一个目录：**`Cargo.toml`** 文件和
一个 **`src`** 目录，`main.rs`文件位于目录中。它也在`hello_cargo`目录初始化了一个 **`git`仓库**，以及一个
**`.gitignore`文件**；你可以通过 **`--vcs`参数**，切换到其它版本控制系统（`VCS`），或者不使用`VCS`。

使用文本编辑器（`IDE`）打开`Cargo.toml`文件。它应该看起来像这样：
```ini
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["fuhd <sandy_cn_@hotmail.com>"]

[dependencies]

```
**这个文件使用`TOML`格式。TOML类似于INI，不过一些额外的改进之处，并且被用作`Cargo`的配置文件的格式**。

第一行，**`[package]`是一个段落标题，表明下面的语句用来配置一个包**。随着我们在这个文件增加更多的信息，
还将增加其他段落。

最后一行，**`[dependencies]`** 是项目依赖的 **`crates`（Rust代码包）** 的段落的开始，这样`Cargo`
就知道下载和编译它们了。这个项目并不需要任何其他`crate`。

现在看看`src/main.rs`：
```rust
fn main() {
    println!("Hello, world!");
}
```
`Cargo`为你生成了一个“Hello, world"，正如我们之前编写的那个！目前为止，之前项目与`Cargo`生成项目区别有：
+ 代码位于`src`目录；
+ 项目根目录包含一个`Cargo.toml`配置文件；

**`Cargo`期望源文件位于`src`目录，将项目根目录留给`README`、`license`信息、配置文件和其他跟代码无关的文件**。
这样，`Cargo`帮且你保持项目干净整洁，一切井井有条。

### 构建并运行Cargo项目
现在让我们看看通过`Cargo`构建和运行Hello World程序有什么不同。为此，输入如下命令：
```shell
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///home/fuhd/work/workspace/rust_projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 5.40 secs
```
这应该创建`target/debug/hello_cargo`可执行文件，可以通过这个命令运行：
```shell
$ ./target/debug/hello_cargo
Hello, world!
```
**首次运行`cargo build`的时候，`Cargo`会在项目根目录创建一个新文件`Cargo.lock`**，它看起来像这样：
```ini
[root]
name = "hello_cargo"
version = "0.1.0"
```
**`Cargo`使用`Cargo.lock`来记录程序的依赖**。这个项目并没有依赖，所以内容比较少。事实上，**你自己永远也不需要
碰这个文件**，让`Cargo`处理它就行了。

我们刚刚使用`cargo build`构建了项目并使用`./target/debug/hello_cargo`运行了它，**也可以使用`cargo run`
编译并运行**：
```shell
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```
注意这一次并没有出现“正在编译hello_cargo”的输出。`Cargo`发现文件并没有被改变，直接运行了二进制文件。
如果修改了源文件的话，将会出现像这样的输出：
```shell
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///home/fuhd/work/workspace/rust_projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.94 secs
     Running `/home/fuhd/work/workspace/rust_projects/hello_cargo/target/debug/hello_cargo`
Hello, world!!!!!!!!!!!!!!!!
```

### 发布构建
**当项目最终准备好发布了，可以使用`cargo build --release`来优化编译项目。这会在`target/release`
下生成可执行文件，而不是`target/debug`。优化可以让Rust代码运行的更快，然而也需要更长的编译时间。
因此产生了两种不同的配置：一种为了开发，你需要快速重新构建；另一种构建给用户的最终程序，不会重新构建，
并且程序运行得越快越好。如果你在测试代码的运行时间，请确保运行`cargo build --release`并使用
`target/release`下的可执行文件**。

### 把Cargo当作习惯
对于简单项目，`Cargo`并不比`rustc`更有价值，不过随着开发的进行终将体现它的价值。**对于拥有多个`crate`的
复杂项目，让`Cargo`来协调构建将更简单**。有了`Cargo`，只需运行`cargo build`，然后一切将有序运行。
即便这个项目很简单，它也使用了很多你之后的Rust生涯会用得上的实用工具。
