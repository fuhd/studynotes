使用和构建对象插件
=========================
通过打包成JAR文件，task可以在独立的项目间被完全重用。然而，该方法仍存在一些限制。让我们来看看打包的定制
task实现有哪些优缺点。

**优点：**
+ 定制逻辑在类中是自包含的，并可以通过增强型task配置。
+ 通过将task属性用注解标志可以支持声明式增量构建。
+ 定制的task可以测试。

**缺点：**
+ 定制的task仅仅暴露独立的工作单元。所提供的额外的公式化代码，约定和生命周期的整合并不是很直接。
+ 定制的task仅仅能通过增强型task来配置。通过自定义的DSL，缺乏有表达性的扩展机制。
+ 其他插件的功能不容易使用或扩展

对象插件给你最大的灵活性去封装高复杂度的逻辑，并且提供一种强大的扩展机制可以在构建脚本中定制它的行为。
和定制task类一样，你可以完全访问Gradle的公共API和工程模型。在本节，我们重新了解如何在构建脚本中使用
标准插件和第三方插件。接下来，我们会学习插件的内部，来深入理解构建块和机制。最后，你会应用所学到的知识
来编写自己的带有附加功能的对象插件。

### 使用对象插件
你已经知道可以通过`apply`方法来配置项目使用标准插件，它是`project`对象提供的`apply`方法，它是
`org.gradle.api.Project`类的实例。该方法定义了一个参数`options`，类型是`java.util.Map`。
#### 通过名字使用插件
插件的标识符，一个很短的名字，通过插件的元信息提供。要在项目中使用Java插件，传入键值对`plugin: 'java'`
，如下：
```gradle
apply plugin: 'java'
```
#### 通过类型使用插件
你也可以使用插件实现类的名字。如果插件没有暴露名字，或者两个不同插件命名冲突，那么这种方法是非常有用的，
通过类型来使用插件很明确，但也显得比较笨重：
```gradle
apply plugin: org.gradle.api.plugins.JavaPlugin
```
#### 使用外部插件
构建脚本并不知道外部插件的存在，直到你将它放入到`classpath`下。你可以通过使用`buildscript`方法来做
这件事，它定义了插件的位置，仓库和插件依赖。'buildscript'和'apply'方法的定义顺序是不相关的。下面显示了
如何使用外部插件`tomcat`将web应用部署到嵌入式和Tomcat容器中：
```gradle
buildscript{
  repositories{
    mavenCentral()
  }
  dependencies{
    classpath 'org.gradle.api.plugins:gradle-tomcat-plugin:0.9.7'
  }
}
apply plugins: 'tomcat'
```

### 解析对象插件
对于实现一个对象插件，有4个基本元素是非常重要的：
+ 在放置插件实现的位置方面,Gradle给你完全的灵活性。代码可以放在构建脚本中或者`buildSrc`目录下，也可以作为
一个独立的工程被开发并且以JAR文件方式发布。
+ 每个插件都需要提供一个实现类，它代表着插件的入口点。插件可以用任何JVM语言编写并编译成字节码。我倾向于Groovy，
因为能有效利用动态语言的特性和简洁性。然而，你也可以用Java或Scala语言去实现构建逻辑。
+ 应用到项目中的插件可以通过暴露出来的 **扩展对象** 进行定制。如果用户想要在构建脚本中覆盖插件的默认配置时，这一点很
有用。
+ **插件描述符** 是一个属性文件，它包含了关于插件的元信息。通常，它包含有插件的简短名字和插件实现类的映射。

### 编写对象插件
编写一个插件的要求是提供`org.gradle.api.Plugin<Project`接口的一个实现类。该接口仅仅定义了一个简单的方法：
`apply(Project)`。示例，现在你需要在项目的`buildSrc`目录下的`com.manning.gia.plugins.cloudbees`包下
创建一个插件的实现类：
```gradle
package com.manning.gia.plugins.cloudbees

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.plugins.WarPlugin
import com.manning.gia.plugins.cloudbees.tasks.*

class CloudBeesPlugin implements Plugin<Project>{
  @Override
  void apply(Project project){
    //应用WAR插件
    project.plugins.apply(WarPlugin)
    addTasks(project)
  }
  private void addTasks(Project project){
    project.tasks.withType(CloudBeesTask){
      //对于所有的CloudBees任务，我们自动给API URL，key和secret赋值
      apiUrl = 'https://api.cloudbees.com/api'
      apiKey = project.property('cloudbeesApiKey')
      secret = project.property('cloudbeesApiSecret')
    }
    addAppTasks(project)
  }
  private void addAppTasks(Project project){
    project.task('cloudBeesAppDeployWar',type: cloudBeesAppDeployWar){
      appId = project.hasProperty('appId')?project.appId:null
      messsage = project.hasProperty('messsage')?project.messsage:null
      warFile = project.hasProperty('warFile')?
        new File(project.getProperty('warFile')):
        //如果没有提供warFile属性，则将War插件产生的路径赋值给WAR文件
        project.tasks.getByName(WarPlugin.WAR_TASK_NAME).archivePath
    }
  }
}
```
在项目中使用该插件，你要做的是在`build.gradle`文件中使用插件的实现类型，示例：
```gradle
apply plugin: com.manning.gia.plugins.cloudbees.CloudBeesPlugin
```
为了验证task已经创建，运行`gradle tasks`命令，你应该能够看到`cloudBeesAppDeployWar`显示在列表中。

### 插件扩展机制
通过解析命令行参数来给task提供输入并不总是可取的。你可以通过暴露一个带有唯一命名空间的DSL来建立自己的
构建语言。下面示例，展示了一个名为`cloudBees`的闭包，允许从构建脚本中给task所需要的属性设值：
```gradle
cloudBees{
  apiUrl = 'https://api.cloudbees.com/api'
  apiKey = project.apiKey
  secret = project.secret
  appId = 'gradle-in-action/todo'
}
```
Gradle将语言结构模型化作为扩展。扩展可以被添加到许多Gradle对象中，比如Project或者task，只要它们是扩展可知的。
如果一个对象实现了`org.gradle.api.plugins.ExtensionAware`接口，就认为它是扩展可知的。每个扩展都是
一种数据模型，它是扩展的基础。这个模型可以是一个POJO或者Groovy Bean。下面展示了cloudBees插件的扩展模型：
```groovy
package com.manning.gia.plugins.cloudbees

class CloudBeesPluginExtension{
  String apiUrl
  String apiKey
  String secret
  String appId
}
```
你需要扩展应用了CloudBees插件的构建脚本背后的Project。扩展可知对象暴露了方法`extensions()`，它会返回一个
容器对象，通过一个名字来注册扩展模型。该容器的实现接口是`org.gradle.api.plugins.ExtensionContainer`。新
的扩展通过方法`create`来注册。该方法接受一个名字和模型类型作为参数。一旦扩展被注册，你就可以获取模型的值并将
它们赋值给定制task的属性。
