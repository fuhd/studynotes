使用task
========================
### 声明task动作
动作（action）就是在task中合适的地方文墨构建逻辑。Task接口（task由Task接口定义）提供了两个相关
的方法来声明task动作：`doFirst(Closure)`和`doLast(Closure)`。当task被执行的时候，动作逻辑
被定义为闭包参数，被依次执行。示例：
```gradle
version = '0.1-SNAPSHOT'
task printVersion {
  doLast{
    println "Version: $version"
  }
}
```
这个task的作用就是打印出当前的项目版本，这段逻辑放在doLast方法里面的。左移操作符（`<<`）就是`doLast`
方法的快捷版本。上面的示例与下面示例相同：
```gradle
version = '0.1-SNAPSHOT'
task printVersion << {
  println "Version: $version"
}
```
当然你把这段逻辑放到`doFirst`方法里面，也会得到同样的结果，示例如下：
```gradle
version = '0.1-SNAPSHOT'
task printVersion {
  doFirst{
    println "Version: $version"
  }
}
```
目前， 上面的示例我们只为task添加了一个动作doLast或者doFirst，但并不限于为每个task只添加一个动作。
事实上，在task创建后，你可以根据需要添加很多动作，doFirst先执行，doLast后执行。。示例：
```gradle
version = '0.1-SNAPSHOT'
task printVersion{
  doFirst{
    println "Before reading the project version"
  }
  doLast{
    println "Version: $version"
  }
}
printVersion.doFirst{println "First action"}
printVersion << {println "Last action"}
```
**最后加的doFirst最先执行，最后加的doLast最后执行！！！**

### 访问DefaultTask属性
有两个属性：`group`和`description`。它们都是task属性，`Task`接口默认由`DefaultTask`类实现。
这两个属性就是来自于`DefaultTask`类。`description`属性用于描述任务的作用，`group`属性则用于
定义task的逻辑分组。在创建task的时候，可以为这两个属性设置值作为参数，示例：
```gradle
task printVersion(group:'versioning',description:'prints project version.') << {
  //Gradle提供了一个基于SLF4J日志库的logger实现。通过Task的方法可以直接访问logger实例。
  logger.guiet "Version: $version"
}
```
或者:
```gradle
task printVersion{
  group = 'versioning'
  description = 'prints project version.'
  doLast{
    logger.quiet "Version: $version"
  }
}
```
当运行`gradle tasks`命令时，我们可以看到task正确的分组和描述信息。

### 定义task依赖
`dependsOn`方法允许声明依赖一个或多个task。示例：
```gradle
task first << {println "first"}
task second << {println "second"}
task printVersion(dependsOn: [second,first]) << {   //指定多个task依赖
  logger.quiet "Version: $version"
}
task third << {println "third"}
third.dependsOn('printVersion')   //声明依赖时按名称引用task
```
**注意：Gradle并不能保证task依赖的执行顺序**

上面示例，first与second哪个先执行，并不确定。`dependsOn`方法只是定义了所依赖的task需要先执行
，并没有定义它该如何执行。

### 终结器task
在实践中，你会发现所依赖的task执行后需要做一些其他处理。针对这种情况，Gradle提供了终结器（finalizer task）
，即使终结器失败了，Gradle的task也会按照预期运行（就好像开了一个子线程处理一些其他任务）。我们通过
Task方法`finalizedBy`来使用一个特定的终结器，示例：
```gradle
task first << {println "first"}
task second << {println "second"}
first.finalizedBy second    //就是执行完first就会触发second
```

### 添加任意代码
在Gradle脚本中定义通用的`Groovy`代码，示例：
```gradle
version = new ProjectVersion(0,1)
class ProjectVersion{
  Integer major
  Integer minor
  Boolean release
  ProjectVersion(Integer major,Integer minor){
    this.major = major
    this.minor = minor
    this.release = Boolean.FALSE
  }
  ProjectVersion(Integer major,Integer minor,Boolean release){
    this(major,minor)
    this.release = release
  }
  @Override
  String toString(){
    "$major.$minor${release?'':'-SNAPSHOT'}"
  }
}
```

### 理解task配置
#### 添加task配置块
示例：
```gradle
//version.properties是当前目录下的一个版本配置文件
//Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例
ext.versionFile = file('version.properties')
task loadVersion{
  //定义task配置(没有使用左移操作符)
  project.version = readVersion()
}
ProjectVersion readVersion(){
  logger.guiet 'Reading the version file.'
  if(!versionFile.exists()){
    throw new GradleException("Required version file does not exist: $versionFile.canonicalPath")
  }
  Propertis versionProps = new Propertis()
  versionFile.withInputStream{ stream ->
    versionProps.load(stream)
  }
  //在Groovy中，如果return是方法中最后一条语句的话，则可以将return省略
  new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),
    versionProps.release.toBoolean())
}
```
