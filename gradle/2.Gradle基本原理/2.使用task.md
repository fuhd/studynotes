使用task
========================
### 声明task动作
动作（action）就是在task中合适的地方文墨构建逻辑。Task接口（task由Task接口定义）提供了两个相关
的方法来声明task动作：`doFirst(Closure)`和`doLast(Closure)`。当task被执行的时候，动作逻辑
被定义为闭包参数，被依次执行。示例：
```gradle
version = '0.1-SNAPSHOT'
task printVersion {
  doLast{
    println "Version: $version"
  }
}
```
这个task的作用就是打印出当前的项目版本，这段逻辑放在doLast方法里面的。左移操作符（`<<`）就是`doLast`
方法的快捷版本。上面的示例与下面示例相同：
```gradle
version = '0.1-SNAPSHOT'
task printVersion << {
  println "Version: $version"
}
```
当然你把这段逻辑放到`doFirst`方法里面，也会得到同样的结果，示例如下：
```gradle
version = '0.1-SNAPSHOT'
task printVersion {
  doFirst{
    println "Version: $version"
  }
}
```
目前， 上面的示例我们只为task添加了一个动作doLast或者doFirst，但并不限于为每个task只添加一个动作。
事实上，在task创建后，你可以根据需要添加很多动作，doFirst先执行，doLast后执行。。示例：
```gradle
version = '0.1-SNAPSHOT'
task printVersion{
  doFirst{
    println "Before reading the project version"
  }
  doLast{
    println "Version: $version"
  }
}
printVersion.doFirst{println "First action"}
printVersion << {println "Last action"}
```
**最后加的doFirst最先执行，最后加的doLast最后执行！！！**

### 访问DefaultTask属性
有两个属性：`group`和`description`。它们都是task属性，`Task`接口默认由`DefaultTask`类实现。
这两个属性就是来自于`DefaultTask`类。`description`属性用于描述任务的作用，`group`属性则用于
定义task的逻辑分组。在创建task的时候，可以为这两个属性设置值作为参数，示例：
```gradle
task printVersion(group:'versioning',description:'prints project version.') << {
  //Gradle提供了一个基于SLF4J日志库的logger实现。通过Task的方法可以直接访问logger实例。
  logger.guiet "Version: $version"
}
```
或者:
```gradle
task printVersion{
  group = 'versioning'
  description = 'prints project version.'
  doLast{
    logger.quiet "Version: $version"
  }
}
```
当运行`gradle tasks`命令时，我们可以看到task正确的分组和描述信息。

### 定义task依赖
`dependsOn`方法允许声明依赖一个或多个task。示例：
```gradle
task first << {println "first"}
task second << {println "second"}
task printVersion(dependsOn: [second,first]) << {   //指定多个task依赖
  logger.quiet "Version: $version"
}
task third << {println "third"}
third.dependsOn('printVersion')   //声明依赖时按名称引用task
```
**注意：Gradle并不能保证task依赖的执行顺序**

上面示例，first与second哪个先执行，并不确定。`dependsOn`方法只是定义了所依赖的task需要先执行
，并没有定义它该如何执行。

### 终结器task
在实践中，你会发现所依赖的task执行后需要做一些其他处理。针对这种情况，Gradle提供了终结器（finalizer task）
，即使终结器失败了，Gradle的task也会按照预期运行（就好像开了一个子线程处理一些其他任务）。我们通过
Task方法`finalizedBy`来使用一个特定的终结器，示例：
```gradle
task first << {println "first"}
task second << {println "second"}
first.finalizedBy second    //就是执行完first就会触发second
```

### 添加任意代码
在Gradle脚本中定义通用的`Groovy`代码，示例：
```gradle
version = new ProjectVersion(0,1)
class ProjectVersion{
  Integer major
  Integer minor
  Boolean release
  ProjectVersion(Integer major,Integer minor){
    this.major = major
    this.minor = minor
    this.release = Boolean.FALSE
  }
  ProjectVersion(Integer major,Integer minor,Boolean release){
    this(major,minor)
    this.release = release
  }
  @Override
  String toString(){
    "$major.$minor${release?'':'-SNAPSHOT'}"
  }
}
```

### 理解task配置
#### 添加task配置块
示例：
```gradle
//version.properties是当前目录下的一个版本配置文件
//Project接口提供了file方法，它会创建一个相对于项目目录的java.io.File实例
ext.versionFile = file('version.properties')
task loadVersion{
  //定义task配置(没有使用左移操作符)
  project.version = readVersion()
}
ProjectVersion readVersion(){
  logger.guiet 'Reading the version file.'
  if(!versionFile.exists()){
    throw new GradleException("Required version file does not exist: $versionFile.canonicalPath")
  }
  Propertis versionProps = new Propertis()
  versionFile.withInputStream{ stream ->
    versionProps.load(stream)
  }
  //在Groovy中，如果return是方法中最后一条语句的话，则可以将return省略
  new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),
    versionProps.release.toBoolean())
}
```
乍一看，loadVersion这个task很像之前定义的其他task，但是如果仔细观察就会发现没有定义动作或者使用
左移操作符（`<<`），Gradle称之为 **task配置** 。**task配置块永远在task动作执行之前被执行**。
#### Gradle构建生命周期阶段
无论什么时候执行Gradle构建，都会运行三个不同的生命周期阶段：**初始化**,**配置** 和 **执行**。
在初始化阶段，Gradle为项目创建了一个`Project`实例。在给定的构建脚本中只定义了一个project。在多项目
构建中，这个构建阶段变得更加重要。初始化阶段后面紧接着的是配置阶段。

> 注意：项目每一次构建的任何配置代码都可以被执行————即使你只是执行`gradle tasks`

在执行阶段，所有的task都应该以正确的顺序被执行。执行顺序是由它们的依赖决定的。如果任务被认为没有修改
过，将被跳过。
#### 声明task的inputs和outputs
Gradle通过比较两个构建task的`inputs`和`outputs`来决定task是否是最新的。自从最后一个task执行以来，
如果`inputs`和`outputs`没有发生变化，则认为task是最新的。因此，只有当`inputs`和`outputs`不同时，
task才运行；否则将跳过。注：**`inputs`和`outputs`在`DefaultTask`类中被定义为属性。**
> inputs可以是一个目录，一个或多个文件，或者是一个任意属性。inputs是TaskInputs接口的实现，作为
> task也就是DefaultTask类的一个属性。TaskInputs的方法有：dir(dirPath: Object)，file(path: Object)
> ，files(paths: Object...)，property(name: String,value: Object)

> `outputs`可以是通过一个目录或1～n个文件来定义的。
