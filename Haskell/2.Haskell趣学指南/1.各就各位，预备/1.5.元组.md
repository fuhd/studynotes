元组
===============================================
**元组（tuple）** 允许我们将 **多个异构的值** 组合成为一个单一的值。从某种意义上讲，元组很像列表。
但它们却有着本质的不同。首先就像前面所说，元组是 **异构** 的，这表示 **单个元组** 可以含有 **多种类型** 的元素，
其次，元组的 **长度固定**，在将元素存入元组的同时，必须明确元素的 **数目**。

元组由 **圆括号**（`()`）括起，其中的项由 **逗号**（`,`）隔开：
```haskell
--(1,3)
(1,3)
--(50,50.4,"hello",'b')
(50,50.4,"hello",'b')
```
### 元组
为理解元组的用途，我们可以思考一下haskell中 **二维向量** 的表示方法。使用列表是可以的，按照[x,y]的形式，
它倒是工作良好。若要将一组向量置于一个列表中来表示二维坐标系中的平面图形又该怎样？
我们可以写个列表的列表，像这样：[[1,2],[8,11],[4,5]]。但是，如果遇到[[1,2],[8,11,5],[4,5]]
这样的列表并把它当做向量列表来使用，这种方法就有问题了。它并不是合法的向量列表，却是一个合法的列表的列表，
毕竟其中元素的类型都相同（数值的列表组成的列表）。有这种情况存在，编写处理向量与图形的函数将复杂得多。

然而 **长度为2** 的元组（也称作 **序对**，**pair**）与 **长度为3** 的元组（也称作 **三元组**，**triple**）
被视为 **不同的类型**。这便意味着一个 **包含一组序对的列表不能再加入一个三元组**。基于这个性质，
使用元组来表示向量无疑更加合适。

要将原先的向量改为用元组表示，可以把里面的方括号改为圆括号：
```haskell
{-
    [(1,2),(8,11,5),(4,5)]，如果不小心将二元组与三元组混到了一起，
    就会报错：Couldn't match expected type ‘(t, t1)’.....
-}
--[(1,2),(8,11),(4,5)]
[(1,2),(8,11),(4,5)]
```
同样，**即使两个元组的长度相同，但其中的元素的类型不一样，Haskell也会将它们视为不同的类型**。比如：
[(1,2),("one",2)]这样的列表就有问题，因为其中的第一个元组是一对数，而第二个元组却成了一个字符串和一个数。

**元组可以方便地用来表示一组数据的关联关系**。比如，我们要表示一个人的姓名与年龄，可以使用这样的三元组：
```haskell
(“Christopher”,"Waiken",55)
```
**注**：需要记住，元组是 **固定大小** 的————使用元组时应事先了解它里面含有多少项，**每个不同长度的元组都是独立的类型**。
同列表相同，**只要其中的项是可比较的，元组也可以比较大小**，只是不可以像比较不同长度的列表那样比较不同长度的元组。另外，
**可以有单元素的列表，但元组不行**。

#### 使用序对
在Haskell中，将数据保存在序对里十分常见。对此，Haskell内置了许多有用的函数来处理序对。
下面给出的是其中的两个函数。
+ `fst`函数：取一个序对作为参数，返回其 **首项**：
```haskell
--8
fst (8,11)
--"Wow"
fst ("Wow", False)
```
+ `snd`函数：取一个序对作为参数，返回其 **尾项**：
```haskell
--11
snd (8,11)
--False
snd ("Wow", False)
```
**注意**：**这两个函数仅对序对有效**，而不能应用于三元组，四元组和五元组等之上。
+ `zip`函数：**可以用来生成一组序对的列表**。它取 **两个列表** 作为参数，然后将它们 **交叉配对**，形成一组序对。
```haskell
--[(1,5),(2,5),(3,5),(4,5),(5,5)]
zip [1,2,3,4,5] [5,5,5,5,5]
--注意，由于序对中可以含有不同的类型，zip函数也可以将不同类型的序对组合在一起。
--[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
zip [1..5] ["one","two","three","four","five"]
--[(5,"im"),(3,"a"),(2,"turtle")]
--可见，较长的列表会在中间断开，至较短的列表结束为止，余下的部分就直接忽略掉了。
zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
--由于Haskell是惰性的，我们也可以使用zip组合有限的和无限的列表
--[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
zip [1..] ["apple","orange","cherry","mango"]
```

### 运用：找直角三角形
思考一道同时用到 **元组**与 **列表推导式** 的题目，使用Haskell来找到所有满足下列条件的直角三角形：
+ 三边长度皆为整数；
+ 三边长度皆小于等于10；
+ 周长为24的直角三角形；

首先，把所有三个元素都小于等于10的元组都列出来：
```haskell
[(a,b,c) | c <- [1..10], a <- [1..10], b <- [1..10]]
```
我们在三个列表中取值，并且左侧的输出部分将它们组合为一个三元组。

我们接下来给它添加一个过滤条件，使其符合勾股定理（a^2 + b^2 = C^2）。同时也考虑上a边要短于斜边（c边），
b边要短于a边情况：
```haskell
[(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2]
```
注意，在这里我们限制了求解的区间，不再检查多余的三元组。

最后修改函数，告诉它只要周长为24的三角形：
```haskell
[(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c == 24]
```
