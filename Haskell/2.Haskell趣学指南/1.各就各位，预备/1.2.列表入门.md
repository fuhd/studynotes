列表入门
===========================================
在Haskell中，**列表** 是一种 **单类型** 的 **数据结构**，可以用来存储 **多个类型相同的元素**。
列表由 **方括号** 括起，其中的元素用 **逗号** 分隔开来：
```haskell
let lostNumbers = [4,5,6,7,8,9]
```
**注意**：在GHCi中，可以使用 **let** 关键字来定义一个 **常量**。在GHCi中执行`let a = 1`与在脚本中编写`a = 1`
随后用`:l`装载的效果是等价的。

### 拼接列表
#### `++`运算符
拼接两个列表可以算是最常见的操作之一了，在Haskell中这可以通过`++`运算符实现：
```haskell
--例1
[1,2,3,4,5] ++ [6,7,8,9,10]
--例2
"hello" ++ " " ++ "world"
--例3
['w','o'] ++ ['o','t']
```
**注意**：Haskell中的 **字符串** 实际上就是 **一组字符组成的列表**。“hello”只是['h','e','l','l','o']的语法糖而已。
因此，我们可以使用处理列表的函数来对字符串进行操作。

在使用`++`运算符处理 **长字符串** 时要格外小心（对 **长的列表** 也是同样），Haskell会 **遍历** 整个第一个列表
（`++`符号 **左边的列表**）。在处理较短的字符串时问题还不大，但要是在一个长度为5000万的列表上追加元素，
那可得执行好一会儿了。

`++`运算符总是取 **两个列表** 作为参数。若要使用`++`运算符 **拼接单个元素** 到一个列表的最后，必须用 **方括号** 把它括起来，
使之成为单元素的列表，示例：
```haskell
--正确
[1,2,3,4] ++ [5]
--错误，因为++运算符两边都必须是列表才行！
[1,2,3,4] ++ 5
```
#### `:`运算符
不过，仅仅将一个元素 **插入列表头部的成本几乎为零**，这里使用`：`运算符即可：
```haskell
--例1
'A' : " SMALL CAT"
--例2
5 : [6,7,8,9]
```
**注意**：`:`运算符的第一个参数的类型一定要与第二个参数中列表中元素的类型保持一致。

有趣的是，[1,2,3]实际上是1:2:3:[]的语法糖。`[]`表示一个空列表，若从前端插入3，它就成了[3]，
再插入2，它就成了[2,3]，依此类推。

**注意**：`[]`，`[[]]`和`[[],[],[]]`是不同的，第一个是一个空列表，第二个是含有一个空列表的列表，
第三个是含有三个空列表的列表。

### 访问列表中的元素
若是要按照索引取得列表中的元素，可以使用`!!`运行符，下标从`0`开始：
```haskell
--结果为'B'
"Steve Busceml" !! 6
--结果为33.2
[9.4,33.2,96.2,11.2,23.25] !! 1
```
### 嵌套列表
列表同样也可以 **以列表为元素**，甚至是列表的列表的列表：
```haskell
let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
```
**注：列表中的列表可以是不同长度的，但类型必须相同**。

### 比较列表
只要列表内的元素是可以比较的，那就可以使用`<`，`>`，`>=`，`<=`来比较两个列表的大小。
它会按照 **字典顺序**，先比较两个列表的第一个元素，若它们的值相等，则比较二者的第二个元素，
如果第二个仍然相等，再比较第三个，依此类推，直至遇到不同为止。**两个列表的大小以二者第一个不等的元素的大小为准**。
比如，执行`[3,4,2]<[3,4,3]`时，Haskell就会发现3与3相等，随后比较4与4，依然相等，再比较2与3，
这时就得出结论了：第一个列表比第二个列表小。>，>=与<=也是同样的道理。示例：
```haskell
--True
[3,2,1] > [2,1,0]
--True
[3,2,1] > [2,10,100]
--True
[3,4,2] < [3,4,3]
--True
[3,4,2] < [2,4]
--True
[3,4,2] == [3,4,2]
```
此外，**非空列表总认为比空列表更大**。这样即可保证两个列表总是可以顺利地做比较，即使其中一个列表完全等同于
另一个列表的开头部分。

### 更多列表操作
