列表入门
===========================================
在Haskell中，**列表** 是一种 **单类型** 的 **数据结构**，可以用来存储 **多个类型相同的元素**。
列表由 **方括号** 括起，其中的元素用 **逗号** 分隔开来：
```haskell
let lostNumbers = [4,5,6,7,8,9]
```
**注意**：在GHCi中，可以使用 **let** 关键字来定义一个 **常量**。在GHCi中执行`let a = 1`与在脚本中编写`a = 1`
随后用`:l`装载的效果是等价的。

### 拼接列表
#### `++`运算符
拼接两个列表可以算是最常见的操作之一了，在Haskell中这可以通过`++`运算符实现：
```haskell
--例1
[1,2,3,4,5] ++ [6,7,8,9,10]
--例2
"hello" ++ " " ++ "world"
--例3
['w','o'] ++ ['o','t']
```
**注意**：Haskell中的 **字符串** 实际上就是 **一组字符组成的列表**。“hello”只是['h','e','l','l','o']的语法糖而已。
因此，我们可以使用处理列表的函数来对字符串进行操作。

在使用`++`运算符处理 **长字符串** 时要格外小心（对 **长的列表** 也是同样），Haskell会 **遍历** 整个第一个列表
（`++`符号 **左边的列表**）。在处理较短的字符串时问题还不大，但要是在一个长度为5000万的列表上追加元素，
那可得执行好一会儿了。

`++`运算符总是取 **两个列表** 作为参数。若要使用`++`运算符 **拼接单个元素** 到一个列表的最后，必须用 **方括号** 把它括起来，
使之成为单元素的列表，示例：
```haskell
--正确
[1,2,3,4] ++ [5]
--错误，因为++运算符两边都必须是列表才行！
[1,2,3,4] ++ 5
```
#### `:`运算符
不过，仅仅将一个元素 **插入列表头部的成本几乎为零**，这里使用`：`运算符即可：
```haskell
--例1
'A' : " SMALL CAT"
--例2
5 : [6,7,8,9]
```
**注意**：`:`运算符的第一个参数的类型一定要与第二个参数中列表中元素的类型保持一致。

有趣的是，[1,2,3]实际上是1:2:3:[]的语法糖。`[]`表示一个空列表，若从前端插入3，它就成了[3]，
再插入2，它就成了[2,3]，依此类推。

**注意**：`[]`，`[[]]`和`[[],[],[]]`是不同的，第一个是一个空列表，第二个是含有一个空列表的列表，
第三个是含有三个空列表的列表。

### 访问列表中的元素
若是要按照索引取得列表中的元素，可以使用`!!`运行符，下标从`0`开始：
```haskell
--结果为'B'
"Steve Busceml" !! 6
--结果为33.2
[9.4,33.2,96.2,11.2,23.25] !! 1
```
### 嵌套列表
列表同样也可以 **以列表为元素**，甚至是列表的列表的列表：
```haskell
let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
```
**注：列表中的列表可以是不同长度的，但类型必须相同**。

### 比较列表
只要列表内的元素是可以比较的，那就可以使用`<`，`>`，`>=`，`<=`来比较两个列表的大小。
它会按照 **字典顺序**，先比较两个列表的第一个元素，若它们的值相等，则比较二者的第二个元素，
如果第二个仍然相等，再比较第三个，依此类推，直至遇到不同为止。**两个列表的大小以二者第一个不等的元素的大小为准**。
比如，执行`[3,4,2]<[3,4,3]`时，Haskell就会发现3与3相等，随后比较4与4，依然相等，再比较2与3，
这时就得出结论了：第一个列表比第二个列表小。>，>=与<=也是同样的道理。示例：
```haskell
--True
[3,2,1] > [2,1,0]
--True
[3,2,1] > [2,10,100]
--True
[3,4,2] < [3,4,3]
--True
[3,4,2] < [2,4]
--True
[3,4,2] == [3,4,2]
```
此外，**非空列表总认为比空列表更大**。这样即可保证两个列表总是可以顺利地做比较，即使其中一个列表完全等同于
另一个列表的开头部分。

### 更多列表操作
#### head函数
head函数返回一个列表的 **头部**，也就是列表的 **第一个元素**。示例：
```haskell
--5
head [5,4,3,2,1]
```
#### tail函数
tail函数返回一个列表的 **尾部**，也就是列表 **除去头部之后的部分**，它与head函数互反。示例：
```haskell
--[4,3,2,1]
tail [5,4,3,2,1]
```
#### last函数
last函数返回一个列表的 **最后一个元素**。示例：
```haskell
--1
last [5,4,3,2,1]
```
#### init函数
init函数返回一个列表 **除去最后一个元素的部分**，与last函数互反。示例：
```haskell
--[5,4,3,2]
init [5,4,3,2,1]
```
**注意**：在使用`head`，`tail`，`last`和`init`时要小心，**不要用到空列表，否则会报异常**！！
所以说做些工作以防止Haskell从空列表中取值是一个好的习惯。
#### length函数
length函数返回一个 **列表的长度**，示例：
```haskell
--5
length [5,4,3,2,1]
```
#### null函数
null函数检查一个列表 **是否为空**。如果是，则返回True，否则返回False。示例：
```haskell
--False
null [3,2,1]
--True
null []
```
#### reverse函数
reverse函数将一个列表 **反转**，示例：
```haskell
--[1,2,3,4,5]
reverse [5,4,3,2,1]
```
#### take函数
take函数返回列表中 **指定的前几个元素**，以一个数字和一个列表做为参数。示例：
```haskell
--[5,4,3]
take 3 [5,4,3,2,1]
--[3]
take 1 [3,8,5]
--[1,2]
take 5 [1,2]
--[]
take 0 [6,6,6]
```
如上，若是 **试图取超过列表长度的元素个数，只能得到原先的列表。若取0个元素，就会得到一个空列表**。
#### drop函数
drop函数是 **删除一个列表中指定的前几个元素**，用法大体与take函数相同，好像与take函数互反。示例：
```haskell
--[1,5,6]
drop 3 [8,4,2,1,5,6]
--[1,2,3,4]
drop 0 [1,2,3,4]
--[]
drop 100 [1,2,3,4]
```
#### maximum函数与minimum函数
maximum函数取一个列表作为参数，并 **返回最大的元素**，其中的 **元素必须可以做比较**。minimum函数与之相似，
不过是 **返回最小的元素**。示例：
```haskell
--9
maximum [1,9,2,3,4]
--1
minimum [8,4,2,1,5,6]
```
#### sum函数与product函数
sum函数返回一个列表中 **所有元素的和**。product函数返回一个列表中 **所有元素的积**。示例：
```haskell
--31
sum [5,2,1,6,3,2,5,7]
--24
product [6,2,1,2]
--0
product [1,2,5,6,7,9,2,0]
```
#### elem函数
elem函数可用来 **判断一个元素是否包含于一个列表**，通常以 **中缀函数** 的形式调用它，这样更加清晰。示例：
```haskell
--True
4 ｀elem｀ [3,4,5,6]
--False
10 ｀elem｀ [3,4,5,6]
```
