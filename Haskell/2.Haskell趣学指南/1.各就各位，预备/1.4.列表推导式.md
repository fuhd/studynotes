列表推导式
==========================================
**列表推导式（list comprehension）是一种过滤，转换或者组合列表的方法。**

例如，前10个偶数的集合怎么表示？若要在Haskell中实现，我们可以通过类似：
```haskell
take 10 [2,4 ..]
```
这样的代码来实现。不过使用列表推导式也是同样的轻而易举：
```haskell
--[2,4,6,8,10,12,14,16,18,20]
[x * 2 | x <- [1 .. 10]]
```
在`[x*2|x<-[1..10]]`这段代码中，我们通过`[x<-[1..10]]`取了`[1..10]`这个列表中的每一项元素，
x即`[1..10]`中的每一项元素的值，也可以说，x是`[1..10]`中每一项元素的绑定。**竖线（|）*前面的部分指
列表推导式的输出，表示所取的值与计算结果的映射关系**。在这个例子里，我们就是取`[1..10]`中的所有数字的2倍了。

看起来，这个例子要比第一个例子长得多，也复杂得多。但是遇到更复杂的情况时，才是列表推导式大显身手的时候。
比如，我们想给这个列表推导式再添一条 **谓词（predicate）**。**它位于列表推导式最后面，与前面的部分由一个逗号分隔**。
在这里，我们只取乘以2后大于等于12的元素：
```haskell
--[12,14,16,18,20]
[x * 2 | x <- [1 .. 10], x * 2 >= 12]
```
若是取50~100中所有除7的余数为3的元素该怎么办？很简单：
```haskell
--[52,59,66,73,80,87,94]
[x | x <- [50 .. 100], x `mod` 7 == 3]
```
