列表推导式
==========================================
**列表推导式（list comprehension）是一种过滤，转换或者组合列表的方法。**

### 最普通的列表推导式
例如，前10个偶数的集合怎么表示？若要在Haskell中实现，我们可以通过类似：
```haskell
take 10 [2,4 ..]
```
这样的代码来实现。不过使用列表推导式也是同样的轻而易举：
```haskell
--[2,4,6,8,10,12,14,16,18,20]
[x * 2 | x <- [1 .. 10]]
```
在`[x*2|x<-[1..10]]`这段代码中，我们通过`[x<-[1..10]]`取了`[1..10]`这个列表中的每一项元素，
x即`[1..10]`中的每一项元素的值，也可以说，x是`[1..10]`中每一项元素的绑定。**竖线（|）*前面的部分指
列表推导式的输出，表示所取的值与计算结果的映射关系**。在这个例子里，我们就是取`[1..10]`中的所有数字的2倍了。

### 带一个谓词的列表推导式
看起来，这个例子要比第一个例子长得多，也复杂得多。但是遇到更复杂的情况时，才是列表推导式大显身手的时候。
比如，我们想给这个列表推导式再添一条 **谓词（predicate）**。**它位于列表推导式最后面，与前面的部分由一个逗号分隔**。
在这里，我们只取乘以2后大于等于12的元素：
```haskell
--[12,14,16,18,20]
[x * 2 | x <- [1 .. 10], x * 2 >= 12]
```
若是取50~100中所有除7的余数为3的元素该怎么办？很简单：
```haskell
--[52,59,66,73,80,87,94]
[x | x <- [50 .. 100], x `mod` 7 == 3]
```
**注意**：从一个列表中筛选出符合特定谓词的元素的操作，也称为 **过滤（filter）**。

再举个例子，假如我们想要一个列表推导式，它能够使列表中所有大于10的奇数变为“BANG”，小于10的奇数变为“BOOM”，
其他则统统扔掉。方便起见，我们将这个列表推导式置于一个函数中：
```haskell
boomBangs xs = [if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
```
odd函数判断一个数是否为奇数，如果是，返回True，否则返回False。某项元素只有满足所有谓词时，才会被列表推导式留下。
```haskell
--["BOOM!","BOOM!","BANG!","BANG!"]
boomBangs [7 .. 13]
```
**注意**：记住，如果是在`GHCi`中定义这个函数，必须在函数名前面放一个`let`关键字。不过将函数写在脚本里再装载到`GHCi`
的话就不必再加`let`了。

### 带多个谓词的列表推导式
也可以加 **多个谓词**，中间用 **逗号** 隔开。比如，取10~20中所有不等于13，15或19的数：
```haskell
--[10,11,12,14,16,17,18,20]
[x | x <- [10 .. 20],x /= 13, x /= 15, x /= 19]
```

### 带多个列表的列表推导式
除了多项谓词之外，从 **多个列表** 中取元素也是可以的。当分别从多个列表中取元素时，将得到这些列表中元素的 **所有组合**：
```haskell
--[11,101,1001,12,102,1002,13,103,1003]
[x + y | x <- [1,2,3], y <- [10,100,1000]]
```
这里的x取自`[1,2,3]`，y取自`[10,100,1000]`。随后这两个列表按照如下的方式组合：首先x成为1，
同时y分别取`[10,100,1000]`中的每一个值。由于列表推导式的输出为`x+y`，可得到11，101，1001作为结果
的开头部分。随后x成为2，同理可得12,102,1002，追加到结果的后面。对3也同理。
