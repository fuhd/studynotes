区间
===========================================
该怎样得到一个由1~20所有数组成的列表呢？我们完全可以用手把它们全都录入一遍，但显而易见，这并不是完美方案。
完美方案就是使用 **区间（range）**。区间是构造列表的方法之一，而其中的值必须是 **可枚举** 的，
或者说， 是可以 **排序** 的。例如，**数字** 可以枚举为1，2，3，4，5等。**字符** 同样也可以枚举：
字母表就是A~Z所有字符的枚举。

要得到包含1~10中所有自然数的列表，只要录入[1..10]即可，这与录入[1,2,3,4,5,6,7,8,9,10]完全等价。示例：
```haskell
--[1,2,3,4,5,6,7,8,9,10]
[1..10]
--"abcdefghijklmnopqrstuvwsyz"
['a'..'z']
--"KLMNOPQRSTUVWSYZ"
['K'..'Z']
```
区间很聪明，允许你告诉它一个 **步长**。要得到1～20中所有的偶数，或者3的倍数该怎样？只要 **用逗号将前两个元素隔开，
再标上区间的上限就好了**：
```haskell
--[2,4,6,8,10,12,14,16,18,20]
[2,4..20]
--[3,6,9,12,15,18]
[3,6..20]
```
**注意**：要得到从20到1之间的列表，**[20..1]是不可以的，必须得[20,19..1]**。对于没有提供 **步长** 的区间（如：[20..1]），
haskell会先构造一个空的列表，随后从区间的下限开始，不停地增长，直到大于等于上限为止。既然20已经大于1了，
那么所得的结果只能是个 **空列表**。

取前24个13的倍数该怎样？一种方法是：
```haskell
--[13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247,260,273,286,299,312]
[13,26..13*24]
```
但有一个更好的方法————**使用无限长度列表**：
```haskell
take 24 [13,26..]
```
**由于haskell是惰性的，它不会对无限长度的列表直接求值**（不然会没完没了）。它会等着，看你会从它那儿取哪些元素。
在这里它见你只要前24个元素，便欣然交差。

注意：在区间中使用浮点数要格外小心！浮点数依据定义，只能实现有限的精度。若是在区间中使用浮点数，
你就会得到如下的糟糕结果：
```haskell
--[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
[0.1,0.3..1]
```

### 几个生成无限列表的函数
#### cycle函数
`cycle`函数接受一个列表作为参数并返回一个无限列表，就是把列表叁数无限次拼接。示例：
```haskell
--[1,2,3,1,2,3,1,2,3,1]
take 10 (cycle [1,2,3])
--"LOL LOL LOL "
take 12 (cycle "LOL ")
```
#### repeat函数
`repeat`函数接受一个值作为参数，并返回一个仅包含该值的无限列表。这与用用`cycle`函数处理单元素列表的效果差不多。
```haskell
--[5,5,5,5,5,5,5,5,5,5]
take 10 (repeat 5)
```
#### replicate函数
若只是想得到包含相同元素的列表，直接使用`replicate`函数将更加简单，它取一个参数表示列表的长度，
一个参数表示列表中要复制的元素：
```haskell
--[10,10,10]
replicate 3 10
```
