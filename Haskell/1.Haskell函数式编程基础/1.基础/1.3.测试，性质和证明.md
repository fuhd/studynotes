测试，性质和证明
===================================
在Haskell中可以测试程序，也应该测试程序。不过，Haskell能够提供另外两种更有力的选择，即 **基于性质的测试和证明**。

### 测试与性质
如何进行测试呢？一种测试的方法是描述如下形式的测试：“如果给函数这样的输入 ...... 那么输出应该是这样的”。
例如：

“如果将一个图形在平面镜中翻转两次，结果和原来的图形一样”；

代码：
```Haskell
test_rotate, test_flipV, test_flipH :: Bool
test_rotate = flipV(flipH horse) == flipH(flipV horse)
test_flipV = flipV(flipV horse) == horse
test_flipH ＝ flipH(flipV horse) == horse
```
前两个测试通过，给出结果True，第三个测试没有通过。这些测试只检查了一个输入，尽管这个输入horse不亚于任何例子，
程序员应该考虑做尽可能多的测试。**基于性质的测试工具：QuickCheck** 可以检查一个性质对大量随机生成的输入是否成立。

**什么是性质呢？** 粗略地讲，一个性质就像先前给出的说明“如果在镜子中翻转一个图形两次，那么应该得到原先的图形”，
其中图形可以是任意图形。我们可以将这样的性质表达成Haskell函数：
```Haskell
prop_rotate, prop_flipV, prop_flipH :: Picture -> Bool
prop_rotate pic = flipV(flipH pic) == flipH(flipV pic)
prop_flipV pic = flipV(flipV pic) == pic
prop_flipH pic = flipH(flipV pic) == pic
```
与前面测试的区别是，**这些性质应用于任意的输入** ，而不是一个输入horse。如果将命令QuickCheck应用于一个性质，
例如：
```Haskell
quickCheck prop_rotate
```
然后在Haskell下运行，对于前两个性质，系统会输出下列结果：
```
+++ OK, passed 100 tests.
```
对于最后一个测试，系统会输出如下结果：
```
*** Failed! Falsifiable (after 3 tests and 3 shrinks):
["ab"]
```
这个结果给出两个信息：该性质并非总是真的，另外给出一个性质不成立的例子。

**以上测试是自动的：只要写出函数的性质，系统会按照类型随机生成测试数据。**

### 覆盖率
以上基于性质的测试已经用100个随机输入代替了一个输入，但是，系统仍然有可能不幸地在随机生成的数据中漏掉了使得性质
不成立的测试数据。

**证明可以说明一个函数的完全正确性。**

**普通测试** 可以检查对于用户仔细选择的少量几个点；**基于性质的测试** 将测试数据扩展到几百个随机生成的点，
但是也可能漏掉出错的点；**证明** 覆盖了所有的可能性，没有例外。

### 证明
**证明** 是说明某命题 **在所有情况下都成立的逻辑的或者数学的论证**。那么证明和函数式程序设计有何关系呢？
对于多数程序设计语言来说，对程序进行证明是可能的，但是 **程序证明** 对于 **函数式程序设计语言** 比其它任何模式
的语言简单得多。

**证明** 确保函数具有某个特定的性质。将之与通常进行的 **测试** 和 **基于性质的测试** 进行比较。
无论是哪种测试，测试只能说明函数在测试点具有某种性质，而在原则上并不能告诉我们函数在其他情形是否具有此性质。
在事关生命财产安全的情况下，我们期望确保程序按照计划运行，在这里 **证明** 便是最好的保证。不过，
并不是说测试不重要。测试和证明在软件开发过程中具有互补的作用。
