守卫
=======================================
一个 **守卫（guard）** 是 **在函数定义中表示不同情况的布尔表达式**。

示例，取两个数的最大值：
```haskell
max :: Integer -> Integer -> Integer
max x y
  | x >= y      = x
  | otherwise   = y
```
**解释：** 如果第一个条件（此处为x>=y）为True，则相应的值便是函数的结果（此处为x）另一方面，
如果第一个条件为False，那么顺序检查第二个条件，第三个条件等。条件otherwise对任意参数均成立，因此，
在上例的情况中，当x>=y时，max的值为x，否则，即y>x时，其值为y。

又例，含有多个守卫的示例：
```haskell
maxThree :: Integer -> Integer -> Integer -> Integer
maxThree x y z
  | x >= y && x >= z      = x
  | y >= z                = y
  | otherwise             = z
```

### 使用守卫定义函数的一般格式
```haskell
name x1 x2 ...xk
  | g1          = e1
  | g2          = e2
  ...
  | otherwise   = e
```
name为 **函数名**；x1，x2一直到xk都是 **形参**；g1，g2到otherwise都是 **守卫条件**；
e1，e2到e都是 **相应的各种结果**。注意，**其中的条件otherwise并非是必需的**。

### 守卫的计算过程
以上面的maxThree函数为例：
```haskell
maxThree 6 (4 + 3) 5
```
计算过程如下：
```
——> 6 >= (4+3) && 6 >= 5
——> 6 >= 7 && 6 >= 5
——> False && True
——> False
——> 7 >= 5
——> True

——> 7
```
在这个例子中，首先计算第一个守卫6>=(4+3)&&6>=5，其结果为False;所以我们继续计算第二个守卫7>=5，
其值为True，所以结果为7。

**注意：(4+3)这个参数不是计算好了再传进来的，这是惰性计算方面内容。**

第二个参数(4+3)的值 **一旦计算过，再一次遇到它时，不需要重新计算它的值**。GHCi系统对(4+3)这样的参数，
只计算一次它的值，并将其值保存起来以备后用。

### 相关内容：条件表达式
守卫是函数定义中区别不同情形的条件。其实还可以使用haskell的`if...then...else`结构编写一般 **条件表达式**：
```haskell
if condition then m else n
```
当条件condition为True时，其值为m；当条件condition为False时，其值为n；示例：
```haskell
max' :: Integer -> Integer -> Integer
max' x y = if x >= y then x else y
```
我们通过使用守卫的格式定义分情形函数，但有的时候使用`if...then...else`显得更自然。

**注意： else部分是不可省略的！！！！！**
在haskell中，**程序是一系列函数的集合**：函数取数据作为参数，并将它们转为想要的结果。**每个函数都会返回一个结果，
也都可以为其他函数所用**。既然必须返回结果，那么每个`if`就必须同时跟着一个`else`，不管条件满足还是失败，
都需要返回一个结果。一言以蔽之，haskell中的`if`是一个 **必然返回结果的表达式**（expression），**而非语句**（statement）。

#### 使用上例演示基于性质的测试
```haskell
import Test.QuickCheck

max' :: Integer -> Integer -> Integer
max' x y = if x >= y then x else y

--测试
prop_compareMax :: Integer -> Integer ->Bool
prop_compareMax x y = max x y == max' x y
```
测试结果为：
```
*Main> quickCheck prop_compareMax
+++ OK, passed 100 tests.
```
