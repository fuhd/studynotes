逐步求解问题：局部定义
=======================================
**函数定义中的局部定义：这些局部定义可能是求解问题中有用的函数，或者有用的中间值。**

### 例子
在模块`PicturesSVG.hs`中定义一个有关图形的函数，假如函数的输入是马的图形，那么函数输出图示的图形（见书：64页的图，这里省略）。

解决该问题的一种方法是：
```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
  where
    left = ...
    right = ...
```
其中`where`后的 **局部定义** 给出`left`和`right`的定义。这些定义称为 **局部** 的原因是 **它们
只能用于函数`fourPics`的定义中，不可用于其他地方**。

所以，原问题分解成了两个子问题，每个问题均比原问题简单。首先看`left`，这个图形是将一个图形`pic`
放置在它的反色图形之上形成的，由此得到：
```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
  where
    left = pic `above` invertColour pic
    right = ...
```
接下来有 **多种** 方法完成函数的定义。下面列出 **4** 种方法：
+ **从零开始定义** `right`，如：

```haskell
fourPics :: Picture -> Picture
fourPics =
  left `beside` right
  where
    left = pic `above` invertColour pic
    right = invertColour (flipV pic) `above` flipV pic
```
+ **通过添加另一个局部定义修改函数的定义**。这里可以定义`flipped`表示图形`pic`在垂直镜子中的翻转，
这种定义方式类似于`left`的定义方法。

```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
  where
    left = pic `above` invertColour pic
    right = invertColour flipped `above` flipped
    flipped = flipV pic
```
+ **在`right`定义中使用`left`**：将`left`在垂直镜子中翻转，然后反色即可得到`right`，由此得到下列定义：
```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
  where
    left = pic `above` invertColour pic
    right = invertColour (flipV left)
```
+ **最后，可以定义一个只能用于`fourPics`定义，不可用于其他地方的局部函数**。函数`stack`将一个图形
放置在其反色图形上，这个函数将用于`left`和`right`的定义。
```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
  where
    stack p = p `above` invertColour p
    left = stack pic
    right = stack (invertColour (flipV pic))
```

另一个更数学化的例子是定义一个函数，对于任意给定三边长度为a,b,c的三角形，计算该三角形的面积。
计算面积的公式是：s*(s-a)*(s-b)*(s-c)的平方根，其中s=(a+b+c)/2。该函数的haskell定义为：
```haskell
triArea :: Float -> Float -> Float -> Float
triArea a b c
  |possible     = sqrt(s*(s-a)*(s-b)*(s-c))
  |otherwise    = 0
  where
    s = (a+b+c)/2
    possible = a+b>c && a+c>b && b+c>a && a>0 && b>0 && c>0
```
其中`possible`的局部定义要求是：三个边能够组成三角形时，`possible`才是True，每个边都应该是正数，
而且每个边都满足三角形不等式（每个边都小于其它两个边之和）。
#### let表达式中使用局部定义
let表达式中也可以使用 **局部定义**。例如：
```haskell
let x = 3+2 in x^2 + 2*x - 4
```
其结果是31。如果同一行包含 **多个局部定义**，应该用 **分号** 将它们隔开来，如：
```haskell
let x = 3+2; y=5-1 in x^2 + 2*x -y
```
不过这种形式只是偶尔会用到。

### 局部定义的计算
现在介绍局部定义的计算，以返回两个整数平方和的函数为例：
```haskell
sumSquares :: Integer -> Integer -> Integer
sumSquares n m =
  sqN + sqM
  where
  sqN = n*n
  sqM = m*m
```
其中`where`后的子句用于求两个数的平方。计算过程如下：
```
sumSquares 4 3
  sqN + sqM
  -----> where
  -----> sqN = 4*4 = 16
  -----> sqM = 3*3 = 9
  -----> = 16+9
  -----> = 25
```
**在`where`之下的局部定义的值在需要时被计算**。

### 版面格式
在带有`where`子句的定义中，版面格式是很重要的，系统用 **越位规则** 确定`where`子句定义的结尾。
`where`子句必须在它所属的定义中，所以它 **必须位于它所属定义起始位置的右边**。在`where`子句中
适用同样的规则。所以，**定义的书写垂直对齐很重要，否则会引起错误**。我们推荐的版面格式为：
```haskell
f p1 p2 ... pk
  |g1 = e1
  ...
  |otherwise = er
  where
  v1 a1 ... an = r1
  v2 = r2
  ...
```
这里的`where`子句附属于整个条件等式，也就是附属于条件等式的所有子句。这个例子也表明 **局部定义可以包含
函数**，这里`v1`是一个局部函数定义。**类似于顶层函数有类型说明，同样，用`where`定义的对象也可以有类型
说明**。如果在上下文中难以确定一个局部定义的对象的类型，我们的习惯是添加其类型说明。
