逐步求解问题：局部定义
=======================================
**函数定义中的局部定义：这些局部定义可能是求解问题中有用的函数，或者有用的中间值。**

### 例子
在模块`PicturesSVG.hs`中定义一个有关图形的函数，假如函数的输入是马的图形，那么函数输出图示的图形（见书：64页的图，这里省略）。

解决该问题的一种方法是：
```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
    where
    left = ...
    right = ...
```
其中`where`后的 **局部定义** 给出`left`和`right`的定义。这些定义称为 **局部** 的原因是 **它们
只能用于函数`fourPics`的定义中，不可用于其他地方**。

所以，原问题分解成了两个子问题，每个问题均比原问题简单。首先看`left`，这个图形是将一个图形`pic`
放置在它的反色图形之上形成的，由此得到：
```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
    where
    left = pic `above` invertColour pic
    right = ...
```
接下来有 **多种** 方法完成函数的定义。下面列出 **4** 种方法：
+ **从零开始定义** `right`，如：

```haskell
fourPics :: Picture -> Picture
fourPics =
  left `beside` right
    where
    left = pic `above` invertColour pic
    right = invertColour (flipV pic) `above` flipV pic
```
+ **通过添加另一个局部定义修改函数的定义**。这里可以定义`flipped`表示图形`pic`在垂直镜子中的翻转，
这种定义方式类似于`left`的定义方法。

```haskell
fourPics :: Picture -> Picture
fourPics pic =
  left `beside` right
    where
    left = pic `above` invertColour pic
    right = invertColour flipped `above` flipped
    flipped = flipV pic
```
