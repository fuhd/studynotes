递归
===========================================
**递归** 是一种重要的程序设计方法：**一个递归函数或对象的定义中包含了此函数或对象本身**。

### 第一个例子：关于阶乘
我们知道，一个自然数的阶乘是从1到这个数（包括此数）的乘积，如：
```haskell
fac 6 = 1*2*3*4*5*6
```
假如要画一个阶乘表，其中0的阶乘为1，则阶乘表如下：
```
n    fac    n
0    1
1    1
2    1*2 = 2
3    1*2*3 = 6
4    1*2*3*4 = 24
```
阶乘表是阶乘函数的一种表示形式，函数表示为：
```haskell
fac :: Integer -> Integer
fac n
  |n == 0       = 1
  |n > 0        = fac (n-1) * n
```
这种形式的定义称为递归的，因为我们在定义`fac`时使用了`fac`本身。它提供了：
+ 一个起始点：`fac`在0处的值；
+ 一个计算方法：`fac`从一个点的值`fac (n-1)`，到下一点的值即`fac n`的一种计算方法；

### 递归与计算
上一节描述了如何用阶乘定义生成阶乘表：
```haskell
fac :: Integer -> Integer
fac n
  |n == 0       = 1                             --(fac.1)
  |n > 0        = fac (n-1) * n                 --(fac.2)
```
从`fac`出发，然后计算`fac.1`和`fac.2`，由此可以计算阶乘为任何数n的阶乘值。以`fac 4`为例，过程如下：
```
fac 4
---> fac 3 * 4
---> (fac 2 * 3) * 4
---> ((fac 1 * 2) * 3) * 4
---> (((fac 0 * 1) * 2) * 3) * 4
```
现在计算到达了最简单的情况，或者说是 **递归基**，它可以用（fac.1）来求得。
```
---> (((1 * 1) * 2) * 3) * 4
---> ((1 * 2) * 3) * 4
---> (2 * 3) * 4
---> 6 * 4
---> 24
```
在上述计算过程中，我们利用 **递归步**（fac.2）将目标逐步转化为递归基。上述递归形式称为 **原始递归**。

### 无定义或错误值
阶乘的定义包括0和正整数，将`fac`应用于负整数会有什么结果呢？
```
*** Exception: Chapter4.hs:(106,0)-(108,33):
    Non-exhaustive patterns in function fac
```
原因是阶乘对负数没有定义，因为阶乘定义的模式没有包含负数的情况。**可以将阶乘的定义扩展到负数上**，并定义其值为0，
即：
```haskell
fac n
  |n == 0         = 1
  |n > 0          = fac (n-1) * n
  |otherwise      = 0
```
也可以在定义中加入错误信息如下：
```haskell
fac n
  |n == 0         = 1
  |n > 0          = fac (n-1) * n
  |otherwise      = error "fac only defined on natural numbers"
```
当计算`fac (-2)`时，系统会输出下列信息：
```
Program error: fac only defined on natural numbers.
```
