递归
===========================================
**递归** 是一种重要的程序设计方法：**一个递归函数或对象的定义中包含了此函数或对象本身**。

### 第一个例子：关于阶乘
我们知道，一个自然数的阶乘是从1到这个数（包括此数）的乘积，如：
```haskell
fac 6 = 1*2*3*4*5*6
```
假如要画一个阶乘表，其中0的阶乘为1，则阶乘表如下：
```
n    fac    n
0    1
1    1
2    1*2 = 2
3    1*2*3 = 6
4    1*2*3*4 = 24
```
阶乘表是阶乘函数的一种表示形式，函数表示为：
```haskell
fac :: Integer -> Integer
fac n
  |n == 0       = 1
  |n > 0        = fac (n-1) * n
```
这种形式的定义称为递归的，因为我们在定义`fac`时使用了`fac`本身。它提供了：
+ 一个起始点：`fac`在0处的值；
+ 一个计算方法：`fac`从一个点的值`fac (n-1)`，到下一点的值即`fac n`的一种计算方法；

### 递归与计算
上一节描述了如何用阶乘定义生成阶乘表：
```haskell
fac :: Integer -> Integer
fac n
  |n == 0       = 1                             --(fac.1)
  |n > 0        = fac (n-1) * n                 --(fac.2)
```
从`fac`出发，然后计算`fac.1`和`fac.2`，由此可以计算阶乘为任何数n的阶乘值。以`fac 4`为例，过程如下：
```
fac 4
---> fac 3 * 4
---> (fac 2 * 3) * 4
---> ((fac 1 * 2) * 3) * 4
---> (((fac 0 * 1) * 2) * 3) * 4
```
现在计算到达了最简单的情况，或者说是 **递归基**，它可以用（fac.1）来求得。
```
---> (((1 * 1) * 2) * 3) * 4
---> ((1 * 2) * 3) * 4
---> (2 * 3) * 4
---> 6 * 4
---> 24
```
在上述计算过程中，我们利用 **递归步**（fac.2）将目标逐步转化为递归基。上述递归形式称为 **原始递归**。
