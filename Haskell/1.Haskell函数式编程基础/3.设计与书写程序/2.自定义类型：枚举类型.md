自定义类型：枚举类型
==========================================
直接定义能够描述问题领域的类型也是很有意义的。这样的类型用Haskell的 **自定义数据类型** 定义。

下面我们用一个游戏来入手进行讲解：石头－剪刀－布。假如我们要模拟这个游戏。一种选择是使用整数，
字符或者字符串，但是基于某些原因，这些选择都不理想，所以我们将 **定义三个元素的类型**。
```haskell
data Move = Rock|Paper|Scissors
```
定义中列出类型包含的元素，并用 **竖线** 将元素分隔开。也可以将元素分列在不同行：
```haskell
data Move = Rock|
  Paper|
  Scissors
```
无论使用哪种定义方式，在定义中再加上一行以便对这种类型的元素进行比较，并且使得这些元素可以在屏幕上显示（以后介绍）：
```haskell
data Move = Rock|Paper|Scissors
  deriving (Show, Eq)
```
现在可以用类型`Move`定义函数了。首先写一个表示一个元素被哪个元素击败的函数：
```haskell
beat :: Move -> Move
beat Rock     = Paper
beat Paper    = Scissors
beat Scissors = Rock
```
在写一个输给某个元素的是哪个元素：
```haskell
lose :: Move -> Move
lose Rock     = Scissors
lose Paper    = Rock
lose _        = Paper
```
在`lose`的定义中没有使用`Scissors`，而是使用了 **通配符`_`**，这是因为 **当其他子句不匹配时这个子句才匹配**，
而且匹配这个子句的正好是`Scissors`。
