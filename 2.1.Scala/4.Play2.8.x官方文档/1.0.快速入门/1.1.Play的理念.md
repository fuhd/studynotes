Play的理念
===================================================================================
自2007年以来，我们一直致力于简化Java Web应用程序开发。Play最初是作为Zenexity（现在的Zengularity）
的一个内部项目而受到我们的Web项目方式的影响：**专注于开发人员的工作效率，尊重Web架构，并从一开始
就采用一种新的方法来打包 - 在有意义的情况下打破所谓的JEE最佳实践**。

2009年，我们决定与社区分享这些想法，作为一个开源项目。立即反馈非常积极，该项目获得了很大的吸引力。
今天 - 经过多年积极的公共开发--Play拥有多个版本，一个拥有超过10,000名员工的活跃社区，其中越来越多的应
用程序在全球范围内投入生产。

向世界开放项目肯定意味着更多的反馈，但它也意味着发现和了解新的用例，所需的功能和未发现的错误，这些
错误在原始设计及其假设中没有特别考虑。在Play作为一个开源项目的这些年里，我们一直致力于解决这类问题，
并集成新功能以支持更广泛的场景。随着项目的不断发展，我们从社区和我们自己的经验中学到了很多东西 - 在
越来越复杂多样的项目中使用Play。

与此同时，技术和web也在不断发展。web已成为所有应用程序的中心点。HTML，CSS和JavaScript技术发展迅
速 - 使服务器端框架几乎不可能跟上。整个Web架构正在快速向实时处理发展，而如今项目介绍的新兴要求意味
着SQL不再作为独有的数据存储技术。在编程语言层面，我们目睹了包括Scala在内的几种JVM语言的一些巨大变
化，越来越受欢迎。

这就是为什么我们创建了Play 2，一个新时代的新Web框架。

## 1.专为异步编程而设计
今天的Web应用程序正在集成更多的并发实时数据，因此 **Web框架需要支持完整的异步HTTP编程模型**。
Play最初设计用于处理具有许多短期请求的经典Web应用程序。但现在，**事件模型是持久连接的方式 - 通过
Comet，长轮询和WebSockets**。

**Play 2的设计从一开始就假设每个请求都可能是长期存在的**。但这还不是全部：**我们还需要一种强大的方
法来安排和运行长时间运行的任务。基于Actor的模型无疑是当今处理高度并发系统的最佳模型，Java和Scala可
用的最佳模型实现是Akka** - 所以它正在进行中。**Play 2 为Play应用程序提供原生Akka支持，使其成为可能可
以编写高度分布的系统**。

## 2.专注于类型安全
**使用静态类型编程语言编写Play应用程序的一个好处是编译器可以检查部分代码**。这不仅有助于在开发过程
的早期发现错误，而且还可以使涉及大量开发人员的大型项目变得更加容易。

**将Scala添加到Play 2的混合中，我们显然可以从更强大的编译器保证中受益** - 但这还不够。在Play 1.x中，
模板系统是动态的，基于Groovy语言，编译器无法为您做很多事情。因此，只能在运行时检测模板中的错误。使
用控制器验证胶水代码也是如此。

在2.0版本中，我们真的想要推动让Play在编译时进一步检查大部分代码的想法。**这就是为什么我们决定使用基
于Scala的模板引擎作为Play应用程序的默认设置** - 即使对于使用Java作为主要编程语言的开发人员也是如此。
**这并不意味着您必须成为Scala专家才能在Play 2中编写模板**，就像您不需要知道Groovy在Play 1.x中编写模
板一样。

在模板中，Scala主要用于导航对象图以显示相关信息，其语法非常接近Java。但是，**如果您想释放Scala的强
大功能来编写高级模板抽象，您将很快发现Scala（面向表达式和功能性）非常适合模板引擎**。

这不仅适用于模板引擎：**路由系统也经过完全类型检查**。Play 2检查您的路线描述，并验证一切是否一致，
包括反向路由部分。

**完全编译的一个很好的副作用是模板和路由文件将更容易打包和重用**。在运行时，您还可以在这些部件上获
得显着的性能提升。

## 3.对Java和Scala的本机支持
在Play项目的早期历史中，我们开始探索使用Scala编程语言编写Play应用程序的可能性。我们最初将这项工作作
为外部模块介绍，以便能够自由地进行实验而不会影响框架本身。

将Scala正确地集成到基于Java的框架中并非易事。考虑到Scala与Java的兼容性，人们可以快速实现第一个简单
使用Scala语法而不是Java的简单集成。然而，这肯定不是使用该语言的最佳方式。Scala是真正的面向对象和函
数式编程的混合体。利用Scala的全部功能需要重新考虑大多数框架的API。

我们很快就达到了Scala支持作为单独模块所能做的极限。我们在Play 1.x中做出的初步设计选择，主要依赖于
Java反射API和字节码操作，使得在没有完全重新思考Play内部的一些基本部分的情况下进展更加困难。同时，
我们为Scala模块创建了几个非常棒的组件，例如新的类型安全模板引擎和全新的SQL访问组件Anorm。这就是为
什么我们决定，**为了充分释放Scala与Play的强大功能，我们将Scala支持从单独的模块转移到Play 2的核心，
Play 2从一开始就设计为原生支持Scala作为编程语言**。

另一方面，Java肯定没有得到Play 2的支持，恰恰相反。Play 2构建为我们提供了增强Java开发人员开发体验的
机会。Java开发人员在编写时考虑到了所有Java特性的真正Java API。

## 4.强大的构建系统
**从Play项目开始，我们选择了一种新的方式来运行，编译和部署Play应用程序。它最初可能看起来像一个深奥
的设计，但提供异步HTTP API代替标准Servlet API，通过实时编译和开发期间重新加载源代码的短反馈周期以及
促进新的封装方法至关重要。因此，很难使Play遵循标准的JEE约定**。

今天，**这种无容器部署的想法在Java世界中越来越被接受**。这是一个设计选择，允许Play Framework在
Heroku这样的平台上本地运行，这引入了我们考虑在弹性PaaS平台上部署Java应用程序的未来模型。

但是，现有的Java构建系统不够灵活，无法支持这种新方法。由于我们希望提供直接的工具来运行和部署Play应
用程序，因此在Play 1.x中我们创建了一系列Python脚本来处理构建和部署任务。

与此同时，使用Play进行更多企业级项目的开发人员有点迷失，这些项目需要构建流程定制并与现有的公司构建
系统集成。我们在Play 1.x中提供的Python脚本绝不是功能齐全的构建系统，也不容易定制。这就是为什么我们
决定为Play 2建立一个更强大的构建系统。

**由于我们需要一个足够灵活的现代构建工具来支持Play原始约定并能够构建Java和Scala项目，因此我们选择
将sbt集成到Play 2中。sbt是Scala的事实构建工具，并且越来越多地被Java接受**。社区也是如此。

这也意味着可以更好地与开箱即用的Maven项目集成，能够将项目打包并作为一组简单的JAR文件发布到任何存
储库，尤其是在任何依赖项目的开发时进行实时编译和重新加载，即使对于标准Java也是如此或Scala lib项目。

## 5.数据存储和模型集成
“数据存储”不再是“SQL数据库”的同义词，而且可能永远不会。许多有趣的数据存储模型正在变得流行，为
不同的场景提供不同的属性。出于这个原因，像Play这样的Web框架很难对开发人员将使用的数据存储类型做出
大胆的假设。Play中的通用模型概念不再有意义，因为使用单个API几乎不可能对所有这些类型的技术进行抽象。

**在Play 2中，我们希望使用任何数据存储驱动程序，ORM或任何其他数据库访问库非常容易，而无需与Web框
架进行任何特殊集成。我们只想提供一组最小的帮助程序来处理常见的技术问题，比如管理连接边界。但是，我
们还希望通过捆绑默认工具来维护Play Framework的全栈方面，以便为没有特殊需求的用户访问经典数据库，
这就是Play 2带有内置关系数据库访问库的原因，例如Ebean，JPA和Anorm**。

