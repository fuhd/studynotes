抽象类型与参数化类型
===================================================================================
我们在1.3节中提到 **Scala支持参数化类型，与Java中的泛型十分类似**。在语法上，Java使用尖括号（`<>`）,
而 **Scala使用方括号（`[]`），因为在Scala中`<`和`>`常用作方法名**。

例如，字符串列表可以声明如下：
```scala
val strings: List[String] = List("one", "two", "three")
```
由于我们可以在集合`List[A]`中使用任何类型作为类型A，这种特性被称为 **参数多态**，在方法`List`的通用
实现中，允许使用任何类型的实例作为`List`的元素。

我们来讨论学习参数化类型最为重要的细节，尤其当你在试图理解Scaladoc中的类型签名时，这些细节尤为重要。
如在Scaladoc中的List条目中，你会发现 **其声明被写为`sealed abstract class List[+A]`**。

**A之前的`+`表示：如果B是A的子类，则`List[B]`也是`List[A]`的子类型，这被称为协类型**。协类型很符
合直觉，如果我们有一个函数`f(list: List[Any])`，那么传递`List[String]`给这个函数，也应该能正常工作。

**如果类型参数前有`-`，则表示另一种关系：如果B是A的子类型，且`Foo[A]`被声明为`Foo[-A]`，则`Foo[B]`
是`Foo[A]`的父类型（称为逆类型）**。这一机制没那么符合直觉，我们将在参数化类型中与参数化类型的其他
细节一起解释这一点。



