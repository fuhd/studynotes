推断类型信息
================================================================================
Java7引入了尖括号操作符来推断表达式右边的泛型类型，降低了冗余度：
```java
HashMap<Integer, String> intToStringMap = new HashMap<>();
```
我们之前已经看过一些示例说明 **Scala对类型推断确有支持。没有显式类型注解时，编译器可以根据上下文
识别不少信息**。利用自动推断类型信息，以上声明可以用Scala重写如下：
```scala
val intToStringMap: HashMap[Integer, String] = new HashMap
```
如果我们将`HashMap[Integer, String]`放在 **等号后边**，代码会更简洁：
```scala
val intToStringMap2 = new HashMap[Integer, String]
```
**一些函数式编程语言，如Haskell，可以推断出几乎所有的类型，因为它们可以执行全局类型推断。Scala
则无法做到这一点，部分原因是Scala必须支持子类多态（支持继承），这使得类型推断要困难得多**。

以下总结了在Scala中什么时候需要显式类型注解：
+ 声明了可变的`var`变量或不可变的`val`变量，**没有进行初始化**。（例如，在类中的抽象声明，如
`val book: String`, `var count: Int`)。
+ 所有的 **方法参数**（如：`def deposit(amount: Money) = {...}`）。
+ **方法的返回值类型**，在以下情况中 **必须显式声明其类型**。
  - 在方法中 **明显地使用了return**（即使在方法末尾也是如此）
  - **递归方法**
  - 两个或多个 **方法重载**（拥有相同的函数名），**其中一个方法调用了另一个重载方法，调用者需要
  显式类型注解**。
```
Any类型是Scala类型层次中的根类型。如果一块代码意外地返回了Any类型的值，很有可能是因为代码比你预期的更为宽泛，于是只有Any
类型才能覆盖所有可能的值。
```
在下面这些例子中 **需要显式类型注释**。比如 **重载的函数中，如果其中一个调用了另一个，则需要提供
显式类型注解**：
```scala
// src/main/scala/progscala2/typelessdomore/method-overloaded-return-v1.scx
// StringUtil第一版（有一个编译错误）
// 错误：无法通过编译，右边的joiner需要一个String类型的返回值

object StringUtilV1 {
    def joiner(strings: String*): String = strings.mkString("-")
    def joiner(strings: List[String]) = joiner(strings: _*)       //编译错误
}
println(StringUtilV1.joiner(List("Programming", "Scala")))
```
这段代码不能通过编译。如果你执行这段脚本，会得到下面的错误信息：
```
<console>:13: error: overloaded method joiner needs result type
       def joiner(strings:List[String]) = joiner(strings: _*)
                                                ^
```
由于第二个joiner调用了第一个joiner，**第二个joiner就需要显式地将返回值声明为String**，应该像
这样：
```scala
def joiner(strings: List[String]): String = joiner(strings: _*)
```
现在我们来看第一个joiner方法中使用的 **惯用技巧**。**Scala支持方法拥有变量参数列表（有时也叫作
“可变方法”）**，第一个joiner方法的签名为：
```scala
def joiner(strings: String*): String = strings.mkString("-")
```
**参数列表中，String后的`*`表示“0个或多个String”，方法可以拥有其他参数，但必须位于可变参数之前，
且方法只能拥有一个可变参数**。
然而，有时用户可能已经有了可以传递给joiner的字符串序列。在这种情况下，第二个joiner方法是一个便利
的方法。它只是简单地转发调用给第一个joiner，**但它使用了特殊的语法告诉编译器将输入的List转为第一
个joiner需要的可变参数列表**：
```scala
def joiner(strings: List[String]): String = joiner(strings: _*)
```
我这么理解这段古怪的代码：**`strings: _*`告诉编译器你希望列表strings作为可变参数列表，而列表
strings的类型却不是指定的，而是根据输入推断得出的。Scala不允许你写成`strings: String*`，即使
你需要为第一个joiner方法指定的输入类型就是String**。































dd
