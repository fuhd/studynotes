推断类型信息
================================================================================
Java7引入了尖括号操作符来推断表达式右边的泛型类型，降低了冗余度：
```java
HashMap<Integer, String> intToStringMap = new HashMap<>();
```
我们之前已经看过一些示例说明 **Scala对类型推断确有支持。没有显式类型注解时，编译器可以根据上下文
识别不少信息**。利用自动推断类型信息，以上声明可以用Scala重写如下：
```scala
val intToStringMap: HashMap[Integer, String] = new HashMap
```
如果我们将`HashMap[Integer, String]`放在 **等号后边**，代码会更简洁：
```scala
val intToStringMap2 = new HashMap[Integer, String]
```
**一些函数式编程语言，如Haskell，可以推断出几乎所有的类型，因为它们可以执行全局类型推断。Scala
则无法做到这一点，部分原因是Scala必须支持子类多态（支持继承），这使得类型推断要困难得多**。

以下总结了在Scala中什么时候需要显式类型注解：
+ 声明了可变的`var`变量或不可变的`val`变量，**没有进行初始化**。（例如，在类中的抽象声明，如
`val book: String`, `var count: Int`)。
+ 所有的 **方法参数**（如：`def deposit(amount: Money) = {...}`）。
+ **方法的返回值类型**，在以下情况中 **必须显式声明其类型**。
  - 在方法中 **明显地使用了return**（即使在方法末尾也是如此）
  - **递归方法**
  - 两个或多个 **方法重载**（拥有相同的函数名），**其中一个方法调用了另一个重载方法，调用者需要
  显式类型注解**。




































dd
