推断类型信息
================================================================================
Java7引入了尖括号操作符来推断表达式右边的泛型类型，降低了冗余度：
```java
HashMap<Integer, String> intToStringMap = new HashMap<>();
```
我们之前已经看过一些示例说明 **Scala对类型推断确有支持。没有显式类型注解时，编译器可以根据上下文
识别不少信息**。利用自动推断类型信息，以上声明可以用Scala重写如下：
```scala
val intToStringMap: HashMap[Integer, String] = new HashMap
```
如果我们将`HashMap[Integer, String]`放在 **等号后边**，代码会更简洁：
```scala
val intToStringMap2 = new HashMap[Integer, String]
```
**一些函数式编程语言，如Haskell，可以推断出几乎所有的类型，因为它们可以执行全局类型推断。Scala
则无法做到这一点，部分原因是Scala必须支持子类多态（支持继承），这使得类型推断要困难得多**。

以下总结了在Scala中什么时候需要显式类型注解：
+ 声明了可变的`var`变量或不可变的`val`变量，**没有进行初始化**。（例如，在类中的抽象声明，如
`val book: String`, `var count: Int`)。
+ 所有的 **方法参数**（如：`def deposit(amount: Money) = {...}`）。
+ **方法的返回值类型**，在以下情况中 **必须显式声明其类型**。
  - 在方法中 **明显地使用了return**（即使在方法末尾也是如此）
  - **递归方法**
  - 两个或多个 **方法重载**（拥有相同的函数名），**其中一个方法调用了另一个重载方法，调用者需要
  显式类型注解**。
```
Any类型是Scala类型层次中的根类型。如果一块代码意外地返回了Any类型的值，很有可能是因为代码比你预期的更为宽泛，于是只有Any
类型才能覆盖所有可能的值。
```
在下面这些例子中 **需要显式类型注释**。比如 **重载的函数中，如果其中一个调用了另一个，则需要提供
显式类型注解**：
```scala
// src/main/scala/progscala2/typelessdomore/method-overloaded-return-v1.scx
// StringUtil第一版（有一个编译错误）
// 错误：无法通过编译，右边的joiner需要一个String类型的返回值

object StringUtilV1 {
    def joiner(strings: String*): String = strings.mkString("-")
    def joiner(strings: List[String]) = joiner(strings: _*)       //编译错误
}
println(StringUtilV1.joiner(List("Programming", "Scala")))
```
这段代码不能通过编译。


































dd
