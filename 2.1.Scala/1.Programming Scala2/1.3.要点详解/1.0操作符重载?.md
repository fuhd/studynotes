操作符重载?
===================================================================================
在Scala中，几乎所有的“**操作符**”其实都是 **方法**。我们一起看最基础的一个例子：
```scala
1 + 2
```
数字之间的加号是什么呢？这个操作符是一个方法。

首先，请注意在Scala的世界里，Java中特殊的“基本类型”都变成正规的对象，这些对象类型为：`Float`、
`Double`、`Int`、`Long`、`Short`、`Byte`和`Boolean`类型。这也意味着它们可以拥有成员方法。

正如你所见，**除了某些特殊情况之外，Scala标示符中允许出现字母和数据之外的字符**。我们稍后将会讲到
这些特殊情况。

由于使用 **中缀表示法** 表示 **单参数** 方法时，其中的 **点号** 和 **括号** 可以省略；因此`1+2`等价于
`1.+(2)`。

与之相似，调用 **无参** 方法时也可以省略 **点号**。这种写法也被称为 **后缀表示法**。**不过有时候使用
后缀表示方法时会产生岐义，因此Scala2.10将这种表示法修改为可选特性**。我们将搭建SBT的实验环境，**假
如你在没有告诉编译器的情况下使用了该特性，那么将触发一条警告信息。可以通过一条`import`语句开启此特
性**。请查看下面的示例了解通过scala命令开启REPL会话，（也可以通过SBT console命令开启）。
```scala
scala> 1 toString
```
显示：
```
error: postfix operator toString needs to be enabled
       by making the implicit value scala.language.postfixOps visible.
       This can be achieved by adding the import clause 'import scala.language.postfixOps'
       or by setting the compiler option -language:postfixOps.
       See the Scaladoc for value scala.language.postfixOps for a discussion
       why the feature needs to be explicitly enabled.
```
**注：在scala2.13之中测试，显示为错误！！！！！！**

```scala
scala> import scala.language.postfixOps
import scala.language.postfixOps

scala> 1 toString
res4: String = 1
```
可以通过 **两种方式** 消除这个警告（**scala2.13显示的是错误！！**）。我们已经演示了 **第一种方法：执
行`import scala.language.postfixOps`命令**。我们也可以 **向编译器传递另一个标志`-language:postfixOps`，
通过这一方式在全局范围内开启该特性**。我个人青睐于每次都调用`import`语句，因为这种方式能提醒读者了
解到我们现在启用了哪个可选特性。

在不造成编译器岐义的前提下，省略点号能够使代码变得更加整洁，也有助于创建更优雅、更自然懂的程序。

那么，**哪些字符允许出现在标识符中呢？** 下面总结了方法名、类型名、变量名等各种标识符需要遵循的规则。
+ **可用的字符**：除了 **括号类字符、分隔符** 之外，其他所有的 **可打印的ASCII字符（确定不是uncode
字符？）** 如字母、数字、下划线(`_`)和美元符(`$`)均可出现在Scala标识符中，**括号类字符包括了`(`,`)`、
`[`,`]`、`{`,`}`；而分隔符则包括了`｀`,`'`,`"`,`.`,`;`以及`,`。Scala还允许在标识符中使用在`\u0020`
到`\u007F`之间的字符**，如数学符号、像`/`和`<`这样的操符符字符以及其他的一些符号。
+ **不能使用保留字**：和绝大多数语言一样，Scala中也不允许使用保留字作为标识符。
+ **普通标识符**：字母、数字、`$`、`_`和操作符的组合。常见的标识符往往由字母或下划线开头，后面跟着
一些字母、数字、下划线或美元符。Scala允许使用Unicode格式的字符。**由于美元符在Scala内部会作为特定
作用，因此尽管编译器不会阻止你，你仍不应将美元符当作标识符使用**。在下划线后可以输入字母、数字、也
可以输入一些操作符。**下划线就一个重要的字符，编译器会将下划线之后空格之前的所有字符视为标识的一部
分。假如在下划线后输入了操作符，那么不允许在操作符后输入字母或数字**。这一限制确保了不会产生具有歧
义的表达式，例如：`abc_=123`。
+ **普通标识符**：操作符。**假如某一标识符以操作符开头，那么后面的字符也必须是操作符字符**。
+ **使用反引号定义标识符**：我们可以通过反引号定义标识符，两个反引号内的任意长度的字符串便是定义的
标识符。
    ```scala
    val `test that addition works` = assert(1 + 1 == 2)
    ```
    便是其中一例（这句代码 **应用反引号定义测试名称的方法**，这种方式使用了一种“如果不满足某些条件，
    便存在问题”的命名技巧。而你将来也许能在产品代码中看到这类命名方式）。我们之前也曾盾到过反引号命
    名的例子。**如果需要访问的Java类方法或变量的名与Scala类的保留字相同，我们需要使用反引号命名**。如：
    ```java
    java.net.Proxy.`type`()
    ```
+ **模式匹配标识符**：在模式匹配表达式中（请回顾１.4节中`actor`的相关示例），**以小写字母开头的标记
会被解析为变量标识符，而大写字母开头的标记则会被解析为常量标识符（如类名）**。模式匹配使用了非常简
洁的变量表示法，例如无需使用`val`关键字，增加该限定能够避免产生某些岐义。

