传统扩展
===================================================================================
从单个服务器开始，开发聊天程序的第一个版本，先进行数据模型设计，一开始只是把这些对象保存在内存里。
应用程序只运行在内存中，一旦程序重启，所有数据就会丢失，而且只能运行在一台服务器上。

## 1.传统扩展和持久性：一切移入数据库
接下来，我们在应用中引入数据库，并运行两台Web服务器，在Web服务器之前放置负载均衡器。因为不能仅仅
在内存中保存对象了，所以代码将变得更加复杂。如何保证两台服务器上的数据一致性？团队中有的人建议“我
们需要转换成无状态的！”，于是删除了功能丰富的对象，并替换成数据库代码。

对象的状态不再是简单地驻留在Web服务器的内存中了，这也就意味着对象的方法不能直接改变对象的状态，因
此所有逻辑操作都要转换成数据库语句。

这种转换需要把某些对象以数据库访问抽象层代替。在这种情况下，使用DAO感觉有点“复古”。

而很多事情都发生了变化：
+ **不再有以前同样的保证**，例如添加一个Message消息。以前可以保证addMessage方法不会执行失败，因
为它只是对内存中的列表（除非JVM内存不足的特殊情况）进行操作。现在，在任何addMessage方法调用中数
据库都可能返回错误。插入操作可能失败，或者恰好此时数据库服务器宕机，或者由于网络问题导致数据库不可
用。
+ **内存版本中有一种锁，可以保证数据不会被并发用户损坏。而现在使用“数据库X”，必须找到处理这个问题
的方法，以保证不会有重复的记录或不一致的数据**。必须在数据库X的库中找到切实解决这个问题的方法。对任
一对象的简单方法调用，只有这些方法工作协调，才会使每次调用成为一次有效的数据库操作。
+ **内存版本易于测试，且单元测试运行很快**。现在在本地运行数据库X进行测试，需要添加测试工具以隔离
测试。单元测试运行速度慢了很多。