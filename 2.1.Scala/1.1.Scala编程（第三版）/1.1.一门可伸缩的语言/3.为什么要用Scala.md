为什么要用Scala
================================================================================
我们发现除了 **伸缩性**，其实还有很多因素让人喜欢Scala编程。本节将介绍其中最重要的四点：**兼容
性、精简性、高级抽象和静态类型**。


### Scala是兼容的
从Java到Scala，Scala并不需要你从Java平台全身而退。这得益于它的 **设计目标就是与Java的无缝互
调**。Scala程序会被编译成JVM字节码，它们的运行期性能通常也跟Java程序相当。Scala代码可以调用
Java方法、访问Java字段、从Java类继承、实现Java接口。**要实现这些并不需要特殊的语法、显式的接
口描述或胶水代码**。事实上，几乎所有的Scala代码都重度使用Java类库，而程序员们通常察觉不到这一点。

关于互操作性还有一点要说明，那就是Scala也重度复用了Java的类型。Scala不仅仅是复用Java的类型，
也会对Java原生的类型进行“再包装”，让它们更好用。

**我们也可以从Java中调用Scala的代码**。具体的方式有时候比较微妙，因为就编程语言而言，**Scala
比Java表达力更为丰富，所以Scala的某些高级特性需要加工后才能映射到Java**。


### Scala是精简的
**Scala编写的程序通常都比较短**。很多Scala程序员都表示，**跟Java相比，代码行数相差可达十倍之
多**。更少的代码不仅仅意味着打更少的字，也让阅读和理解代码更快，缺陷也更少。更少的代码行数，归功
于如下几个因素。

首先，**Scala的语法避免了Java程序中常见的一些样板（boilerplate）代码**。比如，在Scala中分号
是可选的，通常大家也不写分号。**Scala的语法噪声更少** 还体现在其他几个方面，比如，可以比较一下
分别用Java和Scala来编写类和构造方法。Java的类和构造方法通常类似这样的：
```java
class MyClass {
    private int index;
    private String name;
    public MyClass(int index, String name) {
        this.index = index;
        this.name = name;
    }
}
```
而在Scala中，可能更倾向于写成如下的样子：
```scala
class MyClass(index: Int, name: String)
```
**Scala的类型推断是让代码精简的另一个帮手**。重复的类型信息可以去掉，这样代码就更紧凑可读。**不
过可能最重要的因素是有些代码根本不用写，类库都帮你写好了。Scala提供了大量的工具来定义功能强大的
类库**，让你可以捕获那些公共的行为，并将它们抽象出来。


### Scala是高级的
程序员们一直都在应对不断上升的复杂度。要保持高效的产出，必须理解当前处理的代码。许多走下坡路的软
件项目都受到过于复杂的代码的影响。不幸的是，重要的软件通常需求都比较复杂。这些复杂度并不能被简单
地规避，必须对其进行妥善的管理。

**Scala给你的帮助在于提升接口设计的抽象级别，让你更好地管理复杂度**。举例来说，假定你有一个
String类型的变量name，你想知道这个String是否包含大写字符。**在Java8之前**，你可能会编写这样
的一段代码：
```java
boolean nameHasUpperCase = false;
for (int i = 0; i < name.length(); ++i) {
    if (Character.isUpperCase(name.charAt(i))) {
        nameHasUpperCase = true;
        break;
    }
}
```
**Java8** 引入了对lambda和流(stream)的支持，让你能够在Java中执行类似的操作。具体代码如下：
```java
boolean nameHasUpperCase =
    name.chars().anyMatch((int ch) -> Character.isUpperCase((char) ch));
```
而在 **Scala** 中，你可以这样写：
```scala
val nameHasUpperCase = name.exists(_.isUpper);
```
虽然跟之前版本的Java相比有了长足的进步，Java8的代码依然比Scala代码更啰唆。


### Scala是静态类型的
**Scala跟其他语言相比，一个重要的特点是它拥有非常先进的静态类型系统**。Scala不仅拥有跟Java类
似的允许 **嵌套类** 的类型系统，它还允许你 **用泛型（generics）来对类型进行参数化（parameterize），
用交集（intersection）来组合类型，以及用抽象类型（abstracttype）来隐藏类型的细节**。这些特性
为我们构建和编写新的类型打下了坚实的基础，让我们可以设计出既安全又好用的接口。

**你也许会觉得奇怪，我们怎么把静态类型系统当作Scala的强项？**。毕竟，我们常听到有人说没有静态类
型检查是动态语言的一个主要优势。**对静态类型最常见的批评是程序因此变得过于冗长繁复，让程序员不能
自由地表达他们的意图，也无法实现对软件系统的某些特定的动态修改。不过，这些反对的声音并不是笼统地
针对静态类型这个概念本身的，而是针对特定的类型系统，人们觉得这些类型系统过于啰嗦，或者过于死板**。
举例来说，Smalltalk的发明人Alan Kay曾经说过：“我并不是反对（静态）类型，但我并不知道有哪个（静
态）类型系统用起来不是一种折磨，因此我仍喜欢动态类型。”

通过本书，**我们希望让你相信Scala的类型系统并不是“折磨”。事实上，它很好地解决了静态类型的两个常
见的痛点：通过类型推断规避了过于啰嗦的问题，通过模式匹配以及其他编写和组合类型的新方式避免了死板**。
扫清了这些障碍，大家就能更好地理解和接收静态类型系统的好处。其中包括：**程序抽象的可验证性质、安
全的重构和更好的文档**。
