理解Scala的类型推断算法
================================================================================
我们之前用到的`sortWith`和`msort`的区别在于它们 **可接收的比较函数** 语法。我们来比较一下：
```scala
scala> msort((x: Char, y: Char) ⇒ x > y)(abcde)

res0: List[Char] = List(e, d, c, b, a)
```
和 
```scala
scala> abcde sortWith(_ > _)

res1: List[Char] = List(e, d, c, b, a)
```
这两个表达式是等效的，不过前者采用的 **比较函数字面量** 版本较长，用到了 **带名参数和显式类型声
明**。而后者采用了 **更精简的写法（`_ > _`）**，其中带名参数被替换成了 **下画线**。当然，我们
也可以在sortWith调用中使用前一种较长的写法来给出比较函数。

不过，这个较短的版本并不适用于`msort`：
```scala
scala> msort(_ > _)(abcde)

Error:(25, 11) missing parameter type for expanded function ((<x$1: error>, <x$2: error>) => x$1.$greater(x$2))
msort(_ > _)(abcde)
```
要搞清楚为什么会这样，我们需要知道Scala类型推断算法的一些细节。**Scala的类型推断是基于程序流
（`flow based`）的。对于方法调用`m(args)`，类型推断算法首先检查m的类型是否已知。如果m的类型
已知，那么这个类型信息就被用于推断入参的预期类型**。例如，在`abcde.sortWith(_ > _)`中，abcde
的类型为`List[Char]`。因此，类型推断算法知道`sortWith`是一个接收类型为`(Char, Char) -> Boolean`
的入参且产出一个类型为`List[Char]`的结果的方法。由于该函数入参的参数类型是已知的，并不需要显式
地写出来。基于类型推断算法所了解的关于`sortWith`的信息，它可以推导出`(_ > _)`应该被展开成
`((x: Char, y: Char) => x > y)`，其中x和y是任意没有被用过的新名称。

现在我们来看第二个case，`msort(_ > _)(abcde)`。`msort`的类型是一个 **经过柯里化的、多态的
（参数多态）方法类型**，它接收一个类型为`(T, T) => Boolean`的入参，产出一个从`List[T]`到
`List[T]`的函数，**其中T是某个当前未知的类型。`msort`需要先用一个类型参数实例化以后才能被应用
到它的入参上**。

**由于`msort`的确切示例类型暂时未知，类型推断算法不能用这个信息来推断它的首个入参的类型。对于这
种情况，类型推断算法会改变策略，它改为先检查方法入参来决定方法的正确实例类型。然而，当它去对
`(_ > _)`这个简写的函数字面量做类型检查时，由于我们没有提供任何关于用下画线表示的函数参数类型的
信息，类型检查是失败的**。

**解决这个问题的一种方式是给`msort`传一个显式的类型参数**，如：
```scala
scala> msort[Char](_ > _)(abcde)

res2: List[Char] = List(e, d, c, b, a)
```
由于`msort`的正确实例类型现在是已知的了，类型推断算法可以用它来推断入参的类型。**另一个可能的解
决方案是重写`msort`方法，让它的两个参数交换位置**：
```scala
def msortSwapped[T](xs: List[T])(less: (T, T) ⇒ Boolean): List[T] = {
    //与msort相同的实现，不过入参交换了位置
}
```
这样的类型推断也能成功：
```scala
scala> msortSwapped(abcde)(_ > _)

res3: List[Char] = List(e, d, c, b, a)
```
怎么做到的？**类型推断算法使用了首个参数`abcde`的已知类型来判定`msortSwapped`的类型参数。一
旦`msortSwapped`的确切类型已知，它就能被用于推断第二个入参`(_ > _)`的类型**。

一般来说，当类型推断算法需要推断一个多态方法的类型参数时，它会考虑第一个参数列表里的所有入参的类
型，但到此为止。由于`msortSwapped`是一个柯里化的方法，它有两个参数列表，第二个入参（即函数值）
并不会用来判定方法的类型参数。

这样的类型推断机制引导出如下的类库设计原则：**当我们设计一个接收某些非函数的入参和一个函数入参时，
将函数入参单独放在最后一个参数列表中。这样一来，方法的正确实例类型可以从哪些非函数入参推断出来，
而这个类型又能被继续用于对函数入参做类型检查。这样做的净收益是方法的使用者需要给出的类型 信息更少，
因而在编写函数字面量时可以更精简**。

接下来再看看折叠这个更复杂的操作。**为什么我们需要像330页的`flattenRight`方法的方法体内的那段
表达式那样显式地给出类型参数呢**？
```scala
(xss :\ List[T]())(_ ::: _)
```
右折叠操作的类型以两个类型变量的形式呈现出多态。比如下面这个表达式：
```scala
(xs :\ z)(op)
```
xs的类型一定是某个任意类型A的列表，比如说`xs: List[A]`。起始值z可以是某个不一样的类型B。这样
一来操作op一定是接收类型分别为A和B的两个入参，返回类型为B的结果，即`op: (A, B) => B`。**由于
z的类型跟列表xs的类型不相关，类型推断算法就没有任何关于z的上下文信息**。

现在我们来看330页的那个错误版本的flattenRight：
```scala
//这不能编译
(xss :\ List())(_ ::: _)
```
这个折叠操作中的起始值z是一个空列表`List()`，**当没有任何其他额外信息的情况下，它的类型被推断为
`List[Nothing]`**。因此，类型推断算法会推断出本次折叠操作的类型B为`List[Nothing]`。这样一来，
折叠操作中的`(_ ::: _)`预期应该满足如下类型：
```scala
(List[T], List[Nothing]) => List[Nothing]
```
这的确是本次操作的一个可能的类型，但并不是一个十分有用的版本！它表达的意思是这个操作永远接收一个
空列表作为第二个参数，同时永远产出一个空列表作为结果。

换句话说，这里的类型推断算法过早地判定了`List()`的类型，它应该等看到操作op的类型以后再做决定。
因此，这个（本可以很有用的）在柯里化的方法调用中只考虑第一个参数列表来判定方法类型的规则是核心问
题所在。另一方面，即便我们可以放宽这个规则，类型推断算法依然无法推算出op的类型，因为它的参数类型
没有给出。因此，一个《二十二条军规》的情况出现了， **我们只好通过程序员加上显式的类型注解来解决**。

这个例子显现出局部的，基于程序流的Scala类型推断机制的局限。**在函数式编程语言ML或Haskell中使用
的全局的Hindley-Milner风格的类型推断中，并没有这些限制**。不过，**Scala的局部类型推断对于面
向对象的子类型处理相比Hindley-Milner风格要优雅得多**。幸运的是，**这些局限只在某些边界case出
现**，且通常很容易通过显式添加类型注解解决。

当我们对多态方法相关的错误提示感到困惑时，添加类型注解也是一个有用的调试技巧。



