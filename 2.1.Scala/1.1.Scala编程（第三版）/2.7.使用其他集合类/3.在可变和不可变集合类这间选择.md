在可变和不可变集合类这间选择
===================================================================================
对于某些问题，可变集合更好用，而对于另一些问题，不可变集合更适用。**如果拿不定主意，那么最好从一个
不可变集合开始**，事后如果需要再做调整。因为跟可变集合比起来，不可变集合更容易推敲。

同样地，有时候我们也可以反过来看。如果发现某些使用了可变集合的代码开始变得复杂和难以理解，也可以考
虑是不是换成不可变集合能帮上忙。

除了可能更易于推敲之外，**在元素不多的情况下，不可变集合通常还可以比可变集合存储得更紧凑**。举例来
说，一个空的可变映射，按照默认的HashMap实现，会占掉80字节，每增加一个条目需要额外的16字节。一个
空的不可变Map只是单个对象，可以被所有的引用共享，所以引用它本质上只需要花费一个指针字段。

不仅如此，Scala集合类库目前的不可变映射和不可变集单个对象最多可以存4个条目，根据条目数的不同，通常
占据16到40个字节。因此对于小型的映射和集而言，不可变的版本比可变的版本要紧凑得多。**由于实际使用中
很多集合都很小，采用不可变的版本可以节约大量的空间，带来重要的性能优势**。

为了让从不可变集转到可变集（或者反过来）更容易，Scala提供了一些语法糖。**尽管不可变集和映射并不真正
支持`+=`操作，Scala提供了一个变通的解读：只要看到`a += b`而a并不支持名为`+=`的方法，Scala会尝试将
它解读为`a = a + b`**。

例如，不可变集并不支持`+=`操作符：
```scala
scala> val people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[String] = Set(Nancy, Jane)

scala> people += "Bob"
Error:(2, 8) value += is not a member of scala.collection.immutable.Set[String]
        Expression does not convert to assignment because receiver is not assignable.
        people += "Bob"
```
不过，**如果我们将people声明为var而不是val，那么这个集合就能够用`+=`操作来“更新”，尽管它是不可变
的。首先，一个新的集合被创建出来，然后people将被重新赋值指向新的集合**：
```scala
scala> var people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[String] = Set(Nancy, Jane)

scala> people += "Bob"
scala> people
res1: scala.collection.immutable.Set[String] = Set(Nancy, Jane, Bob)
```
在这一系列语句之后，变量people指向了新的集，包含添加的字符串“Bob”。**同样的理念适用于任何以 `=`
结尾的方法，并不仅仅是`+=`方法**。以下是相同的语法规则应用于 **`-=`操作符** 的例子，这个操作符将某
个元素从集里移除；以及 **`++=`操作符** 的例子，将一组元素添加到集里：
```scala
scala> people -= "Jane"
scala> people ++= List("Tom", "Harry")
scala> people
res4: scala.collection.immutable.Set[String] = Set(Nancy, Bob, Tom, Harry)
```




