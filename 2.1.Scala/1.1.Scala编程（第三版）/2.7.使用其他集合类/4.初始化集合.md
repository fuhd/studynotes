初始化集合
===================================================================================
**创建和初始化** 一个集合最常见的方式是 **将初始元素传入所选集合的伴生对象的工厂方法**。Scala编译器
会将它转换成对伴生对象apply方法的调用。
```scala
scala> List(1,2,3)
res0: List[Int] = List(1, 2, 3)

scala> Set('a','b','c')
res1: scala.collection.immutable.Set[Char] = Set(a, b, c)

scala> import scala.collection.mutable
import scala.collection.mutable

scala> mutable.Map("hi" -> 2, "there" -> 3)
res2: scala.collection.mutable.Map[String,Int] = Map(hi -> 2, there -> 3)

scala> Array(1.0,2.0,3.0)
res3: Array[Double] = Array(1.0, 2.0, 3.0)
```
虽然 **大部分时候** 我们可以让Scala编译器从传入工厂方法的元素来 **推断出集合的类型**，但有时候我们可
能希望在 **创建集合时指定跟编译器所选的不同的类型**。对于可变集合来说尤其如此。
```scala
scala> import scala.collection.mutable
import scala.collection.mutable

scala> val stuff = mutable.Set(42)
stuff: scala.collection.mutable.Set[Int] = Set(42)

scala> stuff += "abracadabra"
<console>:16: error: type mismatch;
 found   : String("abracadabra")
 required: Int
       stuff += "abracadabra"
                ^
```
这里的问题是 **stuff** 被编译器推断为类型 **Int** 的集合。如果我们想要的类型是 **Any**，我们就得 **显
式地将元素类型放在方括号里**，就像这样：
```scala
scala> val stuff = mutable.Set[Any](42)
stuff: scala.collection.mutable.Set[Any] = Set(42)
```


