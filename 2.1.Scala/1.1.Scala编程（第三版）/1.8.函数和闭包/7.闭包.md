闭包
================================================================================
本章到目前为止，所有的函数字面量示例，都只是引用了传入的参数。例如，在`(x: Int) => x > 0`中，
唯一在函数体`x > 0`中用到的变量是`x`，即这个函数的唯一参数。不过，**也可以引用其他地方定义的变
量**：
```scala
(x: Int) => x + more             
```
这个函数将“more“也作为入参，不过more是哪里来的？从这个函数的角度来看，**more是一个自由变量**，
因为函数字面量本身并没有给more赋予任何含义。相反，x是一个绑定变量，因为它在该函数的上下文里有明
确的含义：它被定义为该函数的唯一参数，一个Int。如果单独使用这个函数字面量，而并没有在任何处于作用
域内的地方定义more。编译器将报歉:
```scala
val fun = (x: Int) => x + more
```
```
Error:(1, 35) not found: value more
val fun = (x: Int) => x + more
```
只要能找到名为more的变量，同样的函数字面量就能正常工作：
```scala
var more = 1
val addMore = (x: Int) => x + more
addMore(10)
```
**运行时从这个函数字面量创建出来的函数值（对象）被称作闭包。该名称源于“捕获”其自由变量从而“闭合”
该函数字面量的动作**。没有自由变量的函数字面量，比如`(x: Int) => x + 1`，称为 **闭合语**，这
里的语指的是一段源代码。因此，运行时从这个函数字面量创建出来的函数值严格来说并不是一个闭包，因为
`(x: Int) => x + 1`按照目前这个写法已经是闭合的了。而运行时从任何带有自由变量的函数字面量，比
如`(x: Int) => x + more`，创建的函数值，按照定义，要求捕获到它的自由变量more的绑定。相应的函
数值结果（包含指向被捕获的more变量的引用）就被称作闭包，因为函数值是通过闭合这个开放语的动作产生
的。

这个例子带来一个问题，**如果more在闭包创建以后被改变会发生什么？在Scala中，答案是闭包能够看到这
个改变**。参考下面的例子：
```scala
more = 9999
addMore(10)     //10009
```
很符合直觉的是，**Scala的闭包捕获的是变量本身，而不是变量引用的值**。正如示例所展示的，为
`(x: Int) => x + more`创建的 **闭包能够看到闭包外对more的修改。反过来也是成立的：闭包对捕获
到的变量的修改也能在闭包外被看到**。参考的例子：
```scala
val someNumbers = List(-11, -10, -5, 0, 5, 10)
var sum = 0
someNumbers.foreach(sum += _)
println(sum)        //-11
```

**那么如果一个闭包访问了某个随着程序运行会产生多个副本的变量会如何呢**？例如，如果一个闭包使用了
某个函数的局部变量，而这个函数又被调用了多次，会怎么样？闭包每次访问到的是这个变量的哪一个实例呢？

只有一个答案是跟Scala其他组成部分是一致的：**闭包引用的实例是在闭包被创建时活跃的那一个**。参考
下面这个创建并返回“增加”闭包的函数：
```scala
def makeIncreaser(more: Int) = (x: Int) => x + more
```
**该函数每调用一次，就会创建一个新的闭包。每个闭包都会访问那个在它创建时活跃的变量more**：
```scala
def makeIncreaser(more: Int) = (x: Int) => x + more
val inc1 = makeIncreaser(1)
val inc9999 = makeIncreaser(9999)
inc1(10)
inc9999(10)
```
**这里more是某次方法调用的入参，而方法已经返回了，不过这并没有影响。Scala编译器会重新组织和安排，
让被捕获的参数在堆上继续存活。这样的安排都是由编译器自动帮我们完成的**，你并不需要关心。