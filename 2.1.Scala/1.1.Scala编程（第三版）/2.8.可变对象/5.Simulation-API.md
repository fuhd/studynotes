Simulation API
================================================================================
模拟API如下示例：
```scala
abstract class Simulation {
  type Action = () => Unit
  case class WorkItem(time: Int, action: Action)
  private var curtime = 0
  def currentTime: Int = curtime
  private var agenda: List[WorkItem] = List()
  private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = {
    if(ag.isEmpty || item.time < ag.head.time) item :: ag
    else ag.head :: insert(ag.tail, item)
  }
  def afterDelay(delay: Int)(block: => Unit) = {
    val item = WorkItem(currentTime + delay, () => block)
    agenda = insert(agenda, item)
  }
  private def next() = {
    (agenda: @unchecked) match {
      case item :: rest =>
        agenda = rest
        curtime = item.time
        item.action()
    }
  }
  def run() = {
    afterDelay(0) {
      println("*** simulation started, time = " + currentTime + " ***")
    }
    while (!agenda.isEmpty) next()
  }
}
```
它包含了`org.stairwaybook.simlulation`包的`Simulation`类。具体的模拟类库继承自这个类，并
补充扩展领域特定的功能。

离散事件模拟在指定的时间（`time`）执行用户定义的动作（`action`）。所有有具体模拟子类定义的动作
都是如下类型的：
```scala
type Action = () => Unit
```
**这条语句将Action定义为接收空参数列表并返回Unit的过程类型的别名**。Action是Simulation类的
**类型成员**（`type member`）。可以将它想象成`() => Unit`这个类型更可读的名字。类于类型成员
的更详细内容请参考`20.6`节。

动作被执行的时间是模拟时间，跟实际的“挂钟”（`wall clock`）时间无关。模拟时间简单地以整数表示，
当前的模拟时间保存在私有变量里：
```scala
private var curtime: Int = 0
```
这个变量有一个公有的访问方法，用于获取当前时间：
```scala
def currentTime: Int = curtime
```
这样的私有变量和公有访问方法的组合用来确保当前时间不会被Simulation类外部修改。毕竟，你并不想让
你的模拟对象来操纵当前时间。

一个需要在指定时间执行的动作被称为工作项（`work item`）。工作项由如下这个类实现：
```scala
case class WorkItem(time: Int, cation: Action)
```
我们将WorkItem处理成 **样例类**，这是由于样例类的便捷性，可以用WorkItem工厂方法创建该类的示例，
**还可以免费获得对构造方法参数time和action的getter方法**，还要注意一点，WorkItem类是内嵌在
Simulation类里的。

Simulation类有一个 **日程（`agenda`）**，记录了所有还未执行的工作项。工作项的排序依据是它们
需要执行的模拟时间：
```scala
private var agenda: List[WorkItem] = List()
```
列表agenda的排序由更新它的insert方法保证。我们可以看到insert方法的调用来自afterDelay，这也是
向日程添加工作项的唯一方式：
```scala
def afterDelay(delay: Int)(block: => Unit) = {
    val item = WorkItem(currentTime + delay, () => block)
    agenda = insert(agenda, item)
}
```
正如这个名称表达的，**这个方法向日程中插入一个动作（由block给出），计划在当前模拟时间之后的若干
（由delay给出）时间单元执行**。举例来说，如下调用会创建一个新的工作项，在模拟时间
`currentTime + delay`执行：
```scala
afterDelay(delay){count += 1}
```
要执行的代码包含在方法的第二个入参。**这个入参的形参类型为`=> Unit`（即按名传递的类型为Unit的
计算）。我们可以回忆一下，**传名参数在传入方法时并不会被求值**。因此在上面的调用中，count只会在
模拟框架调用存放在工作项当中的动作时被加1。**注意afterDelay是一个柯里化的函数**。

被创建出来的工作项还需要被插入到日程中。可以通过insert方法来完成，这个方法保证了日程是按时间排序
的：
```scala
private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = {
    if(ag.isEmpty || item.time < ag.head.time) item :: ag 
    else ag.head :: insert(ag.tail, item)
}
```
Simulation类的核心是下面这个run方法：
```scala

```


