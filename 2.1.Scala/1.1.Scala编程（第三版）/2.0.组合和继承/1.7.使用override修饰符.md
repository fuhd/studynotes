使用override修饰符
================================================================================
注意，LineElement的width和height的定义前面都带上了override修饰符。**Scala要求我们在所有重
写了父类具体成员的成员之前加上这个修饰符。而如果某个成员并不重定或继承基类中的某个成员，这个修饰
符则是被禁用的**。由于LineElement的height和width的确是重写了Element类中的具体定义，override
这个修饰符是必需的。

这样的规则为编译器提供了有用的信息，帮助我们避免某些难以捕获的错误，让系统得以更加安全地进化。这
个override的规约对于系统进行来说比较重要。比方说你打算定义一个2D绘图方法的类库。你公开了这个类
库，并且有很多人使用。在这个类库的下一个版本，**你打算给你的基类Shape添加一个新的方法**，签名如
下：
```scala
def hidden(): Boolean 
```
你的新方法将被多个绘图方法用来 **判定某个形状是否需要被绘制出来**。这有可能会带来巨大的性能提升，
不过你没法在不产生破坏使用方代码的风险的情况下添加这个方法。毕竟，类库的使用者可能定义了带有不同
hidden实现的Shape子类。**也许使用方的方法实际上会让接收调用的对象消失而不是测试该对象是否是隐
藏的**。由于两个版本的hidden存在重写的关系，你的绘图方法最终会让对象消失，这显然并不是你要的效
果！

这些“不小心出现的重写"是所谓的“脆弱基类”问题最常见的表现形式。**这个问题之所以存在，原因是如果
你在某个类继承关系中对基类添加新的成员，你将面临破坏使用方代码的风险。Scala并不能完全解决脆弱基
类的问题，但它相比Java对此情况有所改善。如果这个绘图类库和使用方代码是用Scala编写的，那么使用方
代码中原先的hidden实现并不会带上override修饰符，因为在当时并没有其他方法使用了这个名称**。

一旦你在第二版的Shape类添加了hidden方法，重新编译使用方代码将会给出类似如下报错：
```
.../Shapes.scala:6: error: error overriding method
    hidden in class Shape of type()Boolean;
    method hidden needs 'override' modifier
    def hidden(): Boolean = 
    -
```
也就是说，**使用你类库的代码并不会表现出错误的行为，而是得到一个编译期错误，这通常是更优的选择**。









