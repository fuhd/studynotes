Typesafe配置库的配置文件语法和功能
===================================================================================
Play使用的配置文件基于 [Typesafe配置库](https://github.com/lightbend/config)。

Play应用程序的配置文件必须在`conf/application.conf`中定义，它使用 **[HOCON格式](https://github.com/lightbend/config/blob/master/HOCON.md)**。

**除application.conf文件外，配置还来自其他两个地方**。
+ 默认设置是从类路径上找到的任何`reference.conf`文件中加载的。 大多数Play JAR都包含带有默认设置的
`reference.conf`文件。**application.conf中的设置将覆盖reference.conf文件中的设置**。
+ 也可以使用系统属性来设置配置。**系统属性将覆盖application.conf设置**。

使用Config的惯用方式是将所有配置键定义在`reference.conf`或`application.conf`中的某个位置。 如果key没
有合理的默认值，则通常将其设置为`null`表示“无值”。

## 1. 指定备用配置文件
在运行时，将从类路径加载默认的`application.conf`。**系统属性可用于强制使用其他配置源**：
+ `config.resource`指定一个包含扩展名的资源名称，即`application.conf`，而不仅仅是`application`。
+ `config.file`指定文件系统路径，再次应包含扩展名，而不是基本名称。

**这些系统属性指定了application.conf的替换项，而不是附加项**。如果仍要使用`application.conf`文件中
的某些值，则可以通过在该文件的顶部写入 **include "application"** 来将`application.conf`包含在其他
`.conf`文件中。将`application.conf`的设置包含在新的`.conf`文件中之后，您可以指定要 **覆盖** 的所有设
置。

## 2. 从控制器使用
由于 **依赖注入**，因此可以在控制器（或组件）中使用 **默认设置** 或 **自定义设置** 来使用配置。
```scala
import javax.inject._
import play.api.Configuration

class MyController @Inject()(config: Configuration) {
  // ...
}
```

## 3. 与Akka一起使用
Akka将使用与为您的Play应用程序定义的配置文件 **相同的配置文件**（也就是说，**他们共用配置文件**）。 
这意味着您可以在`application.conf`文件的Akka中配置任何内容。在Play中，Akka从`play.akka`设置中读取
其设置，而不是从`akka`设置中读取。

## 4. 与run命令一起使用
使用`run`命令运行应用程序时，需要了解一些有关配置的特殊信息。

### 4.1. 额外的devSettings
您可以在`build.sbt`中为`run`命令配置其他设置。**部署应用程序时将不会使用这些设置**。
```
PlayKeys.devSettings += "play.server.http.port" -> "8080"
```

### 4.2. application.conf中的HTTP服务器设置
在`run`模式下，Play的HTTP服务器部分在编译应用程序之前启动。 **这意味着HTTP服务器启动时无法访问
`application.conf`文件**。 如果要在使用`run`命令时覆盖HTTP服务器设置，则不能使用`application.conf`
文件。 相反，**您需要使用系统属性或上面显示的`devSettings`设置**。 服务器设置的一个示例是HTTP端口：
```shell
> run -Dhttp.port=1234
```
其他服务器设置可以在[这里](https://www.playframework.com/documentation/2.7.x/ProductionConfiguration#Server-configuration-options)看到。 如您在这些服务器设置中看到的，如果尚未通
过`PlayKeys.devSettings`定义端口或地址，则http(s)端口和地址将回退到配置键`PLAY_HTTP_PORT`，
`PLAY_HTTPS_PORT`和`PLAY_HTTP_ADDRESS`。**由于这些配置键是替换键**，因此您也可以通过 **环境
变量** 定义设置它（例如，在Linux中使用Bash时）：
```shell
export PLAY_HTTP_PORT=9001
export PLAY_HTTPS_PORT=9002
export PLAY_HTTP_ADDRESS=127.0.0.1
```
如果您需要针对 **开发模式（与run命令一起使用的模式）** 定制Akka配置，则还有一个 **特定的命名空间**。 
您需要在`PlayKeys.devSettings`中使用`play.akka.dev-mode`作为配置的 **前缀**，例如：
```scala
PlayKeys.devSettings += "play.akka.dev-mode.akka.cluster.log-info" -> "off"
```
如果使用的Akka ActorSystem运行开发模式与应用程序本身使用的ActorSystem之间存在某些冲突，**则此功能
特别有用**。

## 5.HOCON语法
HOCON与JSON有相似之处；

### 5.1. 保持与JSON一样，不变
+ 文件必须是有效的UTF-8；
+ 带引号的字符串与JSON字符串的格式相同；
+ 值具有可能的类型：字符串，数字，对象，数组，布尔值，空；
+ 允许的数字格式与JSON匹配；与JSON中一样，未表示某些可能的浮点值，例如NaN。

### 5.2. 注释
`//`或`#`与下一个换行符之间的任何内容均被视为注释并被忽略，除非`//`或`#`包含在带引号的字符串中。

### 5.3. 省略根括号
**JSON文档的根必须有一个数组或对象**。空文件和所有仅包非数组非对象值（例如字符串）的文件一样，都
是无效文档。

**在HOCON中，如果文件不是以方括号或大括号开头，则将其解析为好像用`{}`大括号括起来一样**。如果
HOCON文件省略了开头{但仍然有结束符则无效}; 花括号必须平衡。

### 5.4. 逗号
**数组** 中的值和 **对象** 中的字段之间 **不必有逗号**，只要它们之间至少有一个`ASCII`换行符（`\n`十
进制值10）即可。

**数组中的最后一个元素或对象中的最后一个字段可能后跟一个逗号，多余的逗号将被忽略**。
+ `[1,2,3,]`和`[1,2,3]`是相同的数组。
+ `[1\n2\n3]`和`[1,2,3]`是相同的数组。
+ `[1,2,3,,]` 无效，因为它有两个结尾的逗号。
+ `[,1,2,3]`无效，因为它有一个初始逗号。
+ `[1,,2,3]`无效，因为它连续有两个逗号。
+ 这些相同的逗号规则适用于对象中的字段。

### 5.5. 重复的键
JSON规范并未阐明应如何处理同一对象中的重复键。**在HOCON中，除非两个值都是对象，否则稍后出现的重
复键将覆盖先前出现的重复键。如果两个值都是对象，则合并对象**。

合并对象：
+ 将仅在两个对象之一中存在的字段添加到合并的对象中。
+ 对于两个对象中都存在的非对象值字段，必须使用在第二个对象中找到的字段。
+ 对于两个对象中都存在的对象值字段，应根据这些相同规则递归合并对象值。

**可以通过先将键设置为另一个值来防止对象合并**。这是因为合并总是一次完成两个值。**如果您将键设置为
对象，非对象，然后是对象，首先，非对象退回对象（非对象总是获胜），然后对象回落到非对象（不合并，对
象是新值）。 因此，这两个对象再也看不见**。

这两个等效：
```json
{
    "foo" : { "a" : 42 },
    "foo" : { "b" : 43 }
}

{
    "foo" : { "a" : 42, "b" : 43 }
}
```
这两个是等效的：
```json
{
    "foo" : { "a" : 42 },
    "foo" : null,
    "foo" : { "b" : 43 }
}

{
    "foo" : { "b" : 43 }
}
```
的 **中间设置"foo"到null防止对象合并**。

### 5.6. 路径作为键
如果键是具有多个元素的 **路径表达式**，则将其扩展为每个路径元素（最后一个除外）创建一个对象。 最后
一个路径元素及其值将成为多数嵌套对象中的一个字段。换一种说法：
```
foo.bar : 42
```
等效于：
```
foo { bar : 42 }
```
另：
```
foo.bar.baz : 42
```
等效于：
```
foo { bar { baz : 42 } }
```
等等。**这些值以通常的方式合并**。这意味着：
```
a.x : 42, a.y : 43
```
等效于：
```
a { x : 42, y : 43 }
```
因为 **路径表达式的工作方式类似于值串联，所以键中可以包含空格**：
```
a b c : 42
```
等效于：
```
"a b c" : 42
```
**因为路径表达式总是转换为字符串，所以即使通常具有其他类型的单个值也将变为字符串**。
+ true : 42  是 "true" : 42
+ 3.14 : 42 是  "3.14" : 42

**作为特殊规则，未加引号的字符串include可能不会在键中以路径表达式开头，因为它具有特殊的解释**（请参
见下文）。

## 6. 替代
替代是引用 **配置树** 其他部分的一种方式。

语法为`${pathexpression}`或`${?pathexpression}`，其中`pathexpression`是如上所述的 **路径表达式**。 
此路径表达式具有与对象键相同的语法。

在`${?pathexpression}`的`?`前不能有 **空白**； `${?`这三个字符必须完全分组在一起。

对于在配置树中找不到的替换，实现可以尝试通过查看 **系统环境变量** 或 **其他外部配置源** 来解决它们。
（在后面的部分中将详细介绍环境变量。）

**不会在带引号的字符串内解析替换**。要获得包含替换的字符串，必须在未加引号的部分中使用 **值串联**和
**替换**：
```
key : ${animal.favorite} is my favorite animal
```
或者，您 **可以引用非替代部分**：
```
key : ${animal.favorite}" is my favorite animal"
```
**通过在配置中查找路径来解决替换**。该路径从 **根配置对象** 开始，即它是“**绝对**”而不是“相对”。

替换处理是最后的解析步骤，因此可以在配置中进行替换。如果一个配置包含多个文件，它甚至可能最终会从另
一个文件中检索一个值。如果多次指定键，则替换将始终求值为其最新分配的值（合并的对象或设置的最后一个
非对象值）。

如果配置将值设置为`null`，则不应在外部源中查找它。不幸的是，没有办法在以后的配置文件中“撤消”。如
果您在根对象中有`{"HOME":null}`，则`${HOME}`将永远不会查看环境变量。换句话说，这不等同于JavaScript
的`delete`操作。

如果替换与配置中存在的任何值都不匹配并且未被外部源解析，则它是未定义的。用`${foo}`语法进行的未定义
替换无效，并且应生成错误。

如果用`${?foo}`语法的替换是未定义：
+ 如果它是对象字段的值，则该字段不应被创建。如果该字段将覆盖先前设置的相同字段的值，则保留前一个值。
+ 如果它是数组元素，则不应添加该元素。
+ 如果它是值级联的一部分，则应成为一个空字符串。
+ 如果bar是未定义的，`foo:${?bar}`将避免创建字段foo，但`foo:${?bar}${?baz}`将是一个值，所以如果级联
`bar`或`baz`没有定义，则结果是空字符串。

替换只能在 **对象字段值** 和 **数组元素（值串联）** 中使用，不允许在 **键** 中或 **嵌套在其他替换**（路
径表达式）中。

