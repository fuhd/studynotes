多态函数：基于类型的抽象
===================================================================================
目前我们定义的函数都是 **单态的**（`monomorphic`）：**函数只操作一种数据类型**，比如abs和factorial
的指定参数类型是Int。高阶函数formatResult也是固定的操作`Int => Int`类型的函数。**通常，特别是在写高
阶函数时，希望写出的这段代码能够适用于任何类型，它们被称为“多态函数”**。
```
注意：

这儿的术语多态与你以往所熟悉的面向对象编程里的多态稍微有些差异，面向对象里的多态通常意味着某种形式的子类型或继承关系。这
个例子中没有接口或子类型。这里所用的多态形式有时也称为 参数化多态。
```

## 1.一个多态函数的例子
**我们经常是先注意到若干个单态函数有相似的结构，才发现应该用一个多态函数来解决问题**。比如，下面的
单态函数`findFirst`返回数组里第一个匹配到key的索引，或在匹配不到的情况下返回`-1`。它是从一个字符串
数组里查找一个字符串的特例。示例：
```scala
def findFirst(ss: Array[String], key: String): Int = {
  @annotation.tailrec
  def loop(n: Int): Int =
  //如果n到了数组的结尾，返回-1，表示这个key在数组里不存在
    if (n >= ss.length) -1
    //ss(n)抽取数组ss里的第n个元素，如果第n个元素等于key返回n，表示这个元素出现在数组的索引
    else if (ss(n) == key) n
    //否则，传入n加1,继续查找
    else loop(n + 1)
  //从数组的第一个元素开始启动loop
  loop(0)
}
```
这段代码的细节不是我们关注的重点，重要的是 **不管是从`Array[String]`中查找一个String，还是从`Array[Int]`
中查找一个Int，或从任何`Array[A]`中查找一个A，它们看起来几乎都是相同的。我们可以写一个更泛化的适用
任何类型A的findFirst函数，它接收一个函数参数，用来对A进行判定**：
```scala

```