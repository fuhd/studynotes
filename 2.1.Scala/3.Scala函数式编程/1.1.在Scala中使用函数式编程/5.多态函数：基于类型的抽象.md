多态函数：基于类型的抽象
===================================================================================
目前我们定义的函数都是 **单态的**（`monomorphic`）：**函数只操作一种数据类型**，比如abs和factorial
的指定参数类型是Int。高阶函数formatResult也是固定的操作`Int => Int`类型的函数。**通常，特别是在写高
阶函数时，希望写出的这段代码能够适用于任何类型，它们被称为“多态函数”**。
```
注意：

这儿的术语多态与你以往所熟悉的面向对象编程里的多态稍微有些差异，面向对象里的多态通常意味着某种形式的子类型或继承关系。这
个例子中没有接口或子类型。这里所用的多态形式有时也称为 参数化多态。
```

## 1.一个多态函数的例子
**我们经常是先注意到若干个单态函数有相似的结构，才发现应该用一个多态函数来解决问题**。比如，下面的
单态函数`findFirst`返回数组里第一个匹配到key的索引，或在匹配不到的情况下返回`-1`。它是从一个字符串
数组里查找一个字符串的特例。示例：
```scala
def findFirst(ss: Array[String], key: String): Int = {
  @annotation.tailrec
  def loop(n: Int): Int =
  //如果n到了数组的结尾，返回-1，表示这个key在数组里不存在
    if (n >= ss.length) -1
    //ss(n)抽取数组ss里的第n个元素，如果第n个元素等于key返回n，表示这个元素出现在数组的索引
    else if (ss(n) == key) n
    //否则，传入n加1,继续查找
    else loop(n + 1)
  //从数组的第一个元素开始启动loop
  loop(0)
}
```
这段代码的细节不是我们关注的重点，重要的是 **不管是从`Array[String]`中查找一个String，还是从`Array[Int]`
中查找一个Int，或从任何`Array[A]`中查找一个A，它们看起来几乎都是相同的。我们可以写一个更泛化的适用
任何类型A的findFirst函数，它接收一个函数参数，用来对A进行判定**：
```scala
/**
 * 用类型A做参数替代掉String类型这样的硬编码，并且用一个对数组里每个元素进行测试的函数替代
 * 掉之前用于判断元素是否与给定key相等的硬编码
 */
def findFirst1[A](as: Array[A], p: A ⇒ Boolean): Int = {
  @annotation.tailrec
  def loop(n: Int): Int =
    if (n >= as.length) -1
    //如果函数p匹配当前元素，就找到了相匹配的元素，返回数组当前索引值
    else if (p(as(n))) n
    else loop(n + 1)
  loop(0)
}
```
**这是一个多态函数的例子，有时也称“泛型函数”。我们对数组和用于查找的函数，基于类型进行抽象化**。
要写一个多态函数，我们 **引入了一种使用逗号分隔的类型参数（`type parameter`），紧跟在函数名称后使
用中括号括起来**（这里是单个类型参数[A]）。可以给类型参数起任何名字，比如`[Foo,Bar,Baz]`或`[TheParameter,
another-good-one]`都是有效的类型参数名，不过 **习惯上通常用短的、单个大写的字母来命名类型参数**，
比如：`[A,B,C]`。

在类型参数列表中引入的 **类型变量**，可在某他类型签名中引用（类似于参数列表中的参数变量可以在函数体
中引用）。在findFirst函数中类型变量A被两个地方引用：一处是数组元素要求是类型A（声明为Array[A]），另
一处是函数P必须接收类型A（声明为`A => Boolean`）。这两处类型签名中引用相同的类型变量，意味着它们的
类型必须相同。当我们调用findFirst时编译器会强制检测，如果在`Array[Int]`中查找一个String，可能会造成类
型匹配错误。

## 2.对高阶函数传入匿名函数
在使用高阶函数时，不必非要提供一些有名函数，可以传入匿名函数或函数字面量。这一点很方便，举例来说，
我们可以在REPL中用下面的方式测试findFirst函数：
```scala
scala> findFirst(Array(7, 9, 13), (x: Int) ⇒ x == 9)
res0: Int = 1
```
这里有一些新的语法，表达式`Array(7,9,13)`是一段“**数组字面量**”，它用3个整数构造一个数组。**注意构
造数组时并没有使用new关键字**。

语法`(x: Int) => x == 9`是一段“**函数字面量**”或“**匿名函数**”。不必先定义一个有名称的方法，可以利
用语法的便利，在调用时再定义。这个特定的函数接收一个Int类型参数x，并返回一个Boolean类型的值，表示
x是否等于9。

通常函数的参数声明在`=>`箭头的左边，可以在箭头右边的函数体内使用它们。比如写一个比较两个整数是否相
等的函数：
```scala
scala> (x: Int, y: Int) => x == y
```
**如果Scala可以从上下文推断输入参数的类型，函数参数可以省略掉类型符号**。例如，`(x, y) => x <  y`。

```
在Scala中函数也是值

当我们定义一个函数字面量的时候，实际上定义了一个包含一个apply方法的Scala对象。Scala对这个方法名有特别的规则，一个有apply
方法的对象可以把它当成方法一样调用。我们定义一个函数字面量(a, b) => a < b，它其实是一段创建函数对象的语法糖：

val lessThan = new Function2[Int, Int, Boolean] {
  def apply(a: Int, b: Int) = a < b
}

通常写成(Int, Int) => Boolean。注意Function2接口（在Scala中是trait）包含一个apply方法，当我们以lessThan(10, 20)的方
式调用函数lessThan时它实际是地apply方法调用的语法糖：


``` 


