通过类型来实现多态
===================================================================================
实现`isSorted`方法，检测`Array[A]`是否按照给定的比较函数排序：
```scala
def isSorted[A](as: Array[A], ordered: (A, A) ⇒ Boolean): Boolean 
```
或许在写`isSorted`函数时你已经注意到 **实现一个多态函数时，各种可能的实现方式明显减少了**。针对某种
类型A的多态函数，唯一可能对A进行操作的方式是传入一个函数参数。**在某些例子里你会发现对一个多态类型
的实现可能被限制为只有一种实现方式**。

**我们看一个例子，这个函数签名表示它只有一种实现方式。它是执行“部分应用”的高阶函数**。函数`partiall`
接收一个值和一个带有两个参数的函数，并返回一个带有一个参数的函数。**部分应用**（`partial application`）
这个名词，**表示函数被应用的参数不是它所需要的完整的参数**：
```scala
def partiall[A, B, C](a: A, f: (A, B) ⇒ C): B ⇒ C 
```
函数partiall有三个类型参数：A, B和C。它带有两个参数，参数f本身是一个有两个类型分别为A和B的参数、返回
值为C的函数。函数partiall的返回值也是一个函数，类型为`B=>C`。

**我们如何继续实现这个高阶函数？结果是能编译通过且符合类型签名逻辑的只有一种实现方式**。

看一下返回的类型，partiall返回值类型是`B=>C`，可以写一个接收B参数类型的函数字面量：
```scala
def partiall[A, B, C](a: A, f: (A, B) ⇒ C): B ⇒ C =
  (b: B) ⇒ ???
```
如果你是第一次写匿函数可能觉得很怪异，B是从哪儿来的？其实我们只是写了一个“**返回一个函数，这个函数
接收一个类型为B的参数值b**”。在右箭头符号（`=>`）的右手边（使用问号比较的地方）跟着一个匿名函数的
方法体，匿名函数方法体中可以引用值b，同样可以引用partiall方法体中的值a。
```
在这个内部函数体里，外部的a依然在可见范围内。有时候我们说内部函数隐藏了它包含a的上下文的环境。
```
让我们继续，现在来请求类型B的值，我们希望让匿名函数返回什么类型？匿名函数的类型签名表明它是类型C，
只有一种方式可以实现。按照签名，函数f的返回值正好是C，所以唯一能得到C的方式是传递A和B的值给f。也就
是：
```scala
def partiall[A, B, C](a: A, f: (A, B) ⇒ C): B ⇒ C =
  (b: B) ⇒ f(a, b)
```
完成！结果是一个高阶函数接收一个带有两个参数的函数，进行部分应用。即我们有一个A和一个需要A和B产生
C的函数，可以得到一个只需要B就可以产生C的函数（因为我们已经有A了）。

### 练习1
我们看一个柯里化（currying）的例子，把带有两个参数的函数f转换为只有一个参数的部分应用函数f。
```scala
def curry[A, B, C](f: (A, B) ⇒ C): A ⇒ (B ⇒ C)
```

### 练习2
实现反柯里化（`uncurry`），与柯里化正相反。**注意，因为右箭头`=>`是右结合的，`A => ( B => C)`可以写
为`A => B => C`**：
```scala
def uncurry[A, B, C](f: A ⇒ B ⇒ C): (A, B) ⇒ C
```

### 练习3
实现一个高阶函数，可以 **组合两个函数为一个函数**：
```scala
def compose[A, B, C](f: B ⇒ C, g: A ⇒ B): A ⇒ C 
```
这是一个常见的行为，所以Scala标准库中的Function1（带有一个参数的函数接口）提供了compose方法。要对
函数f和g进行组合，只需要简单地写成`f compose g`。同时还提供了一个andThen方法，`f andThen g`等价于
`g compose f`：
```scala
val f = (x: Double) => math.Pi / 2 - x

val cos = f andThen math.sin
```
**多态高阶函数的适用范围极其广泛，因为它们不是面向特定领域，而是对发生在很多上下文里的通用模式的抽象**。
