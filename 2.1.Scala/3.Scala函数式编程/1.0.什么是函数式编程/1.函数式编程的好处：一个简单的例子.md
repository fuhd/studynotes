函数式编程的好处：一个简单的例子
================================================================================
让我们通过一个例子示范纯函数编程的一些好处。

## 1.一段带有副作用的程序
假设我们要为一家咖啡店的购物编写一段程序，先用一段带有副作用的Scala程序来实现。
```scala
class Cafe {
    def buyCoffee(cc: CreditCard): Coffee = {
        val cup = new Coffee()
        cc.charge(cup.price)
        cup
    }
}
```
**`cc.charge(cup.price`这行是一个副作用的例子**。信用卡的计费涉及与外部世界的一些交互————假
设需要通过`web service`联系信用卡公司、授权交易、对卡片计费，并且持久化一些记录以便以后引用。
我们的函数只不过返回一杯咖啡，这些其他行为也额外发生了，因此也被称为“**副作用**”。

**副作用导致这段代码很难测试**。我们不希望测试逻辑真的去联系信用卡公司并对卡片计费。缺乏可测试性
预示着设计的修改：按理说CreditCard不应该知道如何联系信用卡公司实际执行一次计费，同样也不应该知
道怎么把一次计费持久化到内部系统。我们可以让CreditCard忽略掉这些事情，通过传递一个Payments对象
给buyCoffee函数，使代码更加 **模块化** 和 **可测化**。
```scala
class Cafe {
    def buyCoffee(cc: CreditCard, p: Payments): Coffee = {
        val cup = new Coffee()
        p.charge(cc, cup.price)
        cup
    }
}
```
虽然当我们调用`p.charge(cc, cup.price)`的时候仍然有副作用发生，但至少 **恢复了一些可测试性**。
`Payments`可以是一个接口，我们可以写一个适合于测试的mock实现这个接口。**但这也不够理想**，即
便用一个具体类可能更好，我们也不得不让`Payments`成为一个接口，否则，任何mock都很难被使用。

撇开对测试的担心，这里还有另一个问题：`buyCoffee`方法 **很难被复用**。假设一个叫Alice的顾客，
要订购12杯咖啡。最理想的情况是只要复用这个方法，通过循环来调用12次`buyCoffee`。但是基于当前的
程序，会陷入12次对支付系统的调用，对Alice的信用卡执行12次计费！那样所产生的更多的手续费对Alice
和咖啡店来说都不好。

## 2.函数式的解法：去除副作用

