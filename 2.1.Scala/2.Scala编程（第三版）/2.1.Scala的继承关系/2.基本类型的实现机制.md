基本类型的实现机制
===================================================================================
Scala存放整数的方式跟Java一样，都是32位的词（word）。这对于JVM上的效率以及跟Java类库的互操作很重
要。标准操作比如加法和乘法被实现为基本操作。不过，**Scala在任何需要将整数当作（Java）对象时，都会
启用“备选”的java.lang.Integer类。例如，当我们对整数调用toString或当我们将整数赋值给一个类型为Any的
变量时，都会发生这种情况。类型为Int的整数在必要时都会透明地被转换成类型为java.lang.Integer的“装箱
整数”**。

所有这些听上去很像Java5的自动装箱机制，也的确非常相似。不过有一个重要区别：**Scala中的装箱跟Java相
比要透明很多**。下面的Java代码：
```java
//这是Java
boolean isEqual(int x, int y) {
    return x == y;
}
```
你当然会得到 **true**。现在，将isEqual的参数类型改为java.lang.Integer（或者Object也可以）：
```java
//这是Java
boolean isEqual(Integer x , Integer y) {
    return x == y;
}
System.out.println(isEqual(421, 421));
```
你会发现你得到了 **false**！发生了什么？这里的 **数字421被装箱了两次，因此x与y这两个参数实际上是两个
不同的对象**。由于`==`对于引用类型而言意味着引用相等性。而Integer是个引用类型，结果就是false。这一点
也显示出Java并不是一个纯的面向对象语言，基本类型和引用类型之间有一个清晰可被观察到的区别。

现在，**我们用Scala来做相同的实验**：
```scala

```


