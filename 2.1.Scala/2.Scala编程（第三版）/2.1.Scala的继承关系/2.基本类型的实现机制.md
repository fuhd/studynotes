基本类型的实现机制
===================================================================================
Scala存放整数的方式跟Java一样，都是32位的词（word）。这对于JVM上的效率以及跟Java类库的互操作很重
要。标准操作比如加法和乘法被实现为基本操作。不过，**Scala在任何需要将整数当作（Java）对象时，都会
启用“备选”的java.lang.Integer类。例如，当我们对整数调用toString或当我们将整数赋值给一个类型为Any的
变量时，都会发生这种情况。类型为Int的整数在必要时都会透明地被转换成类型为java.lang.Integer的“装箱
整数”**。

所有这些听上去很像Java5的自动装箱机制，也的确非常相似。不过有一个重要区别：**Scala中的装箱跟Java相
比要透明很多**。下面的Java代码：
```java
//这是Java
boolean isEqual(int x, int y) {
    return x == y;
}
```
你当然会得到 **true**。现在，将isEqual的参数类型改为java.lang.Integer（或者Object也可以）：
```java
//这是Java
boolean isEqual(Integer x , Integer y) {
    return x == y;
}
System.out.println(isEqual(421, 421));
```
你会发现你得到了 **false**！发生了什么？这里的 **数字421被装箱了两次，因此x与y这两个参数实际上是两个
不同的对象**。由于`==`对于引用类型而言意味着引用相等性。而Integer是个引用类型，结果就是false。这一点
也显示出Java并不是一个纯的面向对象语言，基本类型和引用类型之间有一个清晰可被观察到的区别。

现在，**我们用Scala来做相同的实验**：
```scala
def isEqual(x: Int, y: Int) = x == y
isEqual(421, 421)

def isEqual(x: Any, y: Any) = x == y
isEqual(421, 421)
```
**Scala的相等性操作`==`被设计为对于类型的实际呈现是透明的，对于值类型而言，它表示的是自然（数值和布
尔值）相等性。而对于Java装箱数值类型之外的引用类型，==被处理成从Object继承的equals方法的别名。这个
方法原本定义用于引用相等性，但很多子类都重写了这个方法来实现它们对于相等性更自然的理解和表示。这也
意味着在Scala中不会陷入Java那个跟字符串对比相关的陷阱**。                                       



