定义自己的值类型
===================================================================================
**可以定义自己的值类来对内建的值类进行扩充。跟内建的值类一样，你的值类的实例通常也会编译成那种不使
用包装类的Java字节码**。在需要包装类的上下文里，比如泛型代码，**值将被自动装箱和拆箱**。

**只有特定的几个类可以成为值类。要使得某个类成为值类，它必须有且仅有一个参数，并且在内部除了def之外
不能有任何其他东西。不仅如此，也不能有其他类扩展自值类，且值类不能重新定义equals或hashCode**。

**要定义值类，你需要将它处理成AnyVal的子类，并在它唯一的参数前加上val**。以下是值类的一个例子：
```scala
class Dollars(val amount: Int) extends AnyVal {
  override def toString = "$" + amount
}
```
**参数前的val让amount参数可以作为字段被外界访问**。例如，如下代码将创建这个值类的一个实例。然后从
中获取其金额（amount）:
```scala
scala> val money = new Dollars(1000000)
money: Dollars = $1000000

scala> money.amount
res0: Int = 1000000
```
在本例中，money指向该值类的一个实例。**它在Scala源码中的类型为Dollar，但在编译后的Java字节码中将直
接使用Int**。

这个例子定义了toString方法，编译器将识别出什么时候使用这个方法。这就是为什么打印money将给出$1000000，
带上美元符号，而打印money.amount仅会给出1000000。你甚至可以定义多个同样以Int值支撑的值类型。
```scala
class SwissFrancs(val amount: Int) extends AnyVal {
    override def toString() = amount + " CHF"
}
```
尽管Dollars和SwissFrancs最终都是以整数呈现的，**在相同作用域内同时使用它们并没有什么问题**：
```scala
scala> val dollars = new Dollars(1000)
dollars: Dollars = $1000

scala> val francs = new SwissFrancs(1000)
francs: SwissFrancs = 1000 CHF
```

## 避免类型单一化







