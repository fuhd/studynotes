Scala的类继承关系
===================================================================================
在Scala中，每个类都继承自同一个名为 **Any** 的超类。由于每个类都是Any的子类，在Any中定义的方法是
“**全类型的**”（universal）：它们可以在任何对象上被调用。Scala还在 **继承关系的底部** 定义了一些有
趣的类，**Null和Nothing，它们本质上是作为通用的子类存在的。例如，就像Any是每一个其他类的超类那样，
Nothing是每一个其他类的子类**。

![Scala的类继承关系](img/1.jpeg)

上图展示了Scala类继承关系的轮廓。在继承关系的项部是Any类，定义了如下方法：
```scala
final def ==(that: Any): Boolean 
final def !=(that: Any): Boolean 
final equals(that: Any): Boolean 
final ##: Int 
def hashCode: Int 
def toString: String 
```
由于每个类都继承自Any，Scala程序中的每个对象都可以  **用`==`、`!=`或`equals`来进行比较，用`##`或
`hashCode`做哈希，以及用`toString`做格式化**。相等和不等方法（`==`和`!=`）在Any类中声明为final，
所以它们不能被子类重写。

**`==`方法从本质上讲等同于`equals`，而`!=`一定是`equals`的反义。这样一来，子类可以通过重写`equals`
方法来定制`==`或`!=`的含义**。

根类Any有两个子类：**AnyVal** 和 **AnyRef**。**AnyVal是Scala中所有值类（value class）的父类**。虽
然你可以定义自己的值类，**Scala提供了九个内建的值类：Byte、Short、Char、Int、Long、Float、Double、
Boolean和Unit**。前八个对应Java的基本类型，它们的值在运行时是用Java的基本类型的值来表示的。**这些
类的实例在Scala中统统写作字面量。不能用new来创建这些类的实例**。这一点是通过将值类定义为抽象的同时
是final的这个“小技巧”来完成的。




