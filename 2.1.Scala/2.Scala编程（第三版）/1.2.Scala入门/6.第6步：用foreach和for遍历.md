第6步：用foreach和for遍历
================================================================================
你可能还没有意识到，当你在前一步 **写下while循环时，实际上是在以指令式（imperative）的风格编程**。
指令式编程风格也是类似Java、C++、C这样的语言通常的风格，依次给出执行指令，通过循环来遍历，而且还经
常变更被不同函数共享的状态。**Scala允许你以指令式的风格编程**，不过随着你对Scala的了解日益加深，你
应该会发现自己 **倾向于使用更加函数式（functional）的风格**。

**函数式编程语言的主要特征之一就是函数是一等的语法单元，Scala非常符合这个描述**。举例来说，打印每一
个命令行参数的另一种（精简得多的）方式是：
```scala
args.foreach(arg => println(arg))
```
在这段代码中，对args执行foreach方法，传入一个函数。在本例中，你传入的是一个 **函数字面量（funcition
literal）**，这个（匿名）函数接收一个名为arg的参数。函数体为println(arg)。如果把上述内容录入到一
个新的名为pa.scala的文件并执行：
```shell
$ scala pa.scala Concise is nice
```
会看到：
```
Concise
is
nice
```
在前面的示例中，Scala解释器推断出arg的类型是String，因为String是调用foreach那个数组的元素类型。
**如果倾向于更明确地表达，也可以指出类型名**。不过当你这样做的时候，**需要将参数的部分包在圆括号里（这
是函数字面量的常规语法）**：
```scala
args.foreach((arg: String) => println(arg))
```
假如你更喜欢精简的表达而不是事无巨细，可以利用Scala对函数字面量的一个特殊简写规则。**如果函数字面量只
是一个接收单个参数的语句，可以不必给出参数名和参数本身（这个简写规则用到的特性叫作部分应用函数
[partially applied function]）**。示例：
```scala
args.foreach(println)
```
我们来总结一下，**函数字面量的语法是：用圆括号括起来的一组带名字的参数，一个右箭头和函数体**。示例：
```scala
(x: Int, y: Int) => x + y
```

为了鼓励和引导大家使用更函数式的编程风格，Scala只支持指令式for语句的函数式亲戚，这个亲戚叫作 **for表
达式**。快速体验一把，在一个新的名为forargs.scala文件中录入以下内容：
```scala
for(arg <- args)
  println(arg)
```
在“for”之后的括号里包含了一句：arg <- args。**位于<-符号右边的，是我们熟知的args数组。而在<-符号的左
边是"args"，这是一个val变量的名字**，注意它不是var（因为它总是val，只能写成"arg"而不是"val arg"）。
**尽管arg看上去像是var，因为每一次迭代都会拿到新的值，但它确实是个val————arg不能在for表达式的循环体内
被重新赋值。实际情况是，对于args数组中的每一个元素，一个新的名为arg的val会被创建出来，初始化成元素的值，
这时for表达式的循环体才被执行**。
