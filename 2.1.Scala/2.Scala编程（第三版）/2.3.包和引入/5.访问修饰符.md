访问修饰符
===================================================================================
**包、类或对象的成员可以标上private和protected这样的访问修饰符。这些修饰符将对成员的访问限定在特定
的代码区域**。Scala对访问修饰符的处理大体上跟Java保持一致，不过也有些重要的区别。

## 1. 私有成员
Scala对私有成员的处理跟Java类似，**标为private的成员只在包含该定义的类或对象内部可见。在Scala中，这
个规则同样适用于内部类**。Scala在一致性方面做得比Java更好，但做法不一样。示例：
```scala
class Outer {
  class Inner {
    private def f() = println("f")
    class InnerMost{
      //OK
      f()
    }
  }
  //错误，无法访问f
  (new Inner).f()
}
```
在Scala中，像`(new Inner).f()`这样的访问方式是非法的，因为f在Inner中声明为private并且对f的调用并不是
发生在Inner类内部。而第一次在InnerMost类中访问f是OK，因为这个调用包含在Inner类内部。**Java则对两种
访问都允许，因为在Java中可以从外部类访问其内部类的私有成员**。

## 2. 受保护成员
**跟Java相比，Scala对protected成员的访问也更严格。在Scala中，protected的成员只能从定义该成员的子类
访问**。而Java允许同一个包内的其他访问这个类的受保护成员。**Scala提供了另一种方式来达到这个效果（参
见：保护范围一节），因此protected不需要为此放宽限制**。示例：
```scala
package p {
  class Super {
    protected def f() = println("f")
  }
  class Sub extends Super {
    f()
  }
  class Other {
    //错误，无法访问f
    (new Super).f()
  }
}
```
示例中，Sub类对f的访问是OK的，因为在Super中f声明为protected，而Sub是Super的子类。。相反，Other
类对fg的访问是被禁止的，因为Other并不继承自Super。**在Java中，后者依然被允许，因为Other跟Sub在同
一个包中**。

## 3. 公共成员
**Scala并没有专门的修饰符用来标记公共成员：任何没有被标为private或protected的成员都是公共的。公共成
员可以从任何位置访问到**。

## 4. 保护的范围
**我们可以用限定词对Scala中的访问修饰符机制进行增强。形如`private[x]`或`protected[x]`的修饰符的含义
是对此成员的访问限制“上至”X都是私有或受保护的，其中X表示某个包含该定义的包、类或单例对象**。

带有限定词的访问修饰符让我们可以对成员的可见性做非常细粒度的控制，尤其是它允许我们表达Java中访问限
制的语义，比如包内私有、包内受保护或到最外层嵌套类范围内私有等。这些用Scala中简单的修饰符是无法直
接表达出来的。**这种机制还允许我们表达那些无法在Java中表达的访问规则**。示例：
```scala
package bobsrockets

package navigation {
  private[bobsrockets] class Navigator {
    protected[navigation] def useStarChart() = {}
    class LegOfJourney {
      private[Navigator] val distance = 100
    }
    private[this] var speed = 200
  }
}

package launch {
  import navigation._
  object Vehicle {
    private[launch] val guide = new Navigator
  }
}
```

