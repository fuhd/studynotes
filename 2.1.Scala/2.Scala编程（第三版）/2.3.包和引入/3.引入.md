引入
===================================================================================
在Scala中，我们可以 **用import子句引入包和它们的成员**。被引入的项目可以用File这样的 **简单名称** 访
问，**而不需要限定名称**，比如：`java.io.File`。示例代码如下：
```scala
package bobsdelights

abstract class Fruit(val name: String, val color: String)

object Fruits {
  object Apple extends Fruit("apple", "red")
  object Orange extends Fruit("orange", "orange")
  object Pear extends Fruit("pear", "yellowish")
  val menu = List(Apple, Orange, Pear)
}
```
**import子句使得某个包或对象的成员可以只用它们的名字访问，而不需要在前面加上包名或对象名**。下面是
一个简单的例子：
```scala
//到Fruit的便捷访问
import bobsdelights.Fruit

//到bobsdelights所有成员的便捷访问
import bobsdelights._

//到Fruits所有成员的便捷访问
import bobsdelights.Fruits._
```
第一个对应Java的 **单类型引入**，而第二个对应Java的按需引入。唯一的区别是 **Scala的按需引入跟在后面
的是下画线（`_`）** 而不是星号（`*`）（毕竟`*`是个合法的标识符！）。上述第三个引入子句 **对应Java
类静态字段的引入**。

这三个引入能让你对引入能做什么有个感性认识。**不过Scala的引入实际上更加通用**。首先，**Scala的引入
可以出现在任何地方，不仅仅是在某个编译单元的最开始，它们还可以引用任意的值**。如下示例：
```scala
def showFruit(fruit: Fruit) = {
  import fruit._
  println(name + "s are " + color)
}
```
**showFruit方法引入了其参数fruit（类型为Fruit）的所有成员**。这样接下来的println语句就可以直接引用
name和color。这两个引用等同于`fruit.name`和`fruit.color`。**这种语法在你需要用对象来表示模块时尤其
有用**。
```
Scala的灵活引入

跟Java相比，Scala的import子句要灵活得多。主要的区别有三点，在Scala中，引入可以：
- 出现在任意位置
- 引用对象（不论是单例还是常规对象），而不只是包
- 让你重命名并隐藏某些被引入的成员
```