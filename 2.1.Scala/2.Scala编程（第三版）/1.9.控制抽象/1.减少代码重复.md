减少代码重复
================================================================================
所有的函数都能被分解成每次函数调用都一样的 **公共的部分** 和每次调用不一样的 **非公共部分**。
**公共部分是函数体，而非公共部分必须通过实参传入**。当你把函数值当作入参的时候，这段算法的非公共
部分本身又是另一个算法。每当这样的函数被调用，你都可以传入不同的函数值作为实参，被调用的函数会调
用传入的函数值。**这些高阶函数，即那些接收函数作为参数的函数**，让你有额外的机会来进一步压缩和简
化代码。

**高阶函数的好处之一是可以用来创建减少代码重复的控制抽象**。例如，假定你在编写一个文件浏览器，而
你打算提供API给用户来查找匹配某个条件的文件。首先，你添加了一个机制用来查找文件名是 以指定字符串
结尾的文件。比如，这将允许用户查找所有扩展名为“.scala”的文件。可以通过在单例对象中定义一个公共的
`filesEnding`方法的方式来提供这样的API，就像这样：
```scala
object FileMatcher {
    private def fileHere = (new java.io.File(".")).listFiles
    def fileEnding(query: String) = 
        for (file <- fileHere; if file.getName.endsWith(query))
            yield file
}
```
这个`fileEnding`方法用私有的助手方法`filesHere`来获取当前目录下的所有文件，然后基于文件名是否
以用户给定的查询条件结尾来过滤这些文件。

目前为止一切都很完美，暂时都还没有重复的代码。不过到了后来，你决定要让人们可以基于文件名的任意部分
进行搜索。于是回去给你的`FileMatcher API`添加了这个函数：
```scala
def filesContaining(query: String) = 
    for (file <- filesHere; if file.getName.contains(query))
        yield file
```