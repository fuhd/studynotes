编写新的控制结构
===================================================================================
在拥有 **一等函数** 的语言中，可以有效地 **制作出新的控制接口**，尽管语言的语法是固定的。你需要做的
就是 **创建接收函数作为入参的方法**。

例如下面这个"twice"控制结构，它重复某个操作两次，并返回结果：
```scala
scala> def twice(op: Double => Double, x: Double) = op(op(x))
twice: (op: Double => Double, x: Double)Double

scala> twice(_ + 1, 5)
res0: Double = 7.0
```
本例中的`op`类型为`Double => Double`，意思是这是一个接收一个Double作为入参，返回另一个Double的
函数。

**每当你发现某个控制模式在代码中多处出现，就应该考虑将这个模式实现为新的控制结构**。在本章前面的部
分看到了`filesMatching`这个非常特殊的控制模式，现在来看一个更加常用的编码模式：**打开某个资源，对它
进行操作，然后关闭这个资源**。可以用类似如下的方法，将这个模式捕获成一个控制抽象：
```scala
def withPrintWriter(file: File, op: PrintWriter ⇒ Unit) = {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}
```
有了这个方法后，你就可以像这样来使用它：
```scala
withPrintWriter(
  new File("data.txt"),
  writer ⇒ writer.println(new java.util.Date())
)
```
**使用这个方法的好处是，确保文件在最后被关闭的是withPrintWriter而不是用户代码**。因此不可能出现使
用者忘记关闭文件的情况。这个技巧被称为“**贷出模式**”（`loan pattern`），因为是某个控制抽象函数，
比如withPrintWriter，打开某个资源并将这个资源“贷出”给函数。例如，前一例中的withPrintWriter将一个
PrintWriter“贷出”给函数op。当函数完成时，它会表明自己不再需要这个“贷入”的资源。这时这个资源就在
finally代码中被关闭了，这样能确保不论函数是正常返回还是抛出异常，资源都会被正常关闭。




