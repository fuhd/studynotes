Ordered特质
===================================================================================
**比较（对象大小）是另一个富接口会带来便捷的领域**。当你需要比较两个对象来对它们排序时，如果有这么
一个方法可以调用来明确你要的比较，就会很方便。如果你要的是“小于”，可以说`<`，而如果你要的是“小
于等于”，可以说`<=`。如果用一个瘦的比较接口，可能只能用`<`方法，而有时可能需要编写类似`(x<y) || (x==y)`
这样的代码。**而一个富接口可以提供所有常用的比较操作**，这样你就可以直接写下如同 `x <= y``这样的代码。

在看 **Ordered** 的具体实现之前，**设想一下没有它你需要怎么完成比较**。假定你用第6章的Rational类，
然后给它添加比较操作。你可能会做出类似这样的代码：
```scala
class Rational(n: Int, d: Int) {
  //......
  def <(that: Rational) = this.number * that.denom < that.numer * this.denom
  def >(that: Rational) = that < this
  def <=(that: Rational) = (this < that) || (this == that)
  def >=(that: Rational) = (this > that) || (this == that)
}
```
这个类定义了四个比较操作符（`<`、`>`、`<=`和`>=`），**这是个经典的展示出定义富接口代价的例子。首
先，注意其中的三个比较操作符都是基于第一个来定义的**。

这个问题如此普遍，**Scala提供了专门的特质来解决，这个特质叫作Ordered。使用的方式是将所有单独的比较
方法替换成compare方法。Ordered特质为你定义了`<`、`>`、`<=`和`>=`，这些方法都是基于你提供的compare
来实现的**。因此，Ordered特质允许你只实现一个compare方法来增强某个类，让它拥有完整的比较操作。

以下是用Ordered特质来对Rational定义比较操作的代码：
```scala
class Rational(n: Int, d: Int) extends Ordered[Rational] {
  //......
  override def compare(that: Rational) = (this.numer * that.denom) - (that.numer * this.denom)
}
```
你只需要做两件事。首先，**这个版本的Rational混入了Ordered特质**。与你看到过的其他特质不同，
**Ordered要求你在混入时传入一个类型参数**（type paramter）。我们在第19章之前不会详细控讨类型参数，
不过现在你只需要知道 **当你混入Ordered特质的时候，必须混入`Ordered[C]`，其中C是你要比较的元素的类**。

你需要做的第二件事是 **定义一个用来比较两个对象的compare方法**，该方法应该比较接收者，即`this`，
和作为参数传入该方法的对象。**如果两个对象相同，它应该返回0；如果接收者比入参小，应该返回负值；如果
接收者比入参大，则返回正值**。








