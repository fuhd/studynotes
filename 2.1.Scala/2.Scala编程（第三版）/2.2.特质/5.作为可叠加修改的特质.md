作为可叠加修改的特质
===================================================================================
现在你已经看过了 **特质的一个主要用途：将瘦接口转化成富接口**。现在我们将转向 **另一个主要用途：为类
提供可叠加的修改**。特质让你修改类的方法，而它们的实现方式 **允许你将这些修改叠加起来**。

考虑这样一个例子，对某个整数队列叠加修改。这个队列有两个操作：put，将整数放入队列；get，将它们取出
来。队列是先进先出的，所以get应该按照整数被放入队列的顺序返回这些整数。

给定一个实现了这样一个队列的类，可以定义特质来执行如下这些修改：
+ Doubling：将所有放入队列的整数翻倍；
+ Incrementing：将所有放入队列的整数加一；
+ Filtering：从队列中去除负整数；

这三个特质代表了修改，因为它们修改底下的队列类，而不是自己定义完整的队列类。**这三个特质也是可叠加
的。可以从这三个特质中任意选择，将它们混入类，并得到一个带上了你选择的修改的新的类**。

下面示例给出了一个 **抽象的IntQueue类**。IntQueue有一个put方法将新的整数加入队列，以及一个get方法
从队列中去除并返回整数：
```scala
abstract class IntQueue {
  def get: Int
  def put(x: Int)
}
```
下面的示例给出了使用ArrayBuffer的IntQueue的基本实现：
```scala
import scala.collection.mutable.ArrayBuffer

class BasicIntQueue extends IntQueue {
  private val buf = new ArrayBuffer[Int]
  override def get = buf.remove(0)
  override def put(x: Int) = buf += x
}
```
BasicIntQueue类用一个私有字段持有数组缓冲。get方法从缓冲的一端移除条目，而put方法向缓冲的另一端添
加元素。这个实现使用起来是这样的：
```scala
scala> val queue = new BasicIntQueue
queue: BasicIntQueue = BasicIntQueue@4c24bf66

scala> queue.put(10)
scala> queue.put(20)

scala> queue.get
res2: Int = 10

scala> queue.get
res3: Int = 20
```
到目前为止很不错。**现在我们来看看如何用特质修改这个行为**。下面示例给出了 **在放入队列时对整数翻倍
的特质**。Doubling特质有两个好玩的地方。**首先它声明了一个超类IntQueue。这个声明意味着这个特质只能
被混入同样继承自IntQueue的类**。因此，可以将Doubling混入BasicIntQueue，但不能将它混入Rational。
```scala
trait Doubling extends IntQueue {
  abstract override def put(x: Int) = super.put(2 * x)
}
```
第二个好玩的地方是 **该特质有在一个声明为抽象的方法里做了一个super调用，对于普通的类而言这样的调用
是非法的，因为它们在运行时必定会失败**。

