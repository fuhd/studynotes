理解Scala的类型推断算法
===================================================================================
我们之前用到的`sortWith`和`msort`的区别在于它们 **可接收的比较函数** 语法。我们来比较一下：
```scala
scala> msort((x: Char, y: Char) ⇒ x > y)(abcde)

res0: List[Char] = List(e, d, c, b, a)
```
和 
```scala
scala> abcde sortWith(_ > _)

res1: List[Char] = List(e, d, c, b, a)
```
这两个表达式是等效的，不过前者采用的 **比较函数字面量** 版本较长，用到了 **带名参数和显式类型声明**。
而后者采用了 **更精简的写法（`_ > _`）**，其中带名参数被替换成了 **下画线**。当然，我们也可以在
sortWith调用中使用前一种较长的写法来给出比较函数。

不过，这个较短的版本并不适用于`msort`：
```scala
scala> msort(_ > _)(abcde)

Error:(25, 11) missing parameter type for expanded function ((<x$1: error>, <x$2: error>) => x$1.$greater(x$2))
msort(_ > _)(abcde)
```
要搞清楚为什么会这样，我们需要知道Scala类型推断算法的一些细节。**Scala的类型推断是基于程序流
（`flow based`）的。对于方法调用`m(args)`，类型推断算法首先检查m的类型是否已知。如果m的类型已知，
那么这个类型信息就被用于推断入参的预期类型**。例如，在`abcde.sortWith(_ > _)`中，abcde的类型为
`List[Char]`。因此，类型推断算法知道`sortWith`是一个接收类型为`(Char, Char) -> Boolean`的入参且产出
一个类型为`List[Char]`的结果的方法。由于该函数入参的参数类型是已知的，并不需要显式地写出来。基于类
型推断算法所了解的关于`sortWith`的信息，它可以推导出`(_ > _)`应该被展开成`((x: Char, y: Char) => x > y)`，
其中x和y是任意没有被用过的新名称。

现在我们来看第二个case，`msort(_ > _)(abcde)`。`msort`的类型是一个 **经过柯里化的、多态的（参数多
态）方法类型**，它接收一个类型为`(T, T) => Boolean`的入参，产出一个从`List[T]`到`List[T]`的函数，**其
中T是某个当前未知的类型。`msort`需要先用一个类型参数实例化以后才能被应用到它的入参上**。

**由于`msort`的确切示例类型暂时未知，类型推断算法不能用这个信息来推断它的首个入参的类型。对于这种
情况，类型推断算法会改变策略，它改为先检查方法入参来决定方法的正确实例类型。然而，当它去对`(_ > _)`
这个简写的函数字面量做类型检查时，由于我们没有提供任何关于用下画线表示的函数参数类型的信息，类型检
查是失败的**。

**解决这个问题的一种方式是给`msort`传一个显式的类型参数**，如：
```scala
scala> msort[Char](_ > _)(abcde)

res2: List[Char] = List(e, d, c, b, a)
```

