理解Scala的类型推断算法
===================================================================================
我们之前用到的`sortWith`和`msort`的区别在于它们 **可接收的比较函数** 语法。我们来比较一下：
```scala
scala> msort((x: Char, y: Char) ⇒ x > y)(abcde)

res0: List[Char] = List(e, d, c, b, a)
```
和 
```scala
scala> abcde sortWith(_ > _)

res1: List[Char] = List(e, d, c, b, a)
```
这两个表达式是等效的，不过前者采用的 **比较函数字面量** 版本较长，用到了 **带名参数和显式类型声明**。
而后者采用了 **更精简的写法（`_ > _`）**，其中带名参数被替换成了 **下画线**。当然，我们也可以在
sortWith调用中使用前一种较长的写法来给出比较函数。

不过，这个较短的版本并不适用于`msort`：
```scala
scala> msort(_ > _)(abcde)

Error:(25, 11) missing parameter type for expanded function ((<x$1: error>, <x$2: error>) => x$1.$greater(x$2))
msort(_ > _)(abcde)
```
要搞清楚为什么会这样，我们需要知道Scala类型推断算法的一些细节。**Scala的类型推断是基于程序流
（`flow based`）的。对于方法调用`m(args)`，类型推断算法首先检查m的类型是否已知。如果m的类型已知，
那么这个类型信息就被用于推断入参的预期类型**。例如，在`abcde.sortWith(_ > _)`中，abcde的类型为
`List[Char]`。因此，类型推断算法知道`sortWith`是一个接收类型为`(Char, Char) -> Boolean`的入参且产出
一个类型为`List[Char]`的结果的方法。由于该函数入参的参数类型是已知的，并不需要显式地写出来。基于类
型推断算法所了解的关于`sortWith`的信息，它可以推导出`(_ > _)`应该被展开成`((x: Char, y: Char) => x > y)`，
其中x和y是任意没有被用过的新名称。

现在我们来看第二个case，`msort(_ > _)(abcde)`。`msort`的类型是一个 **经过柯里化的、多态的（参数多
态）方法类型**，它接收一个类型为`(T, T) => Boolean`的入参，产出一个从`List[T]`到`List[T]`的函数，**其
中T是某个当前未知的类型。`msort`需要先用一个类型参数实例化以后才能被应用到它的入参上**。

**由于`msort`的确切示例类型暂时未知，类型推断算法不能用这个信息来推断它的首个入参的类型。对于这种
情况，类型推断算法会改变策略，它改为先检查方法入参来决定方法的正确实例类型。然而，当它去对`(_ > _)`
这个简写的函数字面量做类型检查时，由于我们没有提供任何关于用下画线表示的函数参数类型的信息，类型检
查是失败的**。

**解决这个问题的一种方式是给`msort`传一个显式的类型参数**，如：
```scala
scala> msort[Char](_ > _)(abcde)

res2: List[Char] = List(e, d, c, b, a)
```
由于`msort`的正确实例类型现在是已知的了，类型推断算法可以用它来推断入参的类型。**另一个可能的解决
方案是重写`msort`方法，让它的两个参数交换位置**：
```scala
def msortSwapped[T](xs: List[T])(less: (T, T) ⇒ Boolean): List[T] = {
    //与msort相同的实现，不过入参交换了位置
}
```
这样的类型推断也能成功：
```scala
scala> msortSwapped(abcde)(_ > _)

res3: List[Char] = List(e, d, c, b, a)
```
怎么做到的？**类型推断算法使用了首个参数`abcde`的已知类型来判定`msortSwapped`的类型参数。一旦
`msortSwapped`的确切类型已知，它就能被用于推断第二个入参`(_ > _)`的类型**。

一般来说，当类型推断算法需要推断一个多态方法的类型参数时，它会考虑第一个参数列表里的所有入参的类型，
但到此为止。由于`msortSwapped`是一个柯里化的方法，它有两个参数列表，第二个入参（即函数值）并不会
用来判定方法的类型参数。

这样的类型推断机制引导出如下的类库设计原则：**当我们设计一个接收某些非函数的入参和一个函数入参时，
将函数入参单独放在最后一个参数列表中。这样一来，方法的正确实例类型可以从哪些非函数入参推断出来，而
这个类型又能被继续用于对函数入参做类型检查。这样做的净收益是方法的使用者需要给出的类型 信息更少，因
而在编写函数字面量时可以更精简**。

接下来再看看折叠这个更复杂的操作。**为什么我们需要像330页的`flattenRight`方法的方法体内的那段表达式
那样显式地给出类型参数呢**？
```scala
(xss :\ List[T]())(_ ::: _)
```
右折叠操作的类型以两个类型变量的形式呈现出多态。比如下面这个表达式：
```scala
(xs :\ z)(op)
```
xs的类型一定是某个任意类型A的列表，比如说`xs: List[A]`。起始值z可以是某个不一样的类型B。这样一来操作
op一定是接收类型分别为A和B的两个入参，返回类型为B的结果，即`op: (A, B) => B`。**由于z的类型跟列表xs
的类型不相关，类型推断算法就没有任何关于z的上下文信息**。

现在我们来看330页的那个错误版本的flattenRight：
```scala
//这不能编译
(xss :\ List())(_ ::: _)
```
这个折叠操作中的起始值z是一个空列表`List()`，当没有任何其他额外信息的情况下，它的类型被推断为
`List[Nothing]`。因此，类型推断算法会推断出本次折叠操作的类型B为`List[Nothing]`。这样一来，折叠操作
中的`(_ ::: _)`预期应该满足如下类型：
```scala
(List[T], List[Nothing]) => List[Nothing]
```

