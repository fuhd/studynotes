理解Scala的类型推断算法
===================================================================================
我们之前用到的`sortWith`和`msort`的区别在于它们 **可接收的比较函数** 语法。我们来比较一下：
```scala
scala> msort((x: Char, y: Char) ⇒ x > y)(abcde)

res0: List[Char] = List(e, d, c, b, a)
```
和 
```scala
scala> abcde sortWith(_ > _)

res1: List[Char] = List(e, d, c, b, a)
```
这两个表达式是等效的，不过前者采用的 **比较函数字面量** 版本较长，用到了 **带名参数和显式类型声明**。
而后者采用了 **更精简的写法（`_ > _`）**，其中带名参数被替换成了 **下画线**。当然，我们也可以在
sortWith调用中使用前一种较长的写法来给出比较函数。

不过，这个较短的版本并不适用于`msort`：
```scala
scala> msort(_ > _)(abcde)

Error:(25, 11) missing parameter type for expanded function ((<x$1: error>, <x$2: error>) => x$1.$greater(x$2))
msort(_ > _)(abcde)
```
要搞清楚为什么会这样，我们需要知道Scala类型推断算法的一些细节。**Scala的类型推断是基于程序流
（`flow based`）的。对于方法调用`m(args)`，类型推断算法首先检查m的类型是否已知。如果m的类型已知，
那么这个类型信息就被用于推断入参的预期类型**。例如，在`abcde.sortWith(_ > _)`中，abcde的类型为
`List[Char]`。因此，类型推断算法知道`sortWith`是一个接收类型为`(Char, Char) -> Boolean`的入参且产出
一个类型为`List[Char]`的结果的方法。由于该函数入参的参数类型是已知的，并不需要显式地写出来。基于类
型推断算法所了解的关于`sortWith`的信息，它可以推导出`(_ > _)`应该被展开成`((x: Char, y: Char) => x > y)`，
其中x和y是任意没有被用过的新名称。

