List类的高阶方法
===================================================================================
许多对列表的操作都有相似的结构，有一些模式反复出现。例如：以某种方式对列表中的每个元素做转换，验证
列表中所有元素是否都满足某种性质，从列表元素中提取满足某个指定条件的元素，或用某种操作符来组合列表
中的元素。在Java中，这些模式通常要通过固定写法的for循环或while循环来组装。**而Scala允许我们使用高阶
操作符来更精简、更直接地表达，这些高阶操作是通过List类的方法实现的**。
```
这里所说的高阶操作符指的是用在操作符表示法中的高阶函数。
```

## 1. 对列表作映射：map、flatMap和foreach
**`xs map f`这个操作将类型为`List[T]`的列表xs和类型为`T => U`的函数f作为操作元。它返回一个通过应用f
到xs的每个元素后得到的列表**。例如：
```scala
scala> List(1, 2, 3) map (_ + 1)
res0: List[Int] = List(2, 3, 4)

scala> val wordLi = List("the", "quick", "brown", "fox")
wordLi: List[String] = List(the, quick, brown, fox)

scala> wordLi map (_.length)
res1: List[Int] = List(3, 5, 5, 3)

scala> wordLi map (_.toList.reverse.mkString)
res2: List[String] = List(eht, kciuq, nworb, xof)
```
**flatMap操作符跟map类似，不过它要求右侧的操作元是一个返回元素列表的函数。它将这个函数应用到列表的
每个元素，然后将所有结果拼接起来返回**。下面的例子展示了map和flatMap的区别：
```scala
scala> wordLi map (_.toList)
res3: List[List[Char]] = List(List(t, h, e), List(q, u, i, c, k), List(b, r, o, w, n), List(f, o, x))

scala> wordLi flatMap (_.toList)
res4: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x)
```
我们可以看到，**map返回的是列表的列表，而flatMap返回的是所有元素拼接起来的单个列表**。

下面这个表达式也体现了map和flatMap的区别与联系，这个表达式构建的是一个满足`1 <= j < i < 5`的所有对偶
`（i, j）`：
```scala
scala> List.range(1, 5) flatMap (i ⇒ List.range(1, i) map (j ⇒ (i, j)))
res5: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))
```
**`List.range`是一个用来创建某个区间内所有整数的列表的工具方法**。在本例中，我们用到了两次：一次是
生成 **从1（含）到5（不含）的整数列表**，另一次是生成从1到i的整数列表，其中i是来自第一个列表的每个元
素。表达式中的map生成的是一个由元素`(i, j)`组成的列表，其中`j < i`。外围的flatMap对1到5之间的每个i生
成一个列表，并将结果拼接起来。**也可以用for表达式来构建同样的列表**：
```scala
scala> for (i ← List.range(1, 5); j ← List.range(1, i)) yield (i, j)
res6: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))
```
你将在第23章了解到更多关于for表达式和列表操作的内容。

**第三个映射类的操作是foreach**。不同于map和flatMap，**foreach要求右操作元是一个过程（结果类型为
Unit的函数）。它只是简单地将过程应用到列表中的每个元素。整个操作本身的结果类型也是Unit，并没有列表
类型的结果被组装出来**。参考下面这个精简的将列表中所有数值加和的例子：
```scala
scala> var sum = 0
sum: Int = 0

scala> List(1, 2, 3, 4, 5) foreach (sum += _)
scala> sum 
res8: Int = 15
```

## 2. 过滤列表：filter、partition、find、takeWhile、dropWhile和span
**`xs filter p`这个操作的两个操作元分别是类型为`List[T]`的xs和类型为`T => Boolean`的前提条件函数p。这
个操作将交出xs中所有`p(x)`为true的元素x**。例如：
```scala
scala> List(1, 2, 3, 4, 5) filter (_ % 2 == 0)
res0: List[Int] = List(2, 4)

scala> val wordLi2 = List("the", "quick", "brown", "fox")
wordLi2: List[String] = List(the, quick, brown, fox)

scala> wordLi2 filter (_.length == 3)
res1: List[String] = List(the, fox)
```
**partition方法跟filter很像，不过返回的是一对列表。其中一个包含所有前提条件为true的元素，另一个包含所
有前提条件为false的元素**。参考下面的例子：
```scala
scala> List(1,2,3,4,5) partition (_ % 2 == 0)
res2: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))
```
**find方法跟filter也很像，不过它返回满足给定前提条件的第一个元素，而不是所有元素。`xs find p`这个操作
接收列表xs和前提条件函数p两个操作元，返回一个可选值。如果xs中存在一个元素x满足`p(x)`为true，那么就
返回`Some(x)`。而如果对于所有元素而言p都为false，那么则返回None**。来看一些例子：
```scala
scala> List(1, 2, 3, 4, 5) find (_ % 2 == 0)
res3: Option[Int] = Some(2)

scala> List(1, 2, 3, 4, 5) find (_ < 0)
res4: Option[Int] = None
```
**takeWhile和dropWhile操作符也将一个前提条件作为右操作元。`xs takeWhile p`操作返回列表xs中连续满足
p的最长前缀。同理，`xs dropWhile p`操作将去除列表xs中连续满足p的最长前缀**。来看一些例子：
```scala
scala> List(1, 2, 3, -4, 5) takeWhile (_ > 0)
res5: List[Int] = List(1, 2, 3)

scala> wordLi2 dropWhile (_ startsWith "t")
res6: List[String] = List(quick, brown, fox)
```
**span方法将takeWhile和dropWhile两个操作合二为一，就像splitAt将take和drop合二为一一样**。它返回
一堆列表，满足如下等式：
```
xs span p   等于  (xs takeWhile p, xs dropWhile p)
```
跟splitAt一样，**span同样不会重复遍历xs**：
```scala
scala> List(1, 2, 3, -4, 5) span (_ > 0)
res7: (List[Int], List[Int]) = (List(1, 2, 3),List(-4, 5))
```

## 3. 对列表的前提条件检查：forall和exists
**`xs forall p`这个操作接收一个列表xs和一个前提条件p作为入参。如果列表中所有元素都满足p就返回true**。
与此相反，**`xs exists p`操作返回true的要求是xs中存在一个元素满足前提条件p**。例如，要搞清楚一个以
列表的列表表示的矩阵里是否存在一行的元素全为0：
```scala
# 
scala>  def hasZoreRow(m: List[List[Int]]) = m exists (_ forall (_ == 0))
hasZoreRow: (m: List[List[Int]])Boolean

scala> hasZoreRow(List(List(1, 2, 3), List(1, 0, 4), List(0, 0, 0, 0))) 
res0: Boolean = true
```

## 4. 折叠列表：/: 和 :\
```
说明

 /:和:\在新版本中已经废弃，现在用foldLeft与foldRight方法代替。
```
对列表的另一种常见操作是 **用某种操作符合并元素**。例如：
```
sum(List(a, b, c))      等于  0 + a + b + c
```
下面是一个 **折叠操作的特例**：
```scala
scala> def sum1(xs: List[Int]) = (0 /: xs) (_ + _)
sum1: (xs: List[Int])Int

scala> def sum2(xs: List[Int]) = xs.foldLeft(0)(_ + _)
(xs: List[Int])Int
```
