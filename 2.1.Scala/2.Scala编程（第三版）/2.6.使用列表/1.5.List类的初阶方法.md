List类的初阶方法
===================================================================================
本节将会介绍定义在List类里的大部分初阶方法。**如果一个方法不接收任何函数作为入参，就被称为初阶方法**。

## 1. 拼接两个列表
**跟`::`操作相似的一个操作是拼接，写作`:::`。不同于`::`，`:::`接收两个列表参数作为操作元**。`xs ::: ys`
的结果是一个包含了xs所有元素，加上ys所有元素的新列表。

这里有一些例子：
```scala
scala> List(1, 2) ::: List(3, 4, 5)
res0: List[Int] = List(1, 2, 3, 4, 5)

scala> List() ::: List(1, 2, 3)
res1: List[Int] = List(1, 2, 3)

scala> List(1, 2, 3) ::: List(4)
res2: List[Int] = List(1, 2, 3, 4)
```
跟cons类似，**列表的拼接操作也是右结合的**。像这样一个表达式：
```scala
xs ::: ys ::: zs
```
会被解读成：
```scala
xs ::: (ys ::: zs)
```

## 2. 分治原则
拼接（`:::`）是作为List类的一个方法实现的。我们也可以 **通过对列表进行模式匹配来“手工”实现拼接**。
我们建议你自己做一下尝试，因为这个过程展示了用列表实现算法的常用方式。首先，我们明确一下 **拼接方法**
（我们叫它 **append**）的签名。为了不把事情搞得过于复杂，我们假定append是在List类之外定义的，这样
它就需要接收两个待拼接的列表作为参数。这两个列表必须有相同的元素类型，但这个类型具体是什么并不重要。
可以给append指定一个代表两个列表的元素类型的类型参数来表达这层意思：
```scala
def append[T](xs: List[T], ys: List[T]): List[T]
```
要设计这样一个append方法，有必要回顾一下 **对于列表这样的递归数据结构的“分而治之”的程序设计原则**。
许多 **对列表的算法** 都首先会用 **模式匹配** 将输入的列表切分成 **更小的样例**。这是设计原则中“**分**”
的部分。然后对每个样例构建对应的结果。如果结果是一个 **非空的列表**，那么这个列表的局部可以通过 
**递归地调用同一个算法** 来构建出来。这是设计原则中“**治**”的部分。

把这个设计原则应用到append方法的实现，我们要问的 **第一个问题是匹配哪一个列表**。跟其他方法相比，
append方法并不简单，因为我们有两个选择。好在后续的“治”的部分告诉我们需要同时包含两个输入列表的所
有元素。**由于列表是从后往前构建的，ys可以保持不动，而xs则需要被解开然后追加到ys的前面**。这样一来，
我们有理由选择xs作为模式匹配的来源。匹配列表最常见的模式是区分空列表和非空列表。于是我们得到如下
append方法的轮廓：
```scala
def append[T](xs: List[T], ys: List[T]): List[T] = 
  xs match {
    case List() ⇒ ???
    case x :: xsl = ???
  }
```


