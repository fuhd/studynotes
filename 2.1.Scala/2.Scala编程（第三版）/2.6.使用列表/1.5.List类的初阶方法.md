List类的初阶方法
===================================================================================
本节将会介绍定义在List类里的大部分初阶方法。**如果一个方法不接收任何函数作为入参，就被称为初阶方法**。

## 1. 拼接两个列表
**跟`::`操作相似的一个操作是拼接，写作`:::`。不同于`::`，`:::`接收两个列表参数作为操作元**。`xs ::: ys`
的结果是一个包含了xs所有元素，加上ys所有元素的新列表。

这里有一些例子：
```scala
scala> List(1, 2) ::: List(3, 4, 5)
res0: List[Int] = List(1, 2, 3, 4, 5)

scala> List() ::: List(1, 2, 3)
res1: List[Int] = List(1, 2, 3)

scala> List(1, 2, 3) ::: List(4)
res2: List[Int] = List(1, 2, 3, 4)
```
跟cons类似，**列表的拼接操作也是右结合的**。像这样一个表达式：
```scala
xs ::: ys ::: zs
```
会被解读成：
```scala
xs ::: (ys ::: zs)
```

## 2. 分治原则
拼接（`:::`）是作为List类的一个方法实现的。我们也可以 **通过对列表进行模式匹配来“手工”实现拼接**。
我们建议你自己做一下尝试，因为这个过程展示了用列表实现算法的常用方式。首先，我们明确一下 **拼接方法**
（我们叫它 **append**）的签名。为了不把事情搞得过于复杂，我们假定append是在List类之外定义的，这样
它就需要接收两个待拼接的列表作为参数。这两个列表必须有相同的元素类型，但这个类型具体是什么并不重要。
可以给append指定一个代表两个列表的元素类型的类型参数来表达这层意思：
```scala
def append[T](xs: List[T], ys: List[T]): List[T]
```
要设计这样一个append方法，有必要回顾一下 **对于列表这样的递归数据结构的“分而治之”的程序设计原则**。
许多 **对列表的算法** 都首先会用 **模式匹配** 将输入的列表切分成 **更小的样例**。这是设计原则中“**分**”
的部分。然后对每个样例构建对应的结果。如果结果是一个 **非空的列表**，那么这个列表的局部可以通过 
**递归地调用同一个算法** 来构建出来。这是设计原则中“**治**”的部分。

把这个设计原则应用到append方法的实现，我们要问的 **第一个问题是匹配哪一个列表**。跟其他方法相比，
append方法并不简单，因为我们有两个选择。好在后续的“治”的部分告诉我们需要同时包含两个输入列表的所
有元素。**由于列表是从后往前构建的，ys可以保持不动，而xs则需要被解开然后追加到ys的前面**。这样一来，
我们有理由选择xs作为模式匹配的来源。**匹配列表最常见的模式是区分空列表和非空列表**。于是我们得到如
下append方法的轮廓：
```scala
def append[T](xs: List[T], ys: List[T]): List[T] = 
  xs match {
    case List() ⇒ ???
    case x :: xsl = ???
  }
```
剩下要做的便是填充由`???`标出的两处。**第一处是当输入列表xs为空时的可选分支**。这个case当中拼接操
作可以直接交出第二个列表：
```scala
case List() ⇒ ys
```
**第二处是当输入列表xs由某个头x和尾xsl组成时的可选分支**。这个case中结果也是一个非空列表。要构建一
个非空列表，我们需要知道这个非空列表的头和尾分别是什么。我们已经知道结果的第一个元素是x。而余下的元
素可以通过将第二个列表ys拼接在第一个列表的剩余部分即xsl之后。

这样我们就得到了完整的设计：
```scala
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List() ⇒ ys
    case x :: xsl ⇒ x :: append(xsl, ys)
  }
```
第二个可选分支的计算展示了分治原则中“治”的部分：首先思考我们想要的输出的形状是什么，然后计算这个
形状当中的各个独立的组成部分，**在这个过程中的必要环节递归地调用同一个算法**。最后，从这些组成部分
构建出最终的输出结果。

## 3. 获取列表的长度：length 
length方法计算列表的长度。
```scala
scala> List(1, 2, 3).length
res3: Int = 3
```
**不同于数组，在列表上的length操作相对更耗资源。找到一个列表的末尾需要遍历整个列表，因此需要消耗与
元素数量成正比的时间。这也是为什么将`xs.isEmpty`这样的测试换成`xs.length == 0`并不是个好的注意**。
这两种测试的结果并没有区别，但第二个会更慢，尤其当列表xs很长时。

## 4. 访问列表的末端： init和last
我们已经知道基本的操作head和tail，它们分别获取列表的首个元素和除了首个元素剩余的部分。它们也分别有
一个对偶（`dual`）方法：**`last`返回（非空）列表 的最后一个元素，而`init`返回除了最后一个元素之外剩
余的部分**：
```scala
scala> val abcde = List('a', 'b', 'c', 'd', 'e')
abcde: List[Char] = List(a, b, c, d, e)

scala> abcde.last
res4: Char = e

scala> abcde.init
res5: List[Char] = List(a, b, c, d)
```
跟head和tail一样，**这两个方法在应用到空列表的时候也会抛出异常**：
```scala
scala> List().init
java.lang.UnsupportedOperationException: init of empty list
at scala.collection.immutable.Nil$.init(List.scala:596)
at scala.collection.immutable.Nil$.init(List.scala:591)
... 31 elided

scala> List().last
java.util.NoSuchElementException: last of empty list
at scala.collection.immutable.Nil$.last(List.scala:595)
at scala.collection.immutable.Nil$.last(List.scala:591)
... 31 elided
```
不像head和tail那样在运行的时候消耗常量时间，**init和last需要遍历整个列表来计算结果。因此它们的耗时跟
列表的长度成正比**。
```
说明

最好将数据组织成大多数访问都发生在列表头部而不是尾部。
```

## 5. 反转列表：reverse
如果在算法当中某个点 **需要频繁地访问列表的末尾，有时候先将列表反转再对反转后的列表做操作是更好的做
法**。下面是一个反转的例子：
```scala
scala> abcde.reverse
res6: List[Char] = List(e, d, c, b, a)
```
跟所有某他列表操作一样，**reverse会创建一个新的列表，而不是对传入的列表做修改。由于列表是不可变的**，
这样的修改就算想做我们也做不到。现在来验证一下，在reverse操作过后，abcde的原始值并没有变：
```scala
scala> abcde
es7: List[Char] = List(a, b, c, d, e)
```
reverse、init和last操作满足一些可以用于对 **计算过程推理**，以及让程序变得 **简化** 的法则。
1. **reverse是自己的反转**：
  ```scala
  xs.reverse.reverse      //等于xs
  ```
2. **reverse将init变成tail，将last变成head，只不过元素顺序是颠倒的**：
  ```scala
  xs.reverse.init   
  //等同于
  xs.tail.reverse

  xs.reverse.tail
  //等同于
  xs.init.reverse

  xs.reverse.head
  //等同于
  xs.last

  xs.reverse.last
  //等同于
  xs.head
  ```
**反转操作也可以用拼接（`:::`）来实现**，就像下面这个方法rev：
```scala
def rev[T](xs: List[T]): List[T] = xs match {
  case List() ⇒ xs
  case x :: xsl ⇒ rev(xsl) ::: List(x)
}
```
不过，**这个方法的效率并不高**。我们不妨来看一下rev的 **时间复杂度**，假定xs列表长度为n。注意会有n
次对rev的递归调用。除了最后一次之外，每次调用都会做列表拼接。`xs ::: ys`这样的列表拼接所需要的时间跟
首个入参xs的长度成正比。因此，rev的整体复杂度为：
```
n + (n - 1) + ... + 1 = (1 + n) * n/2
```
换句话说，**rev的时间复杂度是入参长度的平方阶**。这跟时间复杂度为线性的可变链表的标准反转操作比起
来很令人失望。不过，rev当前的实现还能做得更好。

## 6. 前缀和后缀：drop、take和splitAt
**drop和take** 是对tail和init的  **一般化**。怎么说呢？**它们返回的是列表任意长度的前缀或后缀**。表达
式“xs take n”返回列表xs的前n个元素。如果n大于`xs.length`，那么将返回整个xs列表。



