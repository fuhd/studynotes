用try表达式实现异常处理
================================================================================
**Scala的异常处理跟其他语言类似。方法除了正常地返回某个值外，也可以通过抛出异常终止执行**。方法
的调用方要么捕获并处理这个异常，要么自我终止，让异常传播到更上层调用方。异常通过这种方式传播，逐
个展开调用栈，直到某个方法处理该异常或者再没有更多方法了为止。

## 1.抛出异常
在Scala中抛出异常跟Java看上去一样。你需要 **创建一个异常对象然后用throw关键字将它抛出**：
```scala
throw new IllegalArgumentException
```
**在Scala中throw是一个有结果类型的表达式**。如下是一个带有结果类型的示例：
```scala
val half = 
  if (n % 2 == 0)
    n / 2
  else
    throw new RuntimeException("n must be even)
```
在这段代码中，如果`n`是偶数，`half`将被初始化成`n`的一半。如果`n`不是偶数，那么在`half`初始化
之前，就会有异常抛出。因此，**我们可以安全地将抛出异常当作任何类型的值来对待。任何想要使用throw
给出的这个返回值的上下文都没有机会真正使用它，也就不必担心有其他问题**。

技术上讲，**抛出异常这个表达式的类型是Nothing。哪怕表达式从不实际被求值，也可以用throw**。这个
技术细节听上去有点奇怪，不过在前一例这样的场景下，还是很常见也很有用的。if的一个分支计算出来某个
值，而另一个分支抛出异常并计算出Nothing。**整个if表达式的类型就是那个计算出某个值的分支的类型**。

## 2.捕获异常
可以使用下面示例中的语法来捕获异常。catch子句的语法之所以是这样，为的是与Scala的一个重要组成部
分：***模式匹配***，保持一致。
```scala
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

try {
  val f = new FileReader("input.txt")
  //使用并关闭文件
} catch {
  case ex: FileNotFoundException ⇒ //处理打不到文件的情况
  case ex: IOException ⇒ //处理其他IO错误
}
```
这个`try-catch`表达式跟其他带有异常处理的语言一样。首先代码体会被执行，如果抛出异常，则会依次尝
试每个catch子句。在本例中，如果异常的类型是FileNotFoundException，第一个子句将被执行。如果异
常的类型是IOException，那么第二个子句将被执行。**而如果异常既不是FileNotFoundException也不
是IOException，`try-catch`将会终止，异常将向上继续传播**。
```
注意

你会注意到一个Scala跟Java的区别，Scala并不要求你捕获受检异常（checked exception）或在throws子句里声明。可以选择
用@throws注解来声明一个throws子句，但这并不是必须的。关于@throws的详情，请参考31.1节。
```

## 3.finally子句
**可以将那些不论是否抛出异常都想执行的代码以表达式的形式包在finally子句里**。例如，你可能想要确
保某个打开的文件要被正确关闭，哪怕某个方法因为抛出了异常而退出。示例如下：
```scala
import java.io.FileReader
val file = new FileReader("input.txt")
try {
    //使用文件
} finally {
    file.close()    //确保关闭文件
}
```