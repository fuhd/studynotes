实现above、beside和toString
===================================================================================
接下来，我们将实现Element类的 **above** 方法。**将某个元素放在另一个“上面”** 意味着将两个元素的
值拼接在一起。第一版的above方法可能是这样的：
```scala
def above(that: Element): Element = new ArrayElement(this.contents ++ that.contents)
```
**其中`++`这个操作将两个数组拼接在一起**。Scala中的数组是用Java的数组表示的，不过支持更多的方法。

事实上，前面给出的代码并不是很够用，因为它并不允许你将宽度不同的元素叠在一起。不过为了让事情保持简
单，我们将不理会这个问题，只是每次都记得传入相同长度的元素给above。

下一个要实现的方法是 **beside**。**要把两个元素并排放在一起**，我们将创建一个新的元素。在这个新元
素中，每一行都是由两个元素的对应行拼接起来的。跟之前一样，为了让事情保持简单，我们一开始假定两个元
素有相同的高度，这让我们设计出下面这个beside方法：
```scala
def beside(that: Element): Element = {
    val contents = new Array[String](this.contents.length)
    for (i ← 0 until this.contents.length)
      contents(i) = this.contents(i) + that.contents(i)
    new ArrayElement(contents)
  }
```
这个beside方法首先分配一个新的数组contents，用this.contents和that.contents对应的数组元素拼接的字符串
数组填充。最后，产生一个新的包含新的contents的ArrayElement。

**虽然这个beside的实现可以解决问题，它是用指令式风格编写的，明显的标志是我们用下标遍历数组时使用的
循环**。换一种方式，可以将这个方法简化为一个表达式：
```scala
def beside(that: Element): Element = {
    new ArrayElement(
      for ((line1, line2) ← this.contents zip that.contents) yield line1 + line2
    )
  }
```
在这里，我们 **用zip操作符将this.contents和that.contents这两个 数组转换成对偶（即：Tuple2）的数组 。
这个zip操作符从它的两个操作元中选取 对应的元素，组装 成一个对偶 （pair）**，例如，如下表达式：
```scala
Array(1, 2, 3) zip Array("a", "b")
```
将被求值为：
```
Array((1,"a"), (2,"b"))
```

