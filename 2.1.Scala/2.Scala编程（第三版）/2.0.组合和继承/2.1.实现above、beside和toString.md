实现above、beside和toString
===================================================================================
接下来，我们将实现Element类的 **above** 方法。**将某个元素放在另一个“上面”** 意味着将两个元素的
值拼接在一起。第一版的above方法可能是这样的：
```scala
def above(that: Element): Element = new ArrayElement(this.contents ++ that.contents)
```
**其中`++`这个操作将两个数组拼接在一起**。Scala中的数组是用Java的数组表示的，不过支持更多的方法。

事实上，前面给出的代码并不是很够用，因为它并不允许你将宽度不同的元素叠在一起。不过为了让事情保持简
单，我们将不理会这个问题，只是每次都记得传入相同长度的元素给above。

下一个要实现的方法是 **beside**。**要把两个元素并排放在一起**，我们将创建一个新的元素。在这个新元
素中，每一行都是由两个元素的对应行拼接起来的。跟之前一样，为了让事情保持简单，我们一开始假定两个元
素有相同的高度，这让我们设计出下面这个beside方法：
```scala
def beside(that: Element): Element = {
    val contents = new Array[String](this.contents.length)
    for (i ← 0 until this.contents.length)
      contents(i) = this.contents(i) + that.contents(i)
    new ArrayElement(contents)
  }
```
这个beside方法首先分配一个新的数组contents，用this.contents和that.contents对应的数组元素拼接的字符串
数组填充。最后，产生一个新的包含新的contents的ArrayElement。

**虽然这个beside的实现可以解决问题，它是用指令式风格编写的，明显的标志是我们用下标遍历数组时使用的
循环**。换一种方式，可以将这个方法简化为一个表达式：
```scala
def beside(that: Element): Element = {
    new ArrayElement(
      for ((line1, line2) ← this.contents zip that.contents) yield line1 + line2
    )
  }
```
在这里，我们 **用zip操作符将this.contents和that.contents这两个 数组转换成对偶（即：Tuple2）的数组 。
这个zip操作符从它的两个操作元中选取 对应的元素，组装 成一个对偶 （pair）**，例如，如下表达式：
```scala
Array(1, 2, 3) zip Array("a", "b")
```
将被求值为：
```
Array((1,"a"), (2,"b"))
```
**如果其中一个操作元数组比另一个长，zip将会仍掉多余的元素**。在上面的表达式中，左操作元的第三个元
素3并没有进入结果 ，因为它在右操作元中并没有对应的元素。

接下来，这个zip起来的数组被一个for表达式遍历 。在这里，“for((line1, line2) <- ...)”**这样的语法允许你在
一个模式 （pattern）中同时对两个元素命名**（也就是说line1表示对偶的每一个元素，而line2表示对偶的第二
个元素）。我们将在第15章详细 介绍 Scala的模式匹配系统。**就现在而言，你可以认为这是在迭代中的每一步
定义两个val(line1和line2)的一种方式**。

**for表达式有一个部分叫作yield，通过 yield交出结果。这个结果的类型和被遍历 的表达式是同一种（也就是数
组）**。数组中的每个元素都是将对应的行line1和line2拼接起来的结果。因此 这段代码的最终结果跟第一版的
beside一样，不过由于它避免了显式的数组下标，获取结果的过程更少出错。





