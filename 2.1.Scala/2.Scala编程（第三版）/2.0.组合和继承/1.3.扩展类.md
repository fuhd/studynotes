扩展类
===================================================================================
我们仍然需要有某种方式创建新的元素对象。你已经看到"new Element"是不能用的，因为Element类是抽象的。
因此，要实例化一个元素，需要创建一个扩展自Element的子类，并实现contents这个抽象方法。下面的示例给
出了一种可能的做法：
```scala
class ArrayElement(conts: Array[String]) extends Element {
  override def contents: Array[String] = conts
}
```
ArrayElement类被定义为 **扩展**（extend）自Element类。跟Java一样，可以在 **类名后面用extends子句**
来表达。

这样的extends子句有两个作用：它使得ArrayElement类从Element类 **继承所有非私有成员**，并且它也让
**ArrayElement的类型成为Element类型的子类型**。由于ArrayElement扩展自Element，ArrayElement类被
称作 **Element类的子类**。反过来讲，Element是ArrayElement的 **超类**。**如果你去掉extends子句，
Scala编译器会默认假定你的类扩展自`scala.AnyRef`**，这对应到Java平台跟`java.lang.Object`相同。因此，
Element类默认也扩展自AnyRef类。

**继承的意思是超类的所有成员也是子类的成员，但是有两个例外。一是超类的私有成员并不会被子类继承：二
是如果子类里已经实现了相同名称和参数的成员，那么该成员不会被继承。对后面这种情况我们也说子类的成员
重写（override)了超类的成员。如果子类的成员是具体的而超类的成员是抽象的，我们也说这个具体的成员实现
了那个抽象的成员**。



