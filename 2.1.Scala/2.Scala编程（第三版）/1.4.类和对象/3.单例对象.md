单例对象
================================================================================
**Scala比Java更面向对象一点**，是Scala的类不允许有静态（static）成员。对此类使用场景，Scala
提供了 **单例对象**（`singleton object`）。单例对象的定义看上去跟类定义很像，只不过class关键
字被换成了 **object关键字**，示例：
```scala
//位于ChecksumAccumulator.scala文件中
import scala.collection.mutable
object ChecksumAccumulator {
    private val cache = mutable.Map.empty[String, Int]
    def calculate(s: String): Int =
        if(cache.contains(s))
            cache(s)
        else {
            val acc = new ChecksumAccumulator
            for(c <- s)
                acc.add(c.toByte)
            val cs = acc.checksum()
            cache += (s -> cs)
            cs
        }
}
```
示例中的单例对象名叫ChecksumAccumulator，跟前一个例子中的类名一样。**当单例对象跟某个类共用一
个名字时，它被称作这个类的伴生对象（companion object）。必须在同一个源码文件中定义类和类的伴生
对象。同时，类又叫作这个单例对象的伴生类（companion class）。类和它的伴生对象可以互相访问对方的
私有成员**。

ChecksumAccumulator单例对象有一个名为calculate的方法，接收一个String，计算这个String的所有
字符的校验和（checksum）。它同样也有个私有的字段cache，这是一个缓存了之前已计算过的校验和。
```
注：

我们在这里用了一个缓存来展示带有字段的实例对象。类似这样的缓存是以牺牲内存换取计算时间的方式来提升性能的。通常来说，
只有当你遇到缓存能解决的性能问题时才会用到这样的缓存，并且你可能会用一个弱引用的映射，比如scala.collection.jcl
的WeakHashMap，以便内存吃紧时，缓存中的条目可以被垃圾回收掉。
```
方法的第一行，`if(cache.contains(s))`，检查缓存看是否传入的字符串已经包含在映射当中了。如果是，
那么就返回映射的值，即`cache(s)`，如果没有，则执行else子句，计算校验和。else子句的第一行定义了
一个名为acc的val，用一个新的ChecksumAccumulator实例初始化。
```
注：

由于new关键字仅被用于实例化类，这里创建的对象是ChecksumAccumulator类的实例，而不是相同名字的那个单例对象。
```
接下来的一行是一个for表达式，遍历传入字符串的每一个字符，通过调用toByte方法将字符转成Byte，然后
将Byte传给acc指向的ChecksumAccumulator实例的add方法。在for表达式执行完成以后，方法的下一行
调用acc的checksum，从传入的String得到其校验和，保存到名为cs的val。再往下一行，`cache += (s -> cs)`，
传入的字符串作为键，计算出的整型的校验和作为值，这组键值对被添加到缓存映射当中。该方法的最后一个表
达式，即cs，确保了该方法的结果是这个校验和。



































dd


































ddd
