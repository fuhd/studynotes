单例对象
================================================================================
**Scala比Java更面向对象一点**，是Scala的类不允许有静态（static）成员。对此类使用场景，Scala
提供了 **单例对象**（`singleton object`）。单例对象的定义看上去跟类定义很像，只不过class关键
字被换成了 **object关键字**，示例：
```scala
//位于ChecksumAccumulator.scala文件中
import scala.collection.mutable
object ChecksumAccumulator {
    private val cache = mutable.Map.empty[String, Int]
    def calculate(s: String): Int =
        if(cache.contains(s))
            cache(s)
        else {
            val acc = new ChecksumAccumulator
            for(c <- s)
                acc.add(c.toByte)
            val cs = acc.checksum()
            cache += (s -> cs)
            cs
        }
}
```
示例中的单例对象名叫ChecksumAccumulator，跟前一个例子中的类名一样。**当单例对象跟某个类共用一
个名字时，它被称作这个类的伴生对象（companion object）。必须在同一个源码文件中定义类和类的伴生
对象。同时，类又叫作这个单例对象的伴生类（companion class）。类和它的伴生对象可以互相访问对方的
私有成员**。

ChecksumAccumulator单例对象有一个名为calculate的方法，接收一个String，计算这个String的所有
字符的校验和（checksum）。它同样也有个私有的字段cache，这是一个缓存了之前已计算过的校验和。
```
注：

我们在这里用了一个缓存来展示带有字段的实例对象。类似这样的缓存是以牺牲内存换取计算时间的方式来提升性能的。通常来说，
只有当你遇到缓存能解决的性能问题时才会用到这样的缓存，并且你可能会用一个弱引用的映射，比如scala.collection.jcl
的WeakHashMap
```



































ddd
