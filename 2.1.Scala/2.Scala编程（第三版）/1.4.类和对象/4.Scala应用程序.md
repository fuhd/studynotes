Scala应用程序
================================================================================
要运行一个Scala程序，必须提供一个 **独立对象的名称**。这个独立对象需要 **包含一个main方法**，
该方法接收一个 **Array[String]** 作为参数，结果类型为 **Unit**。任何带有满足 **正确签名的
main方法** 的独立对象都能被用作应用程序的入口。示例：
```scala
//位于Summer.scala文件中
import ChecksumAccumulator.calculate

object Summer {
    def main(args: Array[String]) = {
        for (arg <- args)
            println(arg + ": " + calculate(arg))
    }
}
```
示例中，单例对象的名称是Summer。它的main方法带有正确的签名，因此可以将它当作应用程序来使用。文
件中的 **第一条语句引入** 了前一例的ChecksumAccumulator对象中定义的 **calculate方法**。这
句引入让你可以 **在这个文件后续的代码中使用这个方法的简单名称**。
```
提示：

如果你是Java程序员，可以把这句引入语句当作是Java5的静态引入（static import）功能。Scala跟Java静态引入的区别在于可
以从任何对象引入成员，而不仅仅是从单例对象。
```
```
注意：

Scala在每一个Scala源码文件都隐式地引入了java.lang和scala包的成员，以及名为Predef的单例对象的所有成员。位于scala包
的Predef包含了很多有用的方法。比如，当你在Scala源码中使用println时，实际上调用了Predef的println（Predef.println　
转而调用Console.println，执行具体的操作）。而当你写下assert时，实际上是调用了Predef.assert。
```
要运行Summer这个应用程序，可以把上例中的代码放入名为Summer.scala的文件中。因为Summer也用到
ChecksumAccumulator，将上篇中的两个示例（伴生对象与伴生类）放入名为ChecksumAccumulator.scala　
的文件中。

Scala和Java的区别之一，**是Java要求你将公共的类放入跟类同名的文件中**（例如需要将SpeedRacer.java中），
**而在Scala中可以任意命名.scala文件，不论你放什么类或代码到这个文件中**。不过，**通常对于那些非
脚本的场景，把类放入以类名命名的文件是推荐的做法**，就像Java那样，以便程序员能够更容易地根据类名定
位到对应的文件。　

**ChecksumAccumulator.scala和Summer.scala都不是脚本，因为它们都是以定义结尾的。而脚本则不同，
必须以一个可以计算出结果的表达式结尾。因此，如果你尝试以脚本的方式运行Summer.scala，解释器会报错**。




































dd
