类、字段和方法
================================================================================
**类是对象的蓝本**。一旦你定义好一个类，就可以用 **new关键字** 从这个类蓝本创建对象。例如，有了
下面这个类定义：
```scala
class ChecksumAccumulator {
    //这里是类定义
}
```
就可以用如下代码创建ChecksumAccumulator的对象：
```scala
new ChecksumAccumulator
```
在类定义中，你会填入 **字段（field）** 和 **方法（method）**，这些被统称为 **成员（member）**。
通过 **val** 或 **var** 定义的 **字段** 是指向对象的 **变量**，通过 **def** 定义的 **方法**
则包含了可执行的代码。

例如，如果你定义了一个ChecksumAccumulator类并给它一个名为sum的var字段：
```scala
class ChecksumAccumulator {
    var sum = 0
}
```
然后用如下代码实例化两次：
```scala
val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator
```
那么内存中这两个对象看上去可能是这个样子的：

![图1](img/1.png)

由于sum这个定义在ChecksumAccumulator类中的字段是 **var**，而不是val，可以在后续代码中对其重
新赋予不同的Int值。如：
```scala
acc.sum = 3
```
如此一来内存中的对象看上去就如同：

![图2](img/2.png)

关于这张图需要注意的一点是总共有两个sum变量，一个位于acc指向的对象里，而另一个位于csa指向的对象
里。字段又叫作 **实例变量**（instance variable），**因为每个实例都有自己的变量**。这些实例变
量合在一起，构成了对象在内存中的映像，另一个并不会受到影响。

本例中另一个值得注意的昌 **可以修改acc指向的对象**。尽管acc本身是val，由于acc和csa都是val而不
是var，**你不能做的是将它们重新赋值指向别的对象**。例如，如下代码会报错：
```scala
//不能编译，因为acc是一个val
acc = new ChecksumAccumulator
```
因此，你能够确信的是，**acc永远指向那个你在初始化的时候用的ChecksumAccumulator对象**，但随着
时间推移 **这个对象中包含的字段是有可能改变的**。

追求健壮性的一个重要手段是确保对象的状态（它的实例变量的值）在其整个生命周期都是有效的。**首先是通
过将字段标记为私有（private）来防止外部直接访问字段**。因为私有字段只能被定义在同一个类中的方法访
问，所有对状态的更新操作的代码，都在类的内部。**要将某个字段声明为私有，可以在字段前加上private这
个访问修饰符**，如：
```scala
class ChecksumAccumulator {
    private var sum = 0
}
```
有了ChecksumAccumulator的定义，任何试图通过外部访问sum的操作都会失败：
```scala
val acc = new ChecksumAccumulator
acc.sum = 5   //不能编译，因为sum是私有的
```
```
注意：

在Scala中，使得成员允许公共访问（public）的方式是不在成员前面显式地给出任何访问修饰符。换句话说，对于那些在Java中可能会
用“public”的地方，到了Scala中，什么都不用就对了。公共访问是Scala的默认访问级别。
```







































sss
