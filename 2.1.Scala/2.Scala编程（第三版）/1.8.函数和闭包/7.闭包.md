闭包
================================================================================
本章到目前为止，所有的函数字面量示例，都只是引用了传入的参数。例如，在`(x: Int) => x > 0`中，
唯一在函数体`x > 0`中用到的变量是`x`，即这个函数的唯一参数。不过，**也可以引用其他地方定义的变
量**：
```scala
(x: Int) => x + more             
```
这个函数将“more“也作为入参，不过more是哪里来的？从这个函数的角度来看，**more是一个自由变量**，
因为函数字面量本身并没有给more赋予任何含义。相反，x是一个绑定变量，因为它在该函数的上下文里有明
确的含义：它被定义为该函数的唯一参数，一个Int。如果单独使用这个函数字面量，而并没有在任何处于作用
域内的地方定义more。编译器将报歉:
```scala
val fun = (x: Int) => x + more
```
```
Error:(1, 35) not found: value more
val fun = (x: Int) => x + more
```
只要能找到名为more的变量，同样的函数字面量就能正常工作：
```scala
var more = 1
val addMore = (x: Int) => x + more
addMore(10)
```
**运行时从这个函数字面量创建出来的函数值（对象）被称作闭包。该名称源于“捕获”其自由变量从而“闭合”
该函数字面量的动作**。没有自由变量的函数字面量，比如`(x: Int) => x + 1`，称为 **闭合语**，这
里的语指的是一段源代码。
