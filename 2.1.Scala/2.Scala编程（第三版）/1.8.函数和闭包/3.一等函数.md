一等函数
================================================================================
**Scala支持一等函数**。不仅可以定义函数并调用它们，还可以 **用匿名的字面量来编写函数** 并将它
们 **作为值进行传递**。

**函数字面量被编译成类，并在运行时实例化成函数值。因此，函数字面量和函数值的区别在于，函数字面量
存在于源码，而函数值以对象形式存在于运行时。这跟类（源码）与对象（运行时）的区别很相似**。
```
每个函数值都是某个扩展自scala包的FunctionN系列当中的一个特质的类的实例。比如Function0表示不带参数的函数，Function1
表示带一个参数的函数，等等。每一个FunctionN特质都有一个apply方法用来调用该函数。
```
以下是一个对某个数加1的函数字面量的简单示例：
```scala
(x: Int) => x + 1
```
`=>`表示该函数将左侧的内容（任何整数`x`）转换成右侧的内容`(x + 1)`。因此，这是一个将任何整数
`x`映射成`x + 1`的函数。

**函数值是对象，所以可以将它们存放在变量中。它们同时也是函数，所以也可以用常规的圆括号来调用它们**。
以下是对这两种操作的示例：
```scala
scala> var increase = (x: Int) => x + 1
increase: Int => Int = $$Lambda$4291/1815318438@71bb1371

scala> increase(10)
res0: Int = 11
```
由于本例中的`increase`是var，可以稍后将它赋值成其他函数值：
```scala
scala> increase = (x: Int) => x + 9999
increase: Int => Int = $$Lambda$4438/1350202930@554be9c3

scala> increase(10)
res1: Int = 10009
```
**如果你想要在函数字面量中包含多于1条语句，可以将函数体用花括号括起来，每条语句占一行，组成一个
代码块（block）。跟方法一样，当函数值被调用时，所有的语句都会被执行，并且该函数的返回值就是对最
后一个表达式求值的结果**。
```scala
val increase = (x: Int) ⇒ {
    println("We")
    println("are")
    println("here!")
    x + 1
}

increase(10)
```
```
increase: Int => Int = <function>


We
are
here!
res0: Int = 11
```
现在你已经看到了函数字面量和函数值的细节和用法。很多Scala类库都让你有机会使用它们。例如，所有的
集合类都提供了`foreach`方法。它接收一个函数作为入参，并对它的每个元素调用这个函数。如下是使用该
方法打印列表中所有元素的例子：
```scala
val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers.foreach((x: Int) ⇒ println(x))
```
```
-11
-10
-5
0
5
10
```
```
说明

foreach方法定义在Traversable特质里，这是List、Set、Array和Map的通用超特质，详情看17章。
```
