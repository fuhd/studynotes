第11步：识别函数式编程风格
================================================================================
Scala允许采用指令式编程，**但鼓励采用函数式编程风格**。如果你之前的编程背景是指令式的（比方说你是
个Java程序员）那么当你学习Scala时的一个主要挑战是搞明白如何使用函数式风格编程。

首先是从代码层而识别出两种风格的差异。一个显著的标志是 **如果代码包含任何var变量，它通常是指令式风
格的；而如果代码完全没有var（也就是说代码只包含val），那么它很可能是函数式的**。因此，一个向函数式
风格转变的方向是 **尽可能不用var**。

在Scala看来，val和var不过是你的工具箱中两种不同的工具，都有相应的用途，**没有哪一个本质上是邪恶的。
Scala鼓励你更偏向于使用val，但最终要根据手里的工作选择最适用的工具**。

如下这个`while`循环的例子，使用`var`因此是指令式风格的：
```scala
def printArgs(args: Array[String]): Unit = {
    var i = 0
    while(i < args.length) {
        println(args(i))
        i += 1
    }
}
```
这段代码 **转换成函数式风格，去掉var**，就像这样：
```scala
def printArgs(args: Array[String]): Unit = {
    for(arg <- args)
        println(arg)
}
```
或者这样：
```scala
def printArgs(args: Array[String]): Unit = {
    args.foreach(println)
}
```
这个例子展示了编程中使用更少的var的好处。经过重构的（更函数式的）代码，跟原始的（更指令式的）代码
相比，更清晰、更精简，也更少出错。

不过你可以走得更远。**重构后的printArgs方法并不是“纯”的函数式代码，因为它有副作用（本例中的副作用
是向标准输出流打印）。带有副作用的函数的标志性特征是结果类型为Unit。如果一个函数并不返回任何有意义
的值，也就是Unit这样的结果类型所表达的意思，那么这个函数存在于世上唯一的意义就是产生某种副作用**。
函数式编程的做法是定义一个将传入的args格式化（用于打印）的方法，但只是返回这个格式化的字符串，示例：
```scala
def formatArgs(args: Array[String]) = args.mkString("\n")
```
现在你真的实现了函数式编程：**没有副作用，也没有var**。mkString方法可以被用于任何可被迭代访问的集
合（包括数组、列表、集和映射），返回一个包含了对所有元素调用toString的结果的字符串，以传入的字符串
分隔。当然，这个函数实际上并不像printArgs那样打印出任何东西，但是可以很容易地将它的结果传给println
来达到这个目的：
```scala
println(formatArgs(args))
```
**每个有用的程序都会有某种形式的副作用。否则，它对于外部世界就没有任何价值**。倾向于使用无副作用的函
数鼓励你设计出将带有副作用的代码最小化的程序。这样做的好处之一是 **让你的程序更容易测试**。

例如，要测试本节给出的三个printArgs方法，需要重新定义println，捕获传给println的输出，确保它是你
预期的样子。而要测试formatArgs则很简单，只需要检查它的结果即可：
```scala
val res = formatArgs(Array("zero", "one", "two"))
assert(res == "zero\none\ntwo")
```
**Scala的assert方法检查传入的Boolean，如果是false，则抛出AssertionError。如果传入的Boolean是
true，assert就安静地返回**。

**尽管如此，请记住var或副作用从本质上讲并不邪恶。Scala并不是一门纯函数式编程语言，强制你只能用函数式
风格来编程。Scala是指令式/函数式混合编程语言。你会发现有些场景下对于要解决的问题而言指令式更为适合，
这个时候不要犹豫，使用指令式的风格就好**。
```
Scala程序员的平衡心态

倾向于使用val、不可变对象和没有副作用的方法，优先选择它们。不过当你有特定的需要和理由时，也不要拒绝var，可变对象和
带有副作用的方法。
```
