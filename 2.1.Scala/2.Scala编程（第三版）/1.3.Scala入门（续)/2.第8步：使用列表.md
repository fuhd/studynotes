第8步：使用列表
================================================================================
**函数式编程的重要理念之一是方法不能有副作用**。一个方法唯一要做的是计算并返回一个值。这样做的好
处是方法不再互相纠缠在一起。因此变得更可靠、更易复用。另一个好处（作为静态类型的编程语言）是类型
检查器会检查方法的入参和出参，因此逻辑错误通常都是以类型错误的形式出现。**将这个函数式的哲学应用
到对象的世界意味着让对象不可变**。

Scala **数组** 是一个拥有 **相同类型** 的对象的 **可变序列**。虽然无法在数组实例化以后改变其长
度，却可以改变它的元素值。因此，**数组是可变的对象**。

对于需要拥有相同类型的对象的 **不可变序列** 的场景。可以使用Scala的 **List** 类。跟数组类似，
一个List[String]只能包含字符串。Scala的List（即Scala.List）跟Java的java.util.List的不同
在于 **Scala的List是不可变的，而Java的List是可变的**。更笼统地说，**Scala的List被设计为允许
函数式风格的编程**。创建列表的方法很简单，如下示例：
```scala
val oneTwoThree = List(1,2,3)
```
由于List是不可变的，它们的行为有点类似于Java的字符串：当你调用列表的某个方法，而这个方法的名字看
上去像是会改变列表的时候，**它实际上是创建并返回一个带有新值的新列表**。例如，List有个方法叫
（“**:::**”），用于 **列表拼接**。用法如下：
```scala
val oneTwo = List(1,2)
val threeFour = List(3,4)
val oneTwoThreeFour = oneTwo ::: threeFour
println(oneTwo + " and " + threeFour + " were not mutated.")
println("Thus, " + oneTwoThreeFour + " is a new List.")
```
执行这段脚本，你将看到：
```
List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new List.
```
也许列表上用得最多的操作是“**::**”，读作“**cons**”。**它在一个已有列表的最前面添加一个新的元素，
并返回这个新的列表**。例如，如果执行下面这段脚本：
```scala
val twoThree = List(2,3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)
```
将会看到：
```
List(1, 2, 3)
```
注意：在表达式“1 :: twoThree”中，“**::**”是 **右操作元的方法**（即：twoThree这个列表）。你可
能会觉得::方法的结合性有些奇怪，实际上背后的规则很简单：**如果一个方法被用在操作符表示法当中时**，
比如a ＊ b，**方法调用默认都发生在左操作元，除非方法名以冒号（:）结尾。如果方法名的最后一个字符是
冒号，该方法的调用会姓在它的右操作元上**。因此，在 1 :: twoThree 中，::方法调用发生在twoThree上，
传入的参数是1，就像这样： **twoThree.::(1)**。














































ddd
