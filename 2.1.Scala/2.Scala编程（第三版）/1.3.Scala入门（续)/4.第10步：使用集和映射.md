第10步：使用集和映射
================================================================================
由于Scala想让你同时享有 **函数式** 和 **指令式** 编程风格优势，**其集合类库特意对可变和不可变的
集合进行了区分**。举例来说， **数组** 永远是 **可变** 的，**列表** 永远是 **不可变** 的。Scala
同时还提供了 **集（set）** 和 **映射（map）** 的 **可变** 和 **不可变** 的不同选择，但使用同样
的简单名字。**对于集和映射而言，Scala通过不同的类继承关系来区分可变和不可变版本**。

例如，Scala的API包含了一个基础的 **特质（`trait`）** 来表示集，这里的 **特质跟Java的接口定义类
似**（将在第12章了解到更多关于特质的内容）。**在此基础上，Scala提供了两个子特质（subtrait），
一个用于表示可变集，另一个用于表示不可变集**。

![Scala集的类继承关系](img/1.jpeg)

从上图中可以看到，这 **三个特质都叫作Set**。不过它们的 **完整名称并不相同**，因为它们分别位于不同
的包。Scala API中具体用于表示集的类，**上图中的HashSet类，分别扩展自可变或不可变的特质Set**。
（在Java中“实现”某个接口，而在Scala中“扩展”或者“**混入**”特质）。因此，如果想要使用一个HashSet，
可以根据需要选择可变或不可变的版本。**创建集的默认方式** 如下示例：
```scala
var jetSet = Set("Boeing", "Airbus")
jetSet += "Lear"
println(jetSet.contains("Cessna"))
```
示例中的第一行，定义了一个新的名为jetSet的 **var**，将其初始化成一个包含两个字符串的 **不可变集**。
如这段代码所示，在Scala中可以像创建列表和数组那样创建集：**通过调用Set伴生对象的名为apply的工厂方
法**。







































dd
