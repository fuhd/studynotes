模式的种类
===================================================================================
## 1. 通配模式
**通配模式（`_`）会匹配任何对象**。前面已经看到过 **通配模式用于缺省，捕获所有的可选路径**，就像这
样：
```scala
expr match {
  case BinOp(op, left, right) ⇒ println(expr + " is a binary operation")
  case _ ⇒      //处理默认case
}
```
**通配模式还可以用来忽略某个对象中你并不关心的局部**。例如，前面这个例子实际上并不需要关心二元操作
的操作元是什么，它只是检查这个表达式 **是否是二元操作**，仅此而已。因此，这段代码也完全可以用通配模
式来表示BinOp的操作元，示例如下：
```scala
expr match {
  case BinOp(_, _, _) ⇒ println(expr + " is a binary operation")
  case _ ⇒ println("It's something else")
}
```

## 2. 常量模式
**常量模式仅匹配自己，任何字面量都可以作为常量（模式）使用**。例如，**5、true和“hello”都是常量模
式**。同时，**任何val或单例对象也可以被当作常量（模式）使用**。例如，Nil这个单例对象能且仅能匹配空
列表。下面给出了常量模式的例子：
```scala
def describe(x: Any) = x match {
  case 5 ⇒ "five"
  case true ⇒ "truth"
  case "hello" ⇒ "hi!"
  case Nil ⇒ "the empty list"
  case _ ⇒ "something else"
}
```

## 3. 变量模式
**变量模式匹配任何对象，这一点跟通配模式相同。不过不同于通配模式的是，Scala将对应的变量绑定成匹配
上的对象。在绑定之后，你就可以用这个变量来对对象做进一步的处理**。下面的示例给出了一个针对零的特例
和针对所有其他值的缺省处理的模式匹配。**缺省的case用到了变量模式**，这样就给匹配的值赋予了一个名称，
不论这个值是啥。
```scala
expr match {
  case 0 ⇒ "zero"
  case somethingElse ⇒ "not zero: " + somethingElse
}
```
**变量还是常量？**

**常量模式也可以有符号形式的名称**。当我们把`Nil`当作一个模式的时候，实际上就是在用一个符号名称来引
用常量。这里有一个相关的例子，这个模式匹配牵扯到常量 **E**(2.781828...)和 **Pi**(3.14159...)：
```scala
scala> import math.{E, Pi}
import math.{E, Pi}

scala> E match {
  case Pi ⇒ "strange math? Pi= " + Pi
  case _ ⇒ "OK"
}
res0: String = OK
```



