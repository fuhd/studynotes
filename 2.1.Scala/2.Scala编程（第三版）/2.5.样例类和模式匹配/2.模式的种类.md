模式的种类
===================================================================================
## 1. 通配模式
**通配模式（`_`）会匹配任何对象**。前面已经看到过 **通配模式用于缺省，捕获所有的可选路径**，就像这
样：
```scala
expr match {
  case BinOp(op, left, right) ⇒ println(expr + " is a binary operation")
  case _ ⇒      //处理默认case
}
```
**通配模式还可以用来忽略某个对象中你并不关心的局部**。例如，前面这个例子实际上并不需要关心二元操作
的操作元是什么，它只是检查这个表达式 **是否是二元操作**，仅此而已。因此，这段代码也完全可以用通配模
式来表示BinOp的操作元，示例如下：
```scala
expr match {
  case BinOp(_, _, _) ⇒ println(expr + " is a binary operation")
  case _ ⇒ println("It's something else")
}
```

## 2. 常量模式
**常量模式仅匹配自己，任何字面量都可以作为常量（模式）使用**。例如，**5、true和“hello”都是常量模
式**。同时，**任何val或单例对象也可以被当作常量（模式）使用**。例如，Nil这个单例对象能且仅能匹配空
列表。下面给出了常量模式的例子：
```scala
def describe(x: Any) = x match {
  case 5 ⇒ "five"
  case true ⇒ "truth"
  case "hello" ⇒ "hi!"
  case Nil ⇒ "the empty list"
  case _ ⇒ "something else"
}
```

## 3. 变量模式
**变量模式匹配任何对象，这一点跟通配模式相同。不过不同于通配模式的是，Scala将对应的变量绑定成匹配
上的对象。在绑定之后，你就可以用这个变量来对对象做进一步的处理**。下面的示例给出了一个针对零的特例
和针对所有其他值的缺省处理的模式匹配。**缺省的case用到了变量模式**，这样就给匹配的值赋予了一个名称，
不论这个值是啥。
```scala
expr match {
  case 0 ⇒ "zero"
  case somethingElse ⇒ "not zero: " + somethingElse
}
```
**变量还是常量？**

**常量模式也可以有符号形式的名称**。当我们把`Nil`当作一个模式的时候，实际上就是在用一个符号名称来引
用常量。这里有一个相关的例子，这个模式匹配牵扯到常量 **E**(2.781828...)和 **Pi**(3.14159...)：
```scala
scala> import math.{E, Pi}
import math.{E, Pi}

scala> E match {
  case Pi ⇒ "strange math? Pi= " + Pi
  case _ ⇒ "OK"
}
res0: String = OK
```
Scala编译器是如何知道Pi是从`scala.math`包引入的常量，而不是一个代表选择器值本身的变量呢？**Scala采
用了一个简单的词法规则来区分：一个以小定字母打头的简单名称会被当作模式变量处理；所有其他引用都是常
量**。想看到具体的区别？可以给Pi创建一个小写的别名，然后尝试如下代码：
```scala
scala> al pi = math.Pi
pi: Double = 3.141592653589793

scala> E match {
  case pi ⇒ "strange math? Pi = " + pi
}
res1: String = strange math? Pi = 2.718281828459045
```
**在这里编译器不允许我们添加一个默认的case。由于pi是变量模式，它将会匹配所有输入，因此不可能走到后
面的case**：
```scala
scala> E match {
  case pi ⇒ "strange math? Pi = " + pi
  case _ ⇒ "OK"
}

case pi ⇒ "strange math? Pi = " + pi //1
^
On line 2: warning: patterns after a variable pattern cannot match (SLS 8.1.1)
case _ ⇒ "OK" //2
```
**如果需要，仍然可以用小写的名称来作为模式常量**，有两个小技巧。**首先，如果常量是某个对象的字段，
可以在字段名前加上限定词**。例如，虽然pi是个变量模式，**但`this.pi`或`obj.pi`是常量（模式），尽管它
们以小写字母打头**。如果这样不行（比如说pi可能是个局部变量）,**也可以用反引号将这个名称包起来**。例
如`｀pi｀`就能再次被编译器解读为一个常量，而不是变量了：
```scala
E match {
  case `pi` ⇒ "strange math? Pi = " + pi
  case _ ⇒ "OK"
}
```
你应该看到了，**给标识符加上反引号在Scala中有两种用途**，来帮助你从不寻常的代码场景中走出来。这里
你看到的是 **如何将小写字母打头的标识符用作模式匹配中的常量**。在6.10节，你还看到过反引号可以用来
**将关键字当作普通的标识符**，比如：`Thread.｀yield｀()`这段代码将yield当作标识符而不是关键字。

## 4. 构造方式模式








