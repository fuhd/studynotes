一个复杂的例子
===================================================================================
在学习了模式的不同形式之后，你可能会对它们 **在相对复杂的例子中是如何应用的** 感兴趣。提议的任务是
**编写一个表达式格式化类**，以二维布局来显示一个算术表达式。诸如“`x / (x + 1)`”的除法应该 **纵向打印**，
将被除数放在除数上面，就像这样：
```
x
-----
x + 1
```
从这个示例来看，要定义的这个类（我们就叫它`ExprFormatter`吧）需要做大量的布局安排，因此我们有理由
使用 **第10章开发的布局类库**。我们还会用到本章前面讲到的 **Expr这组样例类**，并将第10章的布局类库
和本章的表达式格式化工具放在对应名称的包里。

**第一步，我们先集中精力做好横向布局**。比如对于下面这个结构化的表达式：
```scala
BinOp("+",
  BinOp("*",
    BinOp("+", Var("x"), Var("y")),
    Var("z")),
  Number(1))
```
应该打印出：`(x + y) * z + 1`。**注意包在`x + y`外围的这组圆括号是必需的**，但`(x + y) * z`外围则不是必
需的。为了保持布局尽可能清晰易读，我们的 **目标是去掉冗余的圆括号，同时确保所有必要的圆括号继续保留**。

为了知道哪里该放置圆括号，我们的代码 **需要知晓操作符的优先级**，我们先把这件事搞定吧。可以用下面这
样的 **映射字面量来直接表示优先级**：
```scala
Map("|" → 0, "||" → 0,
    "&" → 1, "&&" → 1, ...)
```
不过，这需要我们自己来事先做一些运算。更方便的做法是 **按照递增的优先级定义多组操作符，然后再从中计
算每个操作符的优先级**。具体代码如下：
```scala
package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem

sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr

class ExprFormatter {
  //包含优先级递增的操作符分组
  private val opGroups =
    Array(
      Set("|", "||"),
      Set("&", "&&"),
      Set("^"),
      Set("==", "!="),
      Set("<", "<=", ">", ">="),
      Set("+", "-"),
      Set("*", "%")
    )

  //从操作符到对应优先级的映射关系
  private val precedence = {
    val assocs =
      for{
        i ← 0 until opGroups.length
        op ← opGroups(i)
      } yield op → i
    assocs.toMap
  }

  private val unaryPrecedence = opGroups.length
  private val fractionPrecedence = -1
  //未完待续......
}
```

