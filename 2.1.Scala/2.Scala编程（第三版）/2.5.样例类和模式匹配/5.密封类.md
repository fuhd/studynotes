密封类
===================================================================================
**每当我们编写一个模式匹配时，都需要确保完整地覆盖了所有可能的case。有时候可以通过在末尾添加一个缺
省case来做到，不过这仅限于有合理兜底的场合**。如果没有这样的缺省行为，我们如何确信自己覆盖了所有的
场景呢？

我们可以 **寻求Scala编译器的帮助，帮我们检测出match表达式中缺失的模式组合**。为了做到这一点，编译
器需要分辨出可有的case有哪些。**一般来说，在Scala中这是不可能的，因为新的样例类随时随地都能被定义出
来**。例如没有人会阻止你在现在的四个样例类所在的编译单元之外的另一个编译单元中给Expr的类继承关系添
加第五个样例类。

**解决这个问题的手段是将这些样例类的超类标记为密封（`sealed`）的。密封类除了在同一个文件中定义的子
类之外，不能添加新的子类**。这一点对于模式匹配而言十分有用，**因为这样一来我们就只需要关心那些已知
的样例类。不仅如此，我们还因此获得了更好的编译器支持。如果我们对继承自密封类的样例类做匹配，编译器
会用警告消息标示出缺失的模式组合**。

