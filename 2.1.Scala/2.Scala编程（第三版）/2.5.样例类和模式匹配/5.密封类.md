密封类
===================================================================================
**每当我们编写一个模式匹配时，都需要确保完整地覆盖了所有可能的case。有时候可以通过在末尾添加一个缺
省case来做到，不过这仅限于有合理兜底的场合**。如果没有这样的缺省行为，我们如何确信自己覆盖了所有的
场景呢？

我们可以 **寻求Scala编译器的帮助，帮我们检测出match表达式中缺失的模式组合**。为了做到这一点，编译
器需要分辨出可有的case有哪些。**一般来说，在Scala中这是不可能的，因为新的样例类随时随地都能被定义出
来**。例如没有人会阻止你在现在的四个样例类所在的编译单元之外的另一个编译单元中给Expr的类继承关系添
加第五个样例类。

**解决这个问题的手段是将这些样例类的超类标记为密封（`sealed`）的。密封类除了在同一个文件中定义的子
类之外，不能添加新的子类**。这一点对于模式匹配而言十分有用，**因为这样一来我们就只需要关心那些已知
的样例类。不仅如此，我们还因此获得了更好的编译器支持。如果我们对继承自密封类的样例类做匹配，编译器
会用警告消息标示出缺失的模式组合**。

**如果你的类打算被用于模式匹配，那么你应该考虑将它们做成密封类。只需要在类继承关系的顶部那个类的类
名前面加上sealed关键字**。这样，使用你的这组类的程序员在模式匹配你的这些类时，就会信心十足。**这也
是为什么sealed关键字通常被看作模式匹配的执照的原因**。下面示例给出了Expr被转成密封类的例子：
```scala
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
```
现在我们可以试着 **定义一个漏掉了某些可能case的模式匹配**：
```scala
def describe(e: Expr): String = e match {
  case Number(_) ⇒ "a number"
  case Var(_) ⇒ "a variable"
}
```
我们将得到类似下面这样的 **编译器警报**：
```
warning: match may not be exhaustive.
It would fail on the following inputs: BinOp(_, _, _), UnOp(_, _)
describe: (e: Expr)String
```