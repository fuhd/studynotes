到处都是模式
===================================================================================
**Scala中很多地方都允许使用模式，并不仅仅是match表达式**。我们来看看其他能用模式的地方。

## 1. 变量定义中的模式
**每当我们定义一个val或var，都可以用模式而不是简单的标识符**。例如，**可以将一个元组解开并将其中的
每个元素分别赋值给不同的变量**，示例如下：
```scala
scala> val myTuple = (123, "abc")
myTuple: (Int, String) = (123,abc)

scala> val (number, str) = myTuple
number: Int = 123
str: String = abc
```
**这个语法结构在处理样例类时非常有用。如果你知道要处理的样例类是什么，就可以用一个模式来析构它**。
参考下面的例子：
```scala
scala> val exp = new BinOp("*", Number(5), Number(1))
exp: BinOp = BinOp(*,Number(5.0),Number(1.0))

scala> val BinOp(op, left, right) = exp
op: String = *
left: Expr = Number(5.0)
right: Expr = Number(1.0)
```

## 2. 作为偏函数的case序列
**用花括号包起来的一系列case（即可选分支）可以用在任何允许出现函数字面量的地方**。本质上讲，**case
序列就是一个函数字面量，只是更加通用。不像普通函数那样只有一个入口和参数列表，case序列可以有多个入
口，每个入口都有自己的参数列表。每个case对应该函数的一个入口，而该入口的参数列表用模式来指定。每个
入口的逻辑主体是case右边的部分**。

下面是一个简单的例子：
```scala
val withDefault: Option[Int] ⇒ Int = {
  case Some(x) ⇒ x
  case None ⇒ 0
}
```
该函数的函数体有两个case。第一个case匹配Some，返回Some中的值。第二个case匹配None，返回默认值0。
以下是这个函数用起来的效果：
```scala
scala> withDefault(Some(10))
res0: Int = 10

scala> withDefault(None)
res1: Int = 0
```
**这套机制对于Akka这个actor类库而言十分有用，因为有了它，Akka可以用一组case来定义它的receive方
法**：
```scala

```


