序列
===================================================================================
**序列类型可以用来处理依次排列分组的数据**。由于元素是 **有次序的**，可以向序列获取第1个元素、第2个
元素、第103个元素，等等。

## 列表
也许我们需要知道的 **最重要的序列类型是List类**，也就是我们在前一章介绍的 **不可变链表**。列表支持在
头部快速添加和移除条目，**不过并不提供快速的按下标访问的功能**，因为实现这个功能需要线性地遍历列表。

这样的特征组合听上去可能有些怪，但其实对于很多算法而言都非常适合。快速的头部添加和移除意味着模式匹
配很顺畅。而列表的不可变性质帮助我们开发正确、高效的算法，因为我们不需要（为了防止意外）复制列表。

以下是一个简短的例子，展示如何 **初始化列表，并访问其头部和尾部**：
```scala
scala> val colors = List("red", "blue", "green")
colors: List[String] = List(red, blue, green)

scala> colors.head 
res0: String = red

scala> colors.tail 
res1: List[String] = List(blue, green)
```

## 数组
数组允许我们保存一个序列的元素，**并使用从零开始的下标** 高效地访问（获取或更新）指定位置的元素值。
以下是如何创建一个我们已知大小但还不知道元素值的数组：
```scala
scala> val fiveInts = new Array[Int](5)
fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)
```
以下是如何初始化一个我们已知元素值的数组：
```scala
scala> val fiveToOne = Array(5, 4, 3, 2, 1)
fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)
```
我们前面提到过，**在Scala中以下标访问数组的方式是把下标放在圆括号里**。下面的例子同时展示了获取数
组元素和更新数组元素的写法：
```scala
scala> fiveInts(0) = fiveToOne(4)
scala> fiveInts
res1: Array[Int] = Array(1, 0, 0, 0, 0)
```
Scala数组的表现形式跟Java数组一致。

## 列表缓冲（list buffer）
**List类提供对列表头部的快速访问，对尾部访问则没那么高效**。因此，当我们需要往列表尾部追加元素来构
建列表时，通常要考虑反过来往头部追加元素，追加完成以后，再调用`reverse`来获得我们想要的顺序。

另一种避免`reverse`操作的可选方案是使用`ListBuffer`。**`ListBuffer`是一个可变对象**（包含在
`scala.collection.mutable`包中），**帮助我们在需要追加元素来构建列表时可以更高效。`ListBuffer`提供了
常量时间的往后追加和往前追加的操作。我们可以用`+=`操作符来往后追加元素，用`+=:`来往前追加元素。完
成构建以后，我们可以调用`ListBuffer`的`toList`来获取最终的`List`**。参考下面的例子：
```scala
scala> import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer

scala> val buf = new ListBuffer[Int];
buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()

scala> buf += 1
res0: buf.type = ListBuffer(1)

scala> buf += 2
res1: buf.type = ListBuffer(1, 2)

scala> buf 
res2: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)

scala> 3 +=: buf
res3: buf.type = ListBuffer(3, 1, 2)

scala> buf.toList
res4: List[Int] = List(3, 1, 2)
```
**使用`ListBuffer`而不是`List`的另一个原因是防止可能出现的栈溢出。如果我们可以通过往前追加来构建出
预期顺序的列表，但需要的递归算法并不是尾递归的，可以用`for`表达式或者`while`循环加上`ListBuffer`来
实现**。

## 数组缓冲
**`ArrayBuffer`跟数组很像，除了可以额外地从序列头部或尾部添加或移除元素。所有的`Array`操作在
`ArrayBuffer`都可用，不过由于实现的包装，会稍慢一些。新的添加和移除操作平均而言是常量时间的，不过偶
尔会需要线性的时间，这是因为其实现需要不时地分配新的数组来保存缓冲的内容**。












