一门按需伸缩的语言
================================================================================
Scala这个名字来源于“**scalable language**”，即“**可伸缩的语言**”。它运行在标准的Java平台上，
可以与所有Java类库无缝协作。Scala是一门综合了 **面向对象** 和 **函数式编程** 概念的 **静态类型**
的编程语言。通过这两种编程风格的结合，Scala让我们能够表达出各种新式的编程模式和组件抽象。

示例程序：
```scala
var capital = Map("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
```
这段代码看上去感觉像是一款现代的“脚本”语言，比如Perl、Python。这些语言的一个共通点，至少就从上面的
示例而言，是它们各自都在语法层面支持某种“关联映射”（associative map）的结构。

关联映射非常有用，因为它们让程序精简可靠，**不过有时你可能不同意这种“一体适用”哲学，因为你需要在你的程序
中更为精细地控制映射结构的性质。Scala给你这种自由度，因为映射在Scala里并不是语言本身的语法，它们是通
过类库实现的一种抽象，可以按需进行扩展和适配**。

在上面这段程序中，得到的是默认的Map实现，不过改起来也很容易。比如说，可以指定一个特定的实现，如HashMap
或TreeMap，也可以通过调用par方法得到一个并行执行操作的ParMap。可以指定映射中的默认值，也可以在创建的
映射中重写任何方法。

### 培育新类型
**Scala更像是市集而不是大教堂，其主要的设计目标就是让用Scala编程的人们可以对它进行扩展和定制**。示例，
计算传入整数值的阶乘：
```scala
def factorial(x: BigInt): BigInt = if(x == 0) 1 else x * factorial(x - 1)
//调用
factorial(30)
```
**BigInt看上去像是内建的，因为可以使用整形字面量，并且对这个类型的值做＊和－等操作符运算。但实际上它不过碰
巧是Scala标准类库里定义的一个类而已。就算没有提供这个类，Scala程序员也可以直接（比如对java.math.BigInteger
做一下包装）实现。实际上Scala的BigInt就是这么做的**。






































dd
