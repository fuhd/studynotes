是什么让Scala能屈能伸
================================================================================
语言的伸缩性取决于很多因素，从语法细节到组件抽象都有。找个能屈能伸的例子，**对面向对象和函数式编程
的结合**。跟其他混合面向对象和函数式编程的语言相比，Scala走得更远。举例来说，其他语言可能会区分对
象和函数，将它们定义为不同的两个概念，**但在Scala中，函数值就是对象，而函数的类型是可被子类集成的
类**。如果没有对函数和对象的统一抽象，之前我们讲的actor就不可能（如此优雅地）实现。

### Scala是面向对象的
从原理上讲，面向对象编程的动机非常简单（除了最微不足道的程序之外），**所有程序都需要某种结构**，而
形成这种结构最直接了当的方式就是 **将数据和操作放进某种容器里**。面向对象编程的伟大概念便是让这类容
器变得完全通用，**这样它们既可以包含操作，也可以包含数据，而它们自己也可以以值的形式被存放在某他容器
中，或者作为参数传递给操作。这些容器被称作对象**。Smalltalk的发明人，Alan Kay，认为通过这样的抽象，
最简单的对象也跟完整的计算机一样，有着相同的构造原理：**它将数据和操作结合在一个形式化的接口之下**。
所以说，**对象跟编辑语言的伸缩性之间的关系很大**：同样的技巧既适用于小程序也适用于大程序。

虽然面向对象编辑已经作为主流存在了很长的时间，**相对而言很少有编辑语言跟着Smalltalk的理念，将这个
构思原理推到逻辑的终点。举例来说，许多语言都允许不是对象的值的存在，比如Java的基本类型，又或者允许
不以任何对象的成员形式存在的静态字段和方法。这些对面向对象编程理念的背离在一开始看上去没什么不妥，但
它们倾向于让事情变得复杂，限制了伸缩的可能**。

**Scala则不同，它对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用**。举例来说，如果你说
1＋2，实际上是在调用Int类里定义的名为＋的方法。也可以定义名字像操作符的方法，这样别人就可以用操作符表
示法来使用你的API。Akka的API的设计者就是这么做的，这也是为什么在前面的示例中我们可以使用
requester！sum 这样的表达式：“!”只是Actor类的一个方法而已。

跟其他语言相比，**在组装对象方面，Scala更为高级。Scala的特质（trait）就是个典型的例子**。特质跟
Java的接口很像，**不过特质可以有方法实现甚至是字段**。对象通过 **混入组合（mixin composition）**
构建，**构建的过程是取出某个类的所有成员，然后再加上若干特质的成员**。这样一来，**类的不同维度的功能
特性就可以被封装在不同的特质定义中**。这乍看起来有点像 **多重继承（multiple inheritance）**，细看
则并不相同。不像类，**特质能够对某个未知的超类添加新的功能，这使得特质比类更为“可插拔”（pluggable）**。
尤其是 **特质成功地避开了多重继承中**，当某个子类通过不同的路径继承到 **同一个超类时产生的“钻石继承”
（diamondinheritance）问题**。

### Scala是函数式的
**Scala不只是一门纯的面向对象语言，它也是功能完整的函数式编程语言**。函数式编程的理念，甚至比计算器
还要早。这些理念早在20世纪30年代由Alonzo Church开发的 **lambda演算（lambda calculus）** 中得
以建立。而第一个函数式编程语言 **Lisp** 的历史，可以追溯到20世纪50年代末。其他函数式编程语言还包括：
**Scheme、SML、Erlang、Haskell、Ocaml、F#等** 。很长一段时间，函数式编程都不是主流，在学术界很
受欢迎，但工业界并没有广泛使用。不过，最近几年，大家对函数式编程语言和技巧的兴趣与日俱增。

**函数式编程以两大核心理念为指导。第一个理念是函数是一等（first-class）公民**。在函数式编程语言中，
函数值的地位跟整数、字符串等是相同的。**可以将函数作为参数传递给其他函数，作为返回值返回它们，或者将
它们保存在变量里。还可以在函数中定义另一个函数**，就像在函数中定义整数那样。**也可以在定义函数时不指
定名字**，就像整数字面量42，让函数字面量散落在代码中。

作为一等公民的函数提供了对操作的抽象和创建新的控制结构的便利。**这种函数概念的抽象带来了强大的表现力，
可以让我们写出精简可靠的代码。这一点对于伸缩性也有很大的帮助**。以ScalaTest为例，这个测试类库提供了
eventually（最后）这样的结构体，接收一个函数作为入参（argument）。用法如下：
```scala
val xs = 1 to 3
val it = xs.iterator
eentually {it.next() shouldBe 3}
```
在eventually中的代码————**it.next() shouldBe 3** 这句断言，被包在一个函数里，**该函数并不会直
接执行，而是原样传入eventually方法**。在配置好的时间内，eventually将会反复执行这个函数，直到断言成
功。在大多数传统的编程语言中，函数并不是值。那些把函数当作值的也通常只是二等（second-class）公民。

**函数式编程的第二个核心理念是程序中的操作应该将输入值映射成输出值，而不是当场（in place）修改数据。
不可变数据结构是函数式编程的基石之一。Scala类库在Java API的基础上定义了更多的不可变数据类型**。比如
Scala提供了不可变的列表（list）、元组（tuple）、映射（map）和集（set）等。

**函数式编程的这个核心理念的另一种表述是方法不应该有副作用（side effect）。方法只能通过接收入参和返
回结果这两种方式与外部环境通信**。举例来说，Java的String类的replace方法便符合这个描述：它接收一个
字符串（对象本身）、两个字符，交出一个新的字符串，其中所有出现的入参第一个字符都被替换成了入参的第二个
字符。调用replace并没有其他的作用。像这样的方法被认为是 **“指称透明的”（referential transparent）
（注：也可以翻译为 引用透明），意思是对于任何给定的输入，该方法调用都可以被其结果替换，同时不会影响程序
的语义**。
```
指称透明（或者引用透明）

函数副作用的问题，也称边界问题，降低甚至消灭副作用已经成为我们编程的一个重要原则，不要让一个方法或函数执行主要功能时，会产生
其他意想不到的次要功能，这些额外功能不是我们要求的，称为副作用。更严格地消灭副作用方式是引用透明(referentially
  transparent)，这是面向函数范式FP中的一个术语，也是FP语言如Scala等相比Java特色所在。

“引用透明”（指称透明）这个概念来自于蒯因(Quine)的关于自然语言哲学。看看下面语句：BanQ比老鼠大，如果把"BanQ"去除，留个空白
在那里，显然变成：“??? 比老鼠大”。哲学家认为这是一个Context场景，通过填补场景中的空白，你得到了这个语句真实含义。

再次想一下北京这个城市，它是一个thing，有许多方式可以指称或引用(refer)它，“中国首都”或“在经纬XXX度的城市”。因此，“引用透
明”(referentially transparent)中的“引用referentially”这个词语的含义是在谈论这样一个事实：北京这个事物(thing)有很多
名称，有很多途径来表达指称这个事物。“引用透明”(referentially transparent)中“透明transparent”含义是“没有什么不同”，
“都是一样”。

蒯因认为：如果我们能够用不同的名称替代上面语句中的空白，但是没有改变任何意思，总是得到同样的结果，那么这个场景Context就是“引
用透明”的。
如：
[北京]比老鼠大 是真；
[中国首都]比老鼠大 是真
[在经纬XXX度的城市]比老鼠大 是真
```

函数式编程鼓励不可变数据结构和指称透明的方法。













































ddd
