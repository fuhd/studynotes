是什么让Scala能屈能伸
================================================================================
语言的伸缩性取决于很多因素，从语法细节到组件抽象都有。找个能屈能伸的例子，**对面向对象和函数式编
程的结合**。跟其他混合面向对象和函数式编程的语言相比，Scala走得更远。举例来说，其他语言可能会区
分对象和函数，将它们定义为不同的两个概念，**但在Scala中，函数值就是对象，而函数的类型是可被子类
集成（继承？？）的类**。如果没有对函数和对象的统一抽象，之前我们讲的actor就不可能（如此优雅地）实现。

### Scala是面向对象的
从原理上讲，面向对象编程的动机非常简单（除了最微不足道的程序之外），**所有程序都需要某种结构**，
而形成这种结构最直接了当的方式就是 **将数据和操作放进某种容器里**。面向对象编程的伟大概念便是让
这类容器变得完全通用，**这样它们既可以包含操作，也可以包含数据，而它们自己也可以以值的形式被存放
在某他容器中，或者作为参数传递给操作。这些容器被称作对象**。Smalltalk的发明人，Alan Kay，认为
通过这样的抽象，最简单的对象也跟完整的计算机一样，有着相同的构造原理：**它将数据和操作结合在一个
形式化的接口之下**。所以说，**对象跟编辑语言的伸缩性之间的关系很大**：同样的技巧既适用于小程序也
适用于大程序。
虽然面向对象编辑已经作为主流存在了很长的时间，**相对而言很少有编程语言跟着Smalltalk的理念，将
这个构思原理推到逻辑的终点。举例来说，许多语言都允许不是对象的值的存在，比如Java的基本类型，又或
者允许不以任何对象的成员形式存在的静态字段和方法。这些对面向对象编程理念的背离在一开始看上去没什
么不妥，但它们倾向于让事情变得复杂，限制了伸缩的可能**。

**Scala则不同，它对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用**。举例来说，如果
你说1＋2，实际上是在调用Int类里定义的名为＋的方法。也可以定义名字像操作符的方法，这样别人就可以
用操作符表示法来使用你的API。Akka的API的设计者就是这么做的，这也是为什么在前面的示例中我们可以
使用requester！sum 这样的表达式：“!”只是Actor类的一个方法而已。

跟其他语言相比，**在组装对象方面，Scala更为高级。Scala的特质（trait）就是个典型的例子**。特质
跟Java的接口很像，**不过特质可以有方法实现甚至是字段**。对象通过 **混入组合（mixin composition）**
构建，**构建的过程是取出某个类的所有成员，然后再加上若干特质的成员**。这样一来，**类的不同维度的
功能特性就可以被封装在不同的特质定义中**。这乍看起来有点像 **多重继承（multiple inheritance）**，
细看则并不相同。不像类，**特质能够对某个未知的超类添加新的功能，这使得特质比类更为“可插拔”
（pluggable）**。尤其是 **特质成功地避开了多重继承中**，当某个子类通过不同的路径继承到 **同一
个超类时产生的“钻石继承”（diamondinheritance）问题**。

### Scala是函数式的
**Scala不只是一门纯的面向对象语言，它也是功能完整的函数式编程语言**。函数式编程的理念，甚至比计
算器还要早。这些理念早在20世纪30年代由Alonzo Church开发的 **lambda演算（lambda calculus）**
中得以建立。而第一个函数式编程语言 **Lisp** 的历史，可以追溯到20世纪50年代末。其他函数式编程语
言还包括：**Scheme、SML、Erlang、Haskell、Ocaml、F#等** 。很长一段时间，函数式编程都不是主
流，在学术界很受欢迎，但工业界并没有广泛使用。不过，最近几年，大家对函数式编程语言和技巧的兴趣与
日俱增。
**函数式编程以两大核心理念为指导。第一个理念是函数是一等（first-class）公民**。在函数式编程语
言中，函数值的地位跟整数、字符串等是相同的。**可以将函数作为参数传递给其他函数，作为返回值返回它
们，或者将它们保存在变量里。还可以在函数中定义另一个函数**，就像在函数中定义整数那样。**也可以在
定义函数时不指定名字**，就像整数字面量42，让函数字面量散落在代码中。

作为一等公民的函数提供了对操作的抽象和创建新的控制结构的便利。**这种函数概念的抽象带来了强大的表
现力，可以让我们写出精简可靠的代码。这一点对于伸缩性也有很大的帮助**。以ScalaTest为例，这个测试
类库提供了eventually（最后）这样的结构体，接收一个函数作为入参（argument）。用法如下：
```scala
val xs = 1 to 3
val it = xs.iterator
eventually {it.next() shouldBe 3}
```
在eventually中的代码————**it.next() shouldBe 3** 这句断言，被包在一个函数里，**该函数并
不会直接执行，而是原样传入eventually方法**。在配置好的时间内，eventually将会反复执行这个函数，
直到断言成功。在大多数传统的编程语言中，函数并不是值。那些把函数当作值的也通常只是二等
（second-class）公民。

**函数式编程的第二个核心理念是程序中的操作应该将输入值映射成输出值，而不是当场（in place）修改
数据。不可变数据结构是函数式编程的基石之一。Scala类库在Java API的基础上定义了更多的不可变数据
类型**。比如Scala提供了不可变的列表（list）、元组（tuple）、映射（map）和集（set）等。

**函数式编程的这个核心理念的另一种表述是方法不应该有副作用（side effect）。方法只能通过接收入
参和返回结果这两种方式与外部环境通信**。举例来说，Java的String类的replace方法便符合这个描述：
它接收一个字符串（对象本身）、两个字符，交出一个新的字符串，其中所有出现的入参第一个字符都被替换
成了入参的第二个字符。调用replace并没有其他的作用。像这样的方法被认为是 **“指称透明的”
（referential transparent）（注：也可以翻译为 引用透明），意思是对于任何给定的输入，该方法调
用都可以被其结果替换，同时不会影响程序的语义**。
```
指称透明（或者引用透明）

函数副作用的问题，也称边界问题，降低甚至消灭副作用已经成为我们编程的一个重要原则，不要让一个方法或函数执行主要功能时，会产
生其他意想不到的次要功能，这些额外功能不是我们要求的，称为副作用。更严格地消灭副作用方式是引用透明(referentially
transparent)，这是面向函数范式FP中的一个术语，也是FP语言如Scala等相比Java特色所在。

“引用透明”（指称透明）这个概念来自于蒯因(Quine)的关于自然语言哲学。看看下面语句：BanQ比老鼠大，如果把"BanQ"去除，留个
空白在那里，显然变成：“??? 比老鼠大”。哲学家认为这是一个Context场景，通过填补场景中的空白，你得到了这个语句真实含义。

再次想一下北京这个城市，它是一个thing，有许多方式可以指称或引用(refer)它，“中国首都”或“在经纬XXX度的城市”。因此，“引用
透明”(referentially transparent)中的“引用referentially”这个词语的含义是在谈论这样一个事实：北京这个事物(thing)有很多名称，有
很多途径来表达指称这个事物。“引用透明”(referentially transparent)中“透明transparent”含义是“没有什么不同”，“都是一样”。

蒯因认为：如果我们能够用不同的名称替代上面语句中的空白，但是没有改变任何意思，总是得到同样的结果，那么这个场景Context就是
“引用透明”的。
如：
[北京]比老鼠大 是真；
[中国首都]比老鼠大 是真
[在经纬XXX度的城市]比老鼠大 是真

引用透明性 ，它在数学和计算机中都有近似的定义。 简单地，我们可以理解为「 一个表达式在程序中可以被它等价的值替换，而不影响结
果 」。如果一个函数的输入相同，对应的计算结果也相同，那么它就具备「引用透明性」，它可被称为「纯函数」。

引用透明性是一个非常诱人的性质。它要求无论函数在何时何处调用，它都在相同的输入下持续的产生相同的输出。这就是，函数调用时，
返回值对可变状态的依赖依赖非常少，理想情况下，完全不依赖。简单地说，函数的返回值只依赖于其输入值，这种特性就称为引用透明性。
```

**函数式编程鼓励不可变数据结构和指称透明的方法**。某些函数式编程语言甚至强制要求这些。**Scala给
你选择的机会**。如果你愿意，完全可以编写指令式（imperative）风格的代码，也就是用可变数据和副作
用编程。**不过Scala通常让你可以不必使用指令式的语法结构，因为有其他好的函数式的替代方案可供选择**。
