Typesafe配置库的配置文件语法和功能
================================================================================
Play使用的配置文件基于 [Typesafe配置库](https://github.com/lightbend/config)。

Play应用程序的配置文件必须在`conf/application.conf`中定义，它使用 
**[HOCON格式](https://github.com/lightbend/config/blob/master/HOCON.md)**。

**除application.conf文件外，配置还来自其他两个地方**。
+ 默认设置是从类路径上找到的任何 **`reference.conf`文件** 中加载的。 大多数`Play JAR`都包
含带有默认设置的`reference.conf`文件。**application.conf中的设置将覆盖reference.conf文
件中的设置**。
+ 也可以使用 **系统属性** 来设置配置。**系统属性将覆盖application.conf设置**。

使用Config的惯用方式是将所有配置键定义在`reference.conf`或`application.conf`中的某个位置。 
如果key没有合理的默认值，则通常将其设置为`null`表示“无值”。

## 1. 指定备用配置文件
在运行时，将从类路径加载默认的`application.conf`。**系统属性可用于强制使用其他配置源**：
+ **`config.resource`指定一个包含扩展名的资源名称，即`application.conf`，而不仅仅是
`application`**。
+ **`config.file`指定文件系统路径，再次应包含扩展名，而不是基本名称**。

**这些系统属性指定了application.conf的替换项，而不是附加项**。如果仍要使用`application.conf`
文件中的某些值，则可以通过在该文件的顶部写入 **include "application"** 来将`application.conf`
包含在其他`.conf`文件中。将`application.conf`的设置包含在新的`.conf`文件中之后，您可以指定
要 **覆盖** 的所有设置。

## 2. 从控制器使用
由于 **依赖注入**，因此可以在控制器（或组件）中使用 **默认设置** 或 **自定义设置** 来使用配置。
```scala
import javax.inject._
import play.api.Configuration

class MyController @Inject()(config: Configuration) {
  // ...
}
```

## 3. 与Akka一起使用
Akka将使用为您的Play应用程序定义的配置文件 **相同的配置文件**（也就是说，**他们共用配置文件**）。 
这意味着您可以在`application.conf`文件的Akka中配置任何内容。**在Play中，Akka从`play.akka`
设置中读取其设置**，而不是从`akka`设置中读取。

## 4. 与run命令一起使用
使用`run`命令运行应用程序时，需要了解一些有关配置的特殊信息。

### 4.1. 额外的devSettings
您可以在`build.sbt`中为`run`命令配置其他设置。**部署应用程序时将不会使用这些设置**。
```scala
PlayKeys.devSettings += "play.server.http.port" -> "8080"
```

### 4.2. application.conf中的HTTP服务器设置
在`run`模式下，Play的HTTP服务器部分在编译应用程序之前启动。 **这意味着HTTP服务器启动时无法访
问`application.conf`文件**。如果要在使用`run`命令时覆盖HTTP服务器设置，则不能使用
`application.conf`文件。 相反，**您需要使用系统属性或上面显示的`devSettings`设置**。 服务
器设置的一个示例是HTTP端口：
```shell
> run -Dhttp.port=1234
```
其他服务器设置可以在[这里](https://www.playframework.com/documentation/2.7.x/ProductionConfiguration#Server-configuration-options)看到。 如您在这些服务器设置中看到
的，如果尚未通过`PlayKeys.devSettings`定义端口或地址，则http(s)端口和地址将回退到配置键
`PLAY_HTTP_PORT`，`PLAY_HTTPS_PORT`和`PLAY_HTTP_ADDRESS`。**由于这些配置键是替换键**，
因此您也可以通过 **环境变量** 定义设置它（例如，在Linux中使用Bash时）：
```shell
export PLAY_HTTP_PORT=9001
export PLAY_HTTPS_PORT=9002
export PLAY_HTTP_ADDRESS=127.0.0.1
```
如果您需要 **针对开发模式（与run命令一起使用的模式）定制Akka配置，则还有一个特定的命名空间**。 
您需要在`PlayKeys.devSettings`中使用`play.akka.dev-mode`作为配置的 **前缀**，例如：
```scala
PlayKeys.devSettings += "play.akka.dev-mode.akka.cluster.log-info" -> "off"
```
如果使用的`Akka ActorSystem`运行开发模式与应用程序本身使用的`ActorSystem`之间存在某些冲突，
则此功能特别有用。

## 5.HOCON语法
HOCON与JSON有相似之处。

### 5.1. 保持与JSON一样，不变
+ 文件必须是有效的UTF-8；
+ 带引号的字符串与JSON字符串的格式相同；
+ 值具有可能的类型：字符串，数字，对象，数组，布尔值，空；
+ 允许的数字格式与JSON匹配；与JSON中一样，未表示某些可能的浮点值，例如NaN。

### 5.2. 注释
`//`或`#`与下一个换行符之间的任何内容均被视为注释并被忽略，除非`//`或`#`包含在带引号的字符串中。

### 5.3. 省略根括号
**JSON文档的根必须有一个数组或对象**。空文件和所有仅包含非数组非对象值（例如字符串）的文件一样，
都是无效文档。

**在HOCON中，如果文件不是以方括号或大括号开头，则将其解析为好像用`{}`大括号括起来一样**。如果
HOCON文件省略了开头{但仍然有结束符则无效}; 花括号必须平衡。

### 5.4. 逗号
**数组** 中的值和 **对象** 中的字段之间 **不必有逗号**，只要它们之间至少有一个`ASCII`换行符（
`\n`十进制值10）即可。

**数组中的最后一个元素或对象中的最后一个字段可能后跟一个逗号，多余的逗号将被忽略**。
+ `[1,2,3,]`和`[1,2,3]`是相同的数组。
+ `[1\n2\n3]`和`[1,2,3]`是相同的数组。
+ `[1,2,3,,]` 无效，因为它有两个结尾的逗号。
+ `[,1,2,3]`无效，因为它有一个初始逗号。
+ `[1,,2,3]`无效，因为它连续有两个逗号。
+ 这些相同的逗号规则适用于对象中的字段。

### 5.5. 重复的键
JSON规范并未阐明应如何处理同一对象中的重复键。**在HOCON中，除非两个值都是对象，否则稍后出现的重
复键将覆盖先前出现的重复键。如果两个值都是对象，则合并对象**。

**合并对象**：
+ 将仅在两个对象之一中存在的字段添加到合并的对象中。
+ 对于两个对象中都存在的非对象值字段，必须使用在第二个对象中找到的字段。
+ 对于两个对象中都存在的对象值字段，应根据这些相同规则递归合并对象值。

**可以通过先将键设置为另一个值来防止对象合并**。这是因为合并总是一次完成两个值。**如果您将键设置
为对象，非对象，然后是对象，首先，非对象退回对象（非对象总是获胜），然后对象回落到非对象（不合并，
对象是新值）。 因此，这两个对象再也看不见**。

这两个等效：
```json
{
    "foo" : { "a" : 42 },
    "foo" : { "b" : 43 }
}

{
    "foo" : { "a" : 42, "b" : 43 }
}
```
这两个是等效的：
```json
{
    "foo" : { "a" : 42 },
    "foo" : null,
    "foo" : { "b" : 43 }
}

{
    "foo" : { "b" : 43 }
}
```
**中间设置"foo"到null防止对象合并**。

### 5.6. 路径作为键
如果键是具有多个元素的 **路径表达式**，则将其扩展为每个路径元素（最后一个除外）创建一个对象。最
后一个路径元素及其值将成为多数嵌套对象中的一个字段。换一种说法：
```
foo.bar : 42
```
等效于：
```
foo { bar : 42 }
```
另：
```
foo.bar.baz : 42
```
等效于：
```
foo { bar { baz : 42 } }
```
等等。**这些值以通常的方式合并**。这意味着：
```
a.x : 42, a.y : 43
```
等效于：
```
a { x : 42, y : 43 }
```
因为 **路径表达式的工作方式类似于值串联，所以键中可以包含空格**：
```
a b c : 42
```
等效于：
```
"a b c" : 42
```
**因为路径表达式总是转换为字符串，所以即使通常具有其他类型的单个值也将变为字符串**。
+ true : 42  是 "true" : 42
+ 3.14 : 42  是 "3.14" : 42

**作为特殊规则，未加引号的字符串`include`可能不会在键中以路径表达式开头，因为它具有特殊的解释**
（请参见下文）。

## 6. 替代
替代是引用 **配置树** 其他部分的一种方式。

语法为`${pathexpression}`或`${?pathexpression}`，其中`pathexpression`是如上所述的 
**路径表达式**。 此路径表达式具有与对象键相同的语法。

在`${?pathexpression}`的`?`前不能有 **空白**； `${?`这三个字符必须完全分组在一起。

对于在配置树中找不到的替代，实现可以尝试通过查看 **系统环境变量** 或 **其他外部配置源** 来解决
它们。（在后面的部分中将详细介绍环境变量。）

**不会在带引号的字符串内解析替代**。要获得包含替代的字符串，必须在未加引号的部分中使用 **值串联**
和 **替代**：
```
key : ${animal.favorite} is my favorite animal
```
或者，您 **可以引用非替代部分**：
```
key : ${animal.favorite}" is my favorite animal"
```
**通过在配置中查找路径来解决替代**。该路径从 **根配置对象** 开始，即它是“**绝对**”而不是“相对”。

替代处理是最后的解析步骤，因此可以在配置中进行替换。如果一个配置包含多个文件，它甚至可能最终会从另
一个文件中检索一个值。如果多次指定键，则替代将始终求值为其最新分配的值（合并的对象或设置的最后一个
非对象值）。

如果配置将值设置为`null`，则不应在外部源中查找它。不幸的是，没有办法在以后的配置文件中“撤消”。如
果您在根对象中有`{"HOME":null}`，则`${HOME}`将永远不会查看环境变量。换句话说，这不等同于JavaScript
的`delete`操作。

如果替代与配置中存在的任何值都不匹配并且未被外部源解析，则它是未定义的。用`${foo}`语法进行的未定义
替换无效，并且应生成错误。

如果用`${?foo}`语法的替代是未定义：
+ 如果它是对象字段的值，则该字段不应被创建。如果该字段将覆盖先前设置的相同字段的值，则保留前一个值。
+ 如果它是数组元素，则不应添加该元素。
+ 如果它是 **值串联** 的一部分，则应成为一个空字符串。
+ 如果bar是未定义的，`foo:${?bar}`将避免创建字段foo，但`foo:${?bar}${?baz}`将是一个值，所以如果串联
`bar`或`baz`没有定义，则结果是空字符串。

替代只能在 **对象字段值** 和 **数组元素（值串联）** 中使用，不允许在 **键** 中或 **嵌套在其他替代**（路
径表达式）中。

替代将替换为任何值类型（**数字，对象，字符串，数组，true，false和null**）。如果替代是值的唯一部分，
则保留类型。否则，将其值连接以形成字符串。

循环替换无效，应产生一个错误。

但是，实现必须小心，以允许对象引用其内部的路径。例如，这必须工作：
```
bar: {
    foo: 42,
    baz: ${bar.foo}
}
```
在这里，如果一个解决方案解决了`$ {bar.foo}`的一部分，则解决了bar中的所有替换问题，那么就会有一个循环。 
**该实现只能解析bar中的foo字段，而不是递归整个bar对象**。

## 7. 包含