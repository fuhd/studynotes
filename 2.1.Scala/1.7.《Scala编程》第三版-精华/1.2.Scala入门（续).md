Scala入门（续)
===================================================================================
## 1.用类型参数化数组
当你用Scala实例化对象时，可以用 **值** 和 **类型** 来对其进行 **参数化**。可以 **用值来参数化** 一个实
例，做法是在 **构造方法** 的 **圆括号** 中传入对象参数，也可以 **用类型来参数化** 一个实例，做法是在
 **方括号** 里给出一个或多个类型。

Scala的 **数组** 的访问方式是将 **下标放在圆括号里**，而不是像Java那样用方括号。

### 1.1.精简的方式来创建和初始化数组
```scala
val numNames = Array("zero","one","two")
```
实际上是调用了一个名为 **apply** 的工厂 方法，这个方法创建并返回了新的数组。这个apply方法接收一个
**变长的参数列表**，该方法定义在 **Array的伴生对象**中。

### 1.2.如果方法只接收一个参数
如果一个方法只接收一个参数，在调用它的时候，可以 **不使用英文句点或圆括号**。

### 1.3.Scala用圆括号来访问数组
数组不过是类的实例，这一点跟其他Scala实例没有本质区别。当你用一组圆括号将一个或多个值包起来， 并将
其应用（apply）到某个对象时，Scala会将这段代码转换成对这个对象的一个名为apply的方法的调用。因此，
**在Scala中访问一个数组的元素就 是一个简单的方法调用，跟其他方法调用一样**。这并不是一个特例，这是
一个通行的规则。

## 2.使用列表

### 2.1.列表拼接(:::)
```scala
val oneTwo = List(1,2)
val threeFour = List(3,4)
val oneTwoThreeFour = oneTwo ::: threeFour
```

### 2.2.列表拼接元素（::）
列表上用得最多的操作是 **“::”，读作“cons”**。它在一个已有 **列表的最前面添加一个新的元素**，并返
回这个 **新的** 列表。
```scala
val twoThree = List(2,3)
val oneTwoThree = 1 :: twoThree
```
**“::”是 右操作元的方法**。

### 2.3.空列表(Nil)
初始化一个新的列表的另一种方式是用`::`将元素串接起来，并将 **Nil作为最后一个元素**。
```scala
val oneTwoThree = 1 :: 2 :: 3 :: Nil
```

### 2.4.为什么不在列表末尾追加元素
因为往列表（**末尾**）追加元素的操作 **所需要的时间随着列表的大小线性增加**。

## 3.使用元组
不过跟List不同的是，元组可以容纳 **不同类型** 的元素。

一旦实例化好一个元组，可以用 **英文句点、下划线和从1开始的序号** 来访问每一个元素。
```scala
val pair = (99, "Luftballons")
println(pair._1)
println(pair._2)
```

### 3.1.元组的实际类型
**元组的实际类型取决于它包含的元素以及元素的类型**。因此，`(99,"Lufiballons")`这个元组的类型是 
`Tuple2[Int, String]`，而元组`('u','r',"the",1,4,"me")`的类型是 `Tuple6[Char,Char, String,Int,Int,String]`。

## 4.使用集和映射

### 4.1.集（set)
Scala的API包含了一个基础的 **特质（trait）**  来表示集，这里的 **特质跟Java的接口定义类似**。在此基础
上，**Scala提供了两个子特质， 一个用于表示可变集，另一个用于表示不可变集**。

使用特质叫作在Scala中“**扩展**”或者“**混入**”特质。
- **不可变集**
  创建集的默认方式：
  ```scala
  var jetSet = Set("Boeing", "Airbus")
  ```
  包含两个字符串的 **不可变集**。
  示例中，实际上调用了 **scala.collection.immutable.Set的伴生对象的apply方法**，返回一个默认的、不
  可变的Set的对象。
- **可变集**
  需要做一次引入（**import**）
  ```scala
  import scala.collection.mutable
  val movieSet = mutable.Set("Hitch", "Poltergeist")
  movieSet += "Shrek"
  ```
- **对集调用`+`方法**
  **不论是可变的还是不可变的集，`+`方法都 会创建并返回一个新的包含了新元素的集**。可变集提供了一个实
  际的`+=`方法（**还是在原对象上添加元素？**），不可变集并不直接提供这个方法。

- **特定的集**
  尽管由可变和不可变Set的工厂方法生产出来的 **默认集** 的实现对于大多数情况来说都够用了，偶尔可能也需
  要一类 **特定的集**。
  只需要简单地引入你需要的类，然后使用其伴生对象上的工厂方法即可。
  ```scala
  import scala.collection.immutable.HashSet
  val hashSet = HashSet("Tomatoes", "Chilies")
  ```

### 4.2.映射（map）
在`scala.collection`包里有一个基础的 **Map特质，还有两个子特质，都叫Map**，可变的那个位于
`scala.collection.mutable`，而不可变的那个 位于`scala.collection.immutable`。
```scala
import scala.collection.mutable
val treasureMap = mutable.Map[Int, String]()
treasureMap += (1 -> "Go to island.")
treasureMap += (2 -> "Find big X on ground.")
treasureMap += (3 -> "Dig.")
```
Scala编译器会将二元的操作，比如`1 -> "Go to island."`，转换成标准的方法调用，即`(1).->("Go to island.")`。
**可以在scala的任何对象上调用这个` ->`方法，它将返回包含键和值两个元素的元组**。

示例中，然后将这个元组传给treasureMap指向的那个映射对象的`+=`方法。**Scala允许对任何对象调用`->`
方法的机制，即隐式转换**。如果你更倾向于使用不可变的映射，则不需要任何引入，因为 **默认的映射就是不
可变的**。得到的是默认的那个`scala.collection. immutable.Map`。

那段 **显式的类型参数声明**“[int,String]”是 **必需** 的，因为没有在工厂方法传入任何值的情况下，**编译
器无法推断出映射的类型**。

## 5.可变与不可变

### 5.1.不可变
- **列表（List）**
  Scala的List是不可变的，而Java的List是可变的。更笼统地说，Scala的List被设计为允许函数式风格的编程。
  
  将这个 **函数式** 的哲学应用到对象的世界意味着 **让对象不可变**。

- **元组（Tuple）**
  元组（tuple），跟List类似也是不可变的。

### 5.2.可变
- **数组（Array）**
  Scala数组是一个拥有 **相同类型** 的对象的 **可变序列**。

### 5.3.有可变也有不可变
- **集（set）**
- **映射（map）**

## 6.识别函数式编程风格

### 6.1.不使用var
如果代码 **完全没有var**（也就是说代码只包含val），那么它 **很可能** 是函数式的。

### 6.2.没有副作用
函数要避免产生副作用，但有一些函数为副作用而生。

如果一个函数并不返回任何有意义的值，也就是 **Unit** 这样的结果类型所表达的意思，那么这个函数存在于世
上唯一的意义就是产生某种副 作用。

**每个有用的程序都会有某种形式的副作用。否则，它对于外部世界就没有任何价值**。