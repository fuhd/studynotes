Java强引用、软引用、弱引用、虚引用详解 
==============================================================
Java中没有指针的概念，而引用就是一个弱化的指针，保证开发不能任意操作内存。
引用分为：**强引用、软引用、弱引用、虚引用**。

### 强引用 
如果一个对象具有强引用，GC绝不会回收它；当内存空间不足，JVM宁愿抛出OutOfMemoryError错误。
**一般new出来的对象都是强引用**。示例：
```java
//强引用 
User strangeReference = new User();
```

### 软引用
如果一个对象具有软引用，**当内存空间不足，GC会回收这些对象的内存**，软引用可用来 **实现内存敏感的高速缓存**。
软引用可以和一个引用队列（ReferenceQueue）联合使用，**如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中**。
**软引用的声明借助强引用或者匿名对象**，使用 **泛型SoftReference** ；可以 **通过get方法获得强引用**。示例：
```java
//软引用
SoftReference<User> softReference = new SoftReference<User>(new User());
strangeReference = softReference.get(); //通过get方法获得强引用
```

### 弱引用 
如果一个对象具有弱引用，**在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存**，
使用弱引用构建 **非敏感数据的缓存**。**弱引用的声明借助强引用或者匿名对象，使用泛型WeakReference<T>**。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，**如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中**。
示例：
```java
//弱引用
WeakReference<User> weakReference = new WeakReference<User>(new User());
```

### 虚引用
如果一个对象仅持有虚引用，**在任何时候都可能被垃圾回收**，虚引用与软引用和弱引用的一个区别在于：
**虚引用必须和引用队列联合使用，虚引用主要用来跟踪对象被垃圾回收的活动**。与其他几种引用都不同，
虚引用并不会决定对象的生命周期。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收**。
虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，
把这个虚引用加入到与之关联的引用队列中。示例：
```java
//虚引用
PhantomReference<User> phantomReference = new PhantomReference<User>(new User(),new ReferenceQueue<User>());
```

### 示例
```java
package com.fhd.java;

import java.lang.ref.*;
import java.util.HashSet;
import java.util.Set;

public class ReferenceDemo {

    private static ReferenceQueue<User> referenceQueue = new ReferenceQueue<>();
    private static final int size = 10;

    public static void checkQueue() {
        Reference<? extends User> reference = referenceQueue.poll();
        if (reference != null) {
            System.out.println("In queue : " + reference.get());
        }
    }

    public static void testSoftReference() {
        Set<SoftReference<User>> softReferenceSet = new HashSet<>();
        for (int i = 0; i < size; i++) {
            SoftReference<User> ref = new SoftReference<>(new User("Soft " + i), referenceQueue);
            System.out.println("Just created: " + ref.get());
            softReferenceSet.add(ref);
        }
        System.gc();
        checkQueue();
    }

    public static void testWeaKReference() {
        Set<WeakReference<User>> weakReferenceSet = new HashSet<>();
        for (int i = 0; i < size; i++) {
            WeakReference<User> ref = new WeakReference<>(new User("Weak " + i), referenceQueue);
            System.out.println("Just created: " + ref.get());
            weakReferenceSet.add(ref);
        }
        System.gc();
        checkQueue();
    }

    public static void testPhantomReference() {
        Set<PhantomReference<User>> phantomReferenceSet = new HashSet<>();
        for (int i = 0; i < size; i++) {
            PhantomReference<User> ref = new PhantomReference<>(new User("Phantom " + i), referenceQueue);
            System.out.println("Just created: " + ref.get());
            phantomReferenceSet.add(ref);
        }
        System.gc();
        checkQueue();
    }

    public static void main(String[] args) {
        testSoftReference();
        testWeaKReference();
        testPhantomReference();
    }
}

class User {

    private String name;

    public User(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return this.name;
    }

    public void finalize() {
        System.out.println("Finalizing ... " + name);
    }
}
```

