编写Echo客户端
===============================================================
Echo客户端将会：
1. 连接到服务器；
2. 发送一个或者多个消息；
3. 等待并接收从服务器发回的相同的消息；
4. 关闭连接；

编写客户端所涉及的两个主要代码部分也是 **业务逻辑** 和 **引导**。

### 通过ChannelHandler实现客户端逻辑
如同服务器，客户端将拥有一个用来处理数据的 **`ChannelInboundHandler`**。在这个场景下，
你将扩展 **`SimpleChannelInboundHandler`** 类以处理所有必須的任务，这要求重写下面的方法：
+ `channelActive()`：到服务器的连接已经建立之后将被调用；
+ `channelRead0()`：当从服务器接收到一条消息时被调用；
+ `exceptionCaught()`：在处理过程中引发异常时被调用；

```java
// 客户端的ChannelHandler
// @Sharable标记该类的实例可以被多个Channel共享
@Sharable
public class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        // 当被通知Channel是活跃的时候，发送一条消息
        ctx.writeAndFlush(Unpooled.copiedBuffer("Netty rocks!", CharsetUtil.UTF_8));
    }
    @Override
    public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {
        System.out.println("Client received: " + in.toString(CharsetUtil.UTF_8));
    }
    // 在发生异常时，记录错误并关闭Channel 
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```
1. 首先，你重写了 **`channelActive()`** 方法，其将在一个连接建立时被调用。
2. 接下来，你重写了 **`channelRead0()`** 方法。每当接收数据时，都会调用这个方法。需要注意的是，由服务器发送的消息可能会被分块接收。
也就是说，如果服务器发送了5字节，那么不能保证这5字节会被一次性接收。即使是对于这么少量的数据，`channelRead0()`方法也可能会被调用两次，
第一次使用一个持有3个字节的`ByteBuf`(Netty的字节容器)，第二次使用一个持有2字节的`ByteBuf`。
3. 重写的第三个方法 **`exceptionCaught()`**，记录`Throwable`，关闭`Channel`，在这个场景下，终止到服务器的连接。

### 注意：SimpleChannelInboundHandler与ChannelInboundHandler
你可能会想，**为什么我们在客户端使用的是`SimpleChannelInboundHandler`，而不是在`EchoServerHandler`中所使用的`ChannelInboundHandlerAdapter`呢**？
这和两个因素的相互作用有关：**业务逻辑如何处理消息** 以及 **Netty如何管理资源**。


