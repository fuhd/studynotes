参数化记录
=====================================================================
因为`logback-classic`里的`logger`实现了`SLF4J`的`Logger`接口，某些打印方法可接受多个参数。
这些不同的打印方法主要是为了在提高性能的同时尽量不影响代码可读性。

对于某个`Logger`，下面的代码：
```java
logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
```
**在构造消息参数时有性能消耗，即把整数`i`和`entry[i]`都转换为字符串时，还有连接多个字符串时。
不管消息会不会被记录，都会造成上述消耗**。

**一个可行的办法是用测试语句包围记录语句以避免上述消耗**，比如：
```java
if(logger.isDebugEnabled()) {
    logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
}
```
**当`logger`的`debug`级别被禁用时，这个方法可以避免参数构造带来的性能消耗**。另一方面，如果`logger`的
`DEBUG`级别被启用，那么会导致两次评估`logger`是否被启用：一次是`isDebugEnabled`方法，一次是`debug`方法。
在实践中，这种额外开销无关紧要，**因为评估`logger`所消耗的时间不足实际记录请求所用时间的`1%`**。

### 更好的替代方法
还有一种基于消息格式的方便的替代方法。假设`entry`是一个`object`，你可以编写：
```java
Object entry = new SomeObject();
logger.debug("The entry is {}.", entry);
```
**在评估是否作记录后，仅当需要作记录时，`logger`才会格式化消息，用`entry`的字符串值替换"{}"。换句话说，
当记录语句被禁用时，这种方法不会产生参数构造所带来的性能消耗**。
