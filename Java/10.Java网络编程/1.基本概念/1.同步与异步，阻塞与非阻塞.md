同步与异步，阻塞与非阻塞
======================================
### 同步和异步
首先来解释同步和异步的概念,这两个概念与 **消息的通知机制** 有关。

举个例子，比如我去银行办理业务，可能选择排队等候，也可能取一个小纸条（叫号），等到了我的号时由柜台的人
通知我去办理业务。前者（**排队等候**）就是 **同步** 等待消息；而后者（**等待别人通知**）就是 **异步**
等待消息。在 **异步消息处理** 中，**等待消息者**（在这个例子中就是等待办理业务的人）往往 **注册一个回调机制**。
所等待的事件被触发时由触发机制（在这里是柜台的人）通过某种机制（这里是写在小纸条上的号码）找到等待该事件的人。
在实际的程序中，同步消息处理就好比简单的`read/write`操作，它们需要等待这两个操作成功才能返回；
而异步处理机制就是类似于`select/poll`之类的多路复用IO操作，当所关注的消息被触发时，由消息触发机制通知触发对消息的处理。

### 阻塞和非阻塞
这两个概念与 **程序等待消息(无所谓同步或者异步)时的状态** 有关。

继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，**等待者除了等待消息之外不能做其它的事情**，
那么该机制就是 **阻塞** 的。表现在程序中，也就是 **该程序一直阻塞在该函数调用处不能继续往下执行**。
相反，有的人喜欢在银行办理这些业务的时候一边打电话发短信一边等待，这样的状态就是非阻塞的，因为他（等待者）没有阻塞在这个消息通知上，
而是一边做自己的事情一边等待。但是需要注意，一种 **同步非阻塞** 形式实际上是效率低下的。
想像一下你一边打着电话一边还要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，
这个程序需要在这 **两种不同的行为之间来回的切换**，效率可想而知是低下的；而后者，**异步非阻塞** 形式却没有这样的问题，
因为打电话是你（等待者）的事情，而通知你则是柜台（消息触发机制）的事情，程序没有在两种不同的操作中来回切换。

### 一些容易理解错误的地方
很多人会 **把同步和阻塞混淆**，我想是因为 **很多时候同步操作会以阻塞的形式表现出来**。比如很多人会写阻塞的`read/write`操作，
但是别忘了可以对`fd`设置`O_NONBLOCK`标志位，这样就可以将同步操作变成非阻塞的了；同样的，很多人也会 **把异步和非阻塞混淆**，
**因为异步操作一般都不会在真正的IO操作处被阻塞**。比如如果用`select`函数，当`select`返回可读时再去`read`一般都不会被阻塞，
就好比当你的号码排到时一般都是在你之前已经没有人了，所以你再去柜台办理业务就不会被阻塞。
