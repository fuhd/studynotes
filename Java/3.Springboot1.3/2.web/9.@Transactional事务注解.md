@Transactional事务注解
================================
+ `@Transactional`只能被应用到`public`方法上，对于其它非public的方法，如果标记了`@Transactional`也不会报错，
但方法没有事务功能。
+ 默认情况下，一个有事务方法，遇到`RuntiomeException`时会回滚。遇到 **检查异常** 是不会回滚的。
要想所有异常都回滚，要加上`@Transactional(rollbackFor={Exception.class,其它异常})` 。

###　@Transactional的所有可选属性

属性|类型|默认值|说明
---|----|-----|-------
propagation|Propagation枚举|REQUIRED|事务传播属性
isolation|isolation枚举|DEFAULT|事务隔离级别
readOnly|boolean|false|是否只读
timeout|int|-1|超时(秒)
rollbackFor|Class[]|{}|需要回滚的异常类
rollbackForClassName|String[]|{}|需要回滚的异常类名
noRollbackFor|Class[]|{}|不需要回滚的异常类
noRollbackForClassName|String[]|{}|不需要回滚的异常类名

#### 事务的隔离级别
示例：
```java
@Transactional(isolation=Isolation.DEFAULT)
public String function(){.......................}
```

隔离级别|隔离级别描述
-------|----------------------------
DEFAULT|采用数据库默认隔离级别
READ_UNCOMMITTED|读取未提交
READ_COMMITTED|读取已提交
REPEATABLE_READ|可重复读
SERIALIZABLE|串行化读

#### 事务的传播属性
示例：
```java
@Transactional(propagation=Propagation.REQUIRED)
public String function(){.......................}
```
事务传播属性|描述
----------|-----------------------------------------------
REQUIRED|业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务，这是spring默认的传播行为。
SUPPORTS|如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分，如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行。
MANDATORY|只能在一个已存在事务中执行，业务方法不能发起自己的事务，如果业务方法在没有事务的环境下调用，就抛异常。
REQUIRES_NEW|业务方法总是会为自己发起一个新的事务，如果方法已运行在一个事务中，则原有事务被挂起，新的事务被创建，直到方法结束，新事务才结束，原先的事务才会恢复执行。
NOT_SUPPORTED|声明方法需要事务，如果方法没有关联到一个事务，容器不会为它开启事务。如果方法在一个事务中被调用，该事务会被挂起。在方法调用结束后，原先的事务便会恢复执行。
NEVER|声明方法绝对不能在事务范围内执行，如果方法在某个事务范围内执行，容器就抛异常。只有没关联到事务，才正常执行。
NESTED|如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动的事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保证点。内部事务回滚不会对外部事务造成影响，它只对DataSourceTransactionManager事务管理器起效。
