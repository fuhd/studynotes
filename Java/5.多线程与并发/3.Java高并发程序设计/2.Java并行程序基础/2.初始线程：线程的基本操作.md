初始线程：线程的基本操作
==========================================================
必须要了解Java中为线程操作所提供的一些API。比如，如何新建并且启动线程，如何终止线程，中断线程等。

### 新建线程
新建线程很简单。只要使用`new`关键字创建一个线程对象，并且将它`start()`起来即可。
```java
Thread t1 = new Thread();
t1.start();
```
那线程`start()`后，会干什么呢？这才是问题的关键，线程`Thread`，有一个`run()`方法，`start()`
方法就会新建一个线程并让这个线程执行`run()`方法。

注意：一定要把调用`start()`方法和直接调用`run()`方法区别开来。不要用`run()`来开启新线程。
它只会在当前线程中，串行执行`run()`方法。

如何来编写线程？
+ 可以通过继承`Thread`，重载`run()`方法来自定义线程。
+ 可以通过实现`Runable`接口，并实现`run()`方法即可。

### 终止线程
一般来说，线程在执行完毕后就会结束，无须手工关闭。但是，凡事也都有例外。一些服务端的后台线程可能会常
驻系统，它们通常不会正常终结。比如，它们的执行体本身就是一个大大的无穷循环，用于提供某些服务。

那如何正常的关闭一个线程呢？                                                                                                                                                                                                                                                                                                                                              查阅JDK，你不难发现`Thread`提供了一个`stop()`方法，如果你使用`stop()`方法，就可以立即将一个线程
终止，非常方便，但你会发现 **`stop()`方法是一个被标注为废弃的方法**。

**为什么`stop()`被废弃而不推荐使用呢？原因是`stop()`方法太过于暴力，强行把执行到一半的线程终止，
可能会引起一些数据不一致的问题！**

`Thread.stop()`方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。而这些锁恰恰
是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，
由于锁已经被释放，另外一个等待该锁的读线程就顺理成章的读到了这个不一致的对象，悲剧也就此发生了！

### 线程中断
在Java中，线程中断是一种重要的线程协作机制。从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。
在上一节中，我们已经详细讨论了`stop()`方法停止线程的害处，那么在JDK中是否有提供更强大的支持呢？
答案是肯定的，那就是线程中断。

严格地讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出啦！
至于目标线程接到通知后如何处理，则完全由目标线程自行决定。这点很重要，如果中断后，线程立即无条件退出，
我们就又会遇到`stop()`方法的老问题。

与线程中断有关的，有三个方法，这三个方法看起来很像，所以可能会引起混淆和误用，一定要注意。
```java
public void Thread.interrupt()              //中断线程
public boolean Thread.isInterrupted()       //判断是否被中断
public static boolean Thread.interrupted()  //判断是否被中断，并清除当前中断状态
```
`Thread.interrupte()`方法是一个实例方法。它通知目标线程中断，也就是设置中断标志位。中断标志位表示
当前线程已经被中断了。`Thread.isInterrupted()`方法也是实例方法，它判断当前线程是否有被中断（通过
检查中断标志位）。最后的静态方法`Thread.interrupted()`也是用来判断当前线程的中断状态，但同时会清
除当前线程的中断标志位状态。

示例：
```java
public static void main(String[] args) throws InterruptedException {
  Thread t1 = new Thread() {
    @Override
    public void run() {
      while(true){
        if(Thread.currentThread().isInterrupted()){
          System.out.println("Interrupte!");
          break;
        }
        try {
          Thread.sleep(2000);
        } catch (InterruptedException e) {
          System.out.println("Interrupteed When Sleep");
          //设置中断状态
          Thread.currentThread().interrupt();
        }
        Thread.yield();
      }
    }
  };
  t1.start();
  Thread.sleep(2000);
  t1.interrupt();
}
```
在`try-catch`代码部分，线程被中断则程序会抛出异常。在`catch`部分，由于已经捕获了中断，我们可以立即
退出线程。但在这里，我们并没有这么做，因为也许在这段代码中，我们还必须进行后续的处理，保证数据的一致性
和完整性，因此，执行了`Thread.interrupt()`方法再次中断自己，置上中断标记位。

**注意：`Thread.sleep()`方法由于中断而抛出异常，此时，它会清除中断标记，如果不加处理，那么在下一次循环
开始时，就无法捕获这个中断，故在异常处理中，再次设置中断标记位**。

### 等待（wait）和通知（notify）
为了支持多线程之间的协作，JDK提供了两个非常重要的线程等待`wait()`方法和通知`notify()`方法。
这两个方法并不是在`Thread`类中的，而是输出`Object`类。这也意味着任何对象都可以调用这两个方法。
这两个方法签名如下：
```java
public final void wait() throws InterruptedException
public final native void notify()
```
当在一个对象实例上调用`wait()`方法后，当前线程就会在这个对象上等待。比如，线程A中，调用了`obj.wait()`方法，
那么线程A就会停止继续执行，而转为等待状态。等待到何时结束呢？线程A会一直等到其他线程调用了`obj.notify()`方法为止。
这时，`obj`对象就俨然成为多个线程之间的有效通信手段。

那`wait()`和`notify()`究竟是如何工作呢？如果一个线程调用了`object.wait()`，那么它就会进入`object`
对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。当`object.notify()`
被调用时，它就会从这个等待队列中，随机选择一个线程，并将其唤醒。这里希望大家注意的是，这个选择是不公平的，
并不是先等待的线程会优先被选择，这个选择完全是随机的。

除了`notify()`方法外，`Object`对象还有一个类似的`notifyALL()`方法，它和`notify()`的功能基本一致，
但不同的是，它会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。

**这里还需要注意一点，`Object.wait()`方法并不是可以随便调用的。它必须包含在对应的`synchronzied`语句中，
无论是`wait()`或者`notify()`都需要首先获得目标对象的一个监视器（必须包含在对应的`synchronzied`语句中！！）**。

一个简单地使用`wait()`和`notify()`的案例：
```java
public class SimpleWN {
  final static Object object = new Object();
  public static class T1 extends Thread {
    public void run() {
      synchronized (object) {
        System.out.println(System.currentTimeMillis() + ":T1 start! ");
        try {
          System.out.println(System.currentTimeMillis() + ":T1 wait for object ");
          object.wait();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        System.out.println(System.currentTimeMillis + ":T1 end !");
      }
    }
  }
  public static class T2 extends Thread {
    public void run() {
      synchronized(object) {
        System.out.println(System.currentTimeMillis + ": T2 start! notify one thread!");
        object.notify();
        System.out.println(System.currentTimeMillis + ":T2 end!");
        try {
          Thread.sleep(2000);
        } catch (InterruptedException e){
          e.printStackTrace();
        }
      }
    }
  }

  public static void main(String[] args) {
    Thread t1 = new T1();
    Thread t2 = new T2();
    t1.start();
    t2.start();
  }
}
```
**注意：`Object.wait()`和`Thread.sleep()`方法都可以让线程等待若干时间，除了`wait()`可以被唤醒外，
另外一个主要区别就是`wait()`方法会释放目标对象的锁，而`Thread.sleep()`方法不会释放任何资源（关于
`Thread.sleep()`与别的书看得不一样，疑问！！！！？？？？？？？？？）**。
