初始线程：线程的基本操作
==========================================================
必须要了解Java中为线程操作所提供的一些API。比如，如何新建并且启动线程，如何终止线程，中断线程等。

### 新建线程
新建线程很简单。只要使用`new`关键字创建一个线程对象，并且将它`start()`起来即可。
```java
Thread t1 = new Thread();
t1.start();
```
那线程`start()`后，会干什么呢？这才是问题的关键，线程`Thread`，有一个`run()`方法，`start()`
方法就会新建一个线程并让这个线程执行`run()`方法。

注意：一定要把调用`start()`方法和直接调用`run()`方法区别开来。不要用`run()`来开启新线程。
它只会在当前线程中，串行执行`run()`方法。

如何来编写线程？
+ 可以通过继承`Thread`，重载`run()`方法来自定义线程。
+ 可以通过实现`Runable`接口，并实现`run()`方法即可。

### 终止线程
一般来说，线程在执行完毕后就会结束，无须手工关闭。但是，凡事也都有例外。一些服务端的后台线程可能会常
驻系统，它们通常不会正常终结。比如，它们的执行体本身就是一个大大的无穷循环，用于提供某些服务。

那如何正常的关闭一个线程呢？                                                                                                                                                                                                                                                                                                                                              查阅JDK，你不难发现`Thread`提供了一个`stop()`方法，如果你使用`stop()`方法，就可以立即将一个线程
终止，非常方便，但你会发现 **`stop()`方法是一个被标注为废弃的方法**。

**为什么`stop()`被废弃而不推荐使用呢？原因是`stop()`方法太过于暴力，强行把执行到一半的线程终止，
可能会引起一些数据不一致的问题！**

`Thread.stop()`方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。而这些锁恰恰
是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，
由于锁已经被释放，另外一个等待该锁的读线程就顺理成章的读到了这个不一致的对象，悲剧也就此发生了！
