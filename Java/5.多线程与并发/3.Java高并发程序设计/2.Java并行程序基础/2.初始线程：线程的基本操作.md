初始线程：线程的基本操作
==========================================================
必须要了解Java中为线程操作所提供的一些API。比如，如何新建并且启动线程，如何终止线程，中断线程等。

### 新建线程
新建线程很简单。只要使用`new`关键字创建一个线程对象，并且将它`start()`起来即可。
```java
Thread t1 = new Thread();
t1.start();
```
那线程`start()`后，会干什么呢？这才是问题的关键，线程`Thread`，有一个`run()`方法，`start()`
方法就会新建一个线程并让这个线程执行`run()`方法。

注意：一定要把调用`start()`方法和直接调用`run()`方法区别开来。不要用`run()`来开启新线程。
它只会在当前线程中，串行执行`run()`方法。

如何来编写线程？
+ 可以通过继承`Thread`，重载`run()`方法来自定义线程。
+ 可以通过实现`Runable`接口，并实现`run()`方法即可。

### 终止线程
一般来说，线程在执行完毕后就会结束，无须手工关闭。但是，凡事也都有例外。一些服务端的后台线程可能会常
驻系统，它们通常不会正常终结。比如，它们的执行体本身就是一个大大的无穷循环，用于提供某些服务。

那如何正常的关闭一个线程呢？                                                                                                                                                                                                                                                                                                                                              查阅JDK，你不难发现`Thread`提供了一个`stop()`方法，如果你使用`stop()`方法，就可以立即将一个线程
终止，非常方便，但你会发现 **`stop()`方法是一个被标注为废弃的方法**。

**为什么`stop()`被废弃而不推荐使用呢？原因是`stop()`方法太过于暴力，强行把执行到一半的线程终止，
可能会引起一些数据不一致的问题！**

`Thread.stop()`方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。而这些锁恰恰
是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，
由于锁已经被释放，另外一个等待该锁的读线程就顺理成章的读到了这个不一致的对象，悲剧也就此发生了！

### 线程中断
在Java中，线程中断是一种重要的线程协作机制。从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。
在上一节中，我们已经详细讨论了`stop()`方法停止线程的害处，那么在JDK中是否有提供更强大的支持呢？
答案是肯定的，那就是线程中断。

严格地讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出啦！
至于目标线程接到通知后如何处理，则完全由目标线程自行决定。这点很重要，如果中断后，线程立即无条件退出，
我们就又会遇到`stop()`方法的老问题。

与线程中断有关的，有三个方法，这三个方法看起来很像，所以可能会引起混淆和误用，一定要注意。
```java
public void Thread.interrupt()              //中断线程
public boolean Thread.isInterrupted()       //判断是否被中断
public static boolean Thread.interrupted()  //判断是否被中断，并清除当前中断状态
```
`Thread.interrupte()`方法是一个实例方法。它通知目标线程中断，也就是设置中断标志位。中断标志位表示
当前线程已经被中断了。`Thread.isInterrupted()`方法也是实例方法，它判断当前线程是否有被中断（通过
检查中断标志位）。最后的静态方法`Thread.interrupted()`也是用来判断当前线程的中断状态，但同时会清
除当前线程的中断标志位状态。

示例：
```java
public static void main(String[] args) throws InterruptedException {
  Thread t1 = new Thread() {
    @Override
    public void run() {
      while(true){
        if(Thread.currentThread().isInterrupted()){
          System.out.println("Interrupte!");
          break;
        }
        try {
          Thread.sleep(2000);
        } catch (InterruptedException e) {
          System.out.println("Interrupteed When Sleep");
          //设置中断状态
          Thread.currentThread().interrupt();
        }
        Thread.yield();
      }
    }
  };
  t1.start();
  Thread.sleep(2000);
  t1.interrupt();
}
```
