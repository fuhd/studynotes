数据共享通道：BlockingQueue
===============================================================
多线程的开发模式会引入一个问题，那就是 **如何进行多个线程间的数据共享呢**？比如，线程A希望给线程B发一个消息，
用什么方式告知线程B是比较合理的呢？

比如，你所在小区的物业希望可以得到一些业主的意见，设立了一个意见箱，如果对物业有任何要求和（或）意见都可以
投到意见箱里。这时，作为业主的你并不需要直接找到物业相关的领导表达你的意见。实际上，物业的工作人员也可能经常
发生变动，直接找工作人员未必是一件方便的事情。而你投递到意见箱的意见总是会被物业的工作人员看到，不管是否发生
人员的变动。这样，你就可以很容易地表达自己的诉求了。你既不需要直接和他们对话，又可以轻松提出自己的意见或建议。

将这个模式映射到我们程序中。就是说我们 **既希望线程A能够通知线程B，又希望线程A不知道线程B的存在**。这样，
如果将来进行重构或者升级，我们完全可以不修改线程A，而直接把线程B升级为线程C，保证系统的平滑过渡。
而这中间的“意见箱”就可以使用 **`BlockingQueue`** 来实现。

`BlockingQueue`是一个接口，并非一个具体的实现。它的主要实现有下面一些：
+ **ArrayBlockingQueue<E>**：一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。
默认情况下不保证访问者公平的访问队列。
+ **DelayedWorkQueue**：
+ **DelayQueue<E>**：一个支持延时获取元素的无界阻塞队列。队列使用`PriorityQueue`来实现。队列中的元素必须实现`Delayed`接口，
在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。
+ **LinkedBlockingQueue<E>**：一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。
此队列按照先进先出的原则对元素进行排序。
+ **PriorityBlockingQueue<E>**：一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，
也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。
+ **SynchronousQueue<E>**：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。
+ **LinkedBlockingDeque<E>**：一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。
双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。
+ **LinkedTransferQueue**：一个由链表结构组成的无界阻塞`TransferQueue`队列。扩展了`TransferQueue`接口，
生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费（不仅仅是添加到队列里就完事）。
