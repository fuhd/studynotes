数据共享通道：BlockingQueue
===============================================================
多线程的开发模式会引入一个问题，那就是 **如何进行多个线程间的数据共享呢**？比如，线程A希望给线程B发一个消息，
用什么方式告知线程B是比较合理的呢？

比如，你所在小区的物业希望可以得到一些业主的意见，设立了一个意见箱，如果对物业有任何要求和（或）意见都可以
投到意见箱里。这时，作为业主的你并不需要直接找到物业相关的领导表达你的意见。实际上，物业的工作人员也可能经常
发生变动，直接找工作人员未必是一件方便的事情。而你投递到意见箱的意见总是会被物业的工作人员看到，不管是否发生
人员的变动。这样，你就可以很容易地表达自己的诉求了。你既不需要直接和他们对话，又可以轻松提出自己的意见或建议。

将这个模式映射到我们程序中。就是说我们 **既希望线程A能够通知线程B，又希望线程A不知道线程B的存在**。这样，
如果将来进行重构或者升级，我们完全可以不修改线程A，而直接把线程B升级为线程C，保证系统的平滑过渡。
而这中间的“意见箱”就可以使用 **`BlockingQueue`** 来实现。

`BlockingQueue`是一个接口，并非一个具体的实现。它的主要实现有下面一些：
+ **ArrayBlockingQueue<E>**：规定大小的`BlockingQueue`，其构造函数必须带一个`int`参数来指明其大小，
其所含的对象是以`FIFO`（先入先出）顺序排序的。
+ **DelayedWorkQueue**：
+ **DelayQueue<E>**：
+ **LinkedBlockingQueue<E>**：大小不定的`BlockingQueue`，若其构造函数带一个规定大小的参数，
生成的`BlockingQueue`有大小限制，若不带大小参数，所生成的`BlockingQueue`的大小由`Integer.MAX_VALUE`来决定，
其所含的对象是以`FIFO`（先入先出）顺序排序的。
+ **FriorityBlockingQueue<E>**：类似于`LinkedBlockingQueue`，在这个数据结构，元素的默认排序是依据对象
的自然排序顺序排列（不是FIFO）。元素们必须实现带有`compareTo()`方法的`Comparable`接口。当你在结构中插入数据时，
它会与数据元素对比直到找到它的位置。
+ **SynchronousQueue<E>**：特殊的`BlockingQueue`，内部并没有数据缓存空间。其中每个插入操作必须等待另一个
线程的对应移除操作，反之亦然。
+ **BlockingDeque<E>**：
