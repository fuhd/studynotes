synchronized的功能扩展：重入锁
=================================================
重入锁可以完全替代`synchronized`关键字。**在JDK 5.0的早期版本中，重入锁的性能远远好于`synchronized`，
但从JDK 6.0开始，JDK在`synchronized`上做了大量的优化，使得两者的性能差距并不大**。

重入锁使用`java.util.concurrent.locks.ReentrantLock`类来实现。示例：
```java
package concurrent;

import java.util.concurrent.locks.ReentrantLock;

public class ReenterLock implements Runnable {

    public static ReentrantLock lock = new ReentrantLock();
    public static int i = 0;

    @Override
    public void run() {
        for (int j = 0; j < 10000; j++) {
            lock.lock();
            try {
                i++;
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReenterLock t1 = new ReenterLock();
        Thread thread1 = new Thread(t1);
        Thread thread2 = new Thread(t1);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(i);
    }
}
```
示例中，使用重入锁保护临界区资源`i`，确保多线程对`i`操作的安全性。与`synchronized`相比，重入锁
有着显示的操作过程。**开发人员必须手动指定何时加锁，保时释放锁。也正因为这样，重入锁对逻辑控制的灵活性
要远远好于`synchronized`。但注意的是，在退出临界区时，必须记得释放锁，否则，其他线程就没有机会再
访问临界区了**。

为什么要加上“重入”两个字呢？从类的命名上看，`Re-Entrant-Lock`翻译成重入锁是非常贴切的。
之所以这么叫，那是因为 **这种锁是可以反锁进入的。当然，这里的反复仅仅局限于一个线程**。

示例：
```java
lock.lock();
lock.lock();
try{
  i++;
}finally{
  lock.unlock();
  lock.unlock();
}
```
在这种情况下，一个线程连续两次获得同一把锁。这是允许的！如果不允许这么操作，那么同一个线程在第2次
获得锁时，将会和自己产生死锁。程序就会“卡死”在第2次申请锁的过程中。但需要注意的是，如果同一个线程
多次获得锁，那么在释放锁的时候，也必须释放相同次数。

### 中断响应
**对于`synchronized`来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，
要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。也就是在等待锁的过程中，
程序可以根据需要取消对锁的请求**。

如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待，可以停止工作了。这种情况对于处理
死锁是有一定帮助的。

下面的代码产生了一个死锁，但得益于锁中断，我们可以很轻易地解决这个死锁：
```java

```
