synchronized的功能扩展：重入锁
=================================================
重入锁可以完全替代`synchronized`关键字。**在JDK 5.0的早期版本中，重入锁的性能远远好于`synchronized`，
但从JDK 6.0开始，JDK在`synchronized`上做了大量的优化，使得两者的性能差距并不大**。

重入锁使用`java.util.concurrent.locks.ReentrantLock`类来实现。示例：
```java
package concurrent;

import java.util.concurrent.locks.ReentrantLock;

public class ReenterLock implements Runnable {

    public static ReentrantLock lock = new ReentrantLock();
    public static int i = 0;

    @Override
    public void run() {
        for (int j = 0; j < 10000; j++) {
            lock.lock();
            try {
                i++;
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReenterLock t1 = new ReenterLock();
        Thread thread1 = new Thread(t1);
        Thread thread2 = new Thread(t1);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(i);
    }
}
```
示例中，使用重入锁保护临界区资源`i`，确保多线程对`i`操作的安全性。与`synchronized`相比，重入锁
有着显示的操作过程。**开发人员必须手动指定何时加锁，保时释放锁。也正因为这样，重入锁对逻辑控制的灵活性
要远远好于`synchronized`。但注意的是，在退出临界区时，必须记得释放锁，否则，其他线程就没有机会再
访问临界区了**。

为什么要加上“重入”两个字呢？从类的命名上看，`Re-Entrant-Lock`翻译成重入锁是非常贴切的。
之所以这么叫，那是因为 **这种锁是可以反锁进入的。当然，这里的反复仅仅局限于一个线程**。
