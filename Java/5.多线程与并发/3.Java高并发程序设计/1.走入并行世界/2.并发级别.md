并发级别
==================================================
根据控制并发的策略，我们可以把并发的级别进行分类，大致上可以分为阻塞，无饥饿，无障碍，无锁，无等待几种。

### 阻塞（Blocking）
一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用 **`synchronized`** 关键字，
或者 **重入锁** 时，我们得到的就是阻塞的线程。

无论是`synchronized`或者重入锁，都会试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，
直到占有了所需资源为止。

### 无饥饿（Starvation-Free）
如果线程之间是有 **优先级** 的，那么线程调度的时候总是会倾向于满足高优先级的线程。也就是说，对于同一个资源的分配，
是不公平的！**对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿**。
但如果锁是公平的，满足先来后到，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。
那么所有的线程都有机会执行。

### 无障碍（Obstruction-Free）
无障碍是一种最弱的非阻塞调度。**两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起**。
换言之，大家都可以大摇大摆地进入临界区了。**那么如果大家一起修改共享数据，把数据改坏了怎么办？对于无障碍的线程来说，
一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全**。但如果没有数据竞争发生，那么线程
就可以顺利完成自己的工作，走出临界区。

如果说阻塞的控制方式是悲观策略。也就是说，系统认为两个线程之间很有可能发生不幸的冲突，因此，以保护共享数据为第一优先级。
相对来说，非阻塞的调度就是一种乐观的策略。它认为多个线程之间很有可能不会发生冲突，或者说这种概率不大。
因此大家都应该无障碍执行，但是一旦检测到冲突，就应该进行回滚。

从这个策略中也可以看到，无障碍的多线程程序并不一定能顺畅的运行。因为当临界区中存在严重的冲突时，
所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。
所以，我们可能会非常希望在这一堆线程中，至少可以有一个线程能够在有限的时间内完成自己的操作，而退出临界区。
至少这样可以保证系统不会在临界区中进行无限的等待。
