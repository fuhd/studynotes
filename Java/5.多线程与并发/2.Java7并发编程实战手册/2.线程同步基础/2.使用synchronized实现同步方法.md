使用synchronized实现同步方法
===============================================================
Java最基本的同步方式，即使用`synchronized`关键字来控制一个方法的并发访问。每一个用`synchronized`
关键字声明的方法都是临界区。在Java中，同一个对象的临界区，在同一时间只有一个允许被访问。

**静态方法则有不同的行为**，用`synchronized`关键字声明的静态方法，同时只能够被一个执行线程访问，
但是其他线程可以访问这个对象的非静态方法。必须非常谨慎这一点，**因为两个线程可以同时访问一个对象的两
个不同的`synchronized`方法，即其中一个是静态方法，另一个是非静态方法**。如果两个方法都改变了相同的数据，
将会出现数据不一致的错误。

示例，将使两个线程访问同一个对象。我们有一个银行帐号和两个线程，一个线程将转钱到帐户中，另一线程将
从帐户中取钱。
```java
import java.util.concurrent.TimeUnit;

public class Main5 {

    public static void main(String[] args) {
        Account account = new Account();
        account.setBalance(1000);
        Company company = new Company(account);
        Thread companyThread = new Thread(company);
        Bank bank = new Bank(account);
        Thread bankThread = new Thread(bank);
        System.out.printf("Account : Initial Balance: %f\n",account.getBalance());
        companyThread.start();
        bankThread.start();
        //等待两个线程运行完成
        try {
            companyThread.join();
            bankThread.join();
            System.out.printf("Account : Final Balance: %f\n",account.getBalance());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    //帐号类
    private static class Account {

        private double balance;

        //加
        public synchronized void addAmount(double amount){
            double tmp = balance;
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            tmp += amount;
            balance = tmp;
        }

        //减
        public synchronized void subtractAmount(double amount){
            double tmp = balance;
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            tmp -= amount;
            balance = tmp;
        }

        public double getBalance() {
            return balance;
        }

        public void setBalance(double balance) {
            this.balance = balance;
        }
    }

    private static class Bank implements Runnable{

        private Account account;

        public Bank(Account account){
            this.account = account;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10; i++){
                account.subtractAmount(1000);
            }
        }
    }

    private static class Company implements Runnable{

        private Account account;

        public Company(Account account) {
            this.account = account;
        }

        @Override
        public void run() {
            for(int i = 0; i < 10; i++){
                account.addAmount(1000);
            }
        }
    }
}
```
