使用锁实现同步
=====================================================
Java提供了同步代码块的另一种机制，它是一种比`synchronized`关键字更强大也更灵活的机制。这种机制 **基于
`Lock`接口及其实现类（例如`ReentrantLock`）**，提供了更多的好处。
+ **支持更灵活的同步代码块结构**。使用`synchronized`关键字时，只能在同一个`synchronized`块结构中获
取和释放控制。`Lock`接口允许实现更复杂的临界区结构。
+ **相比`synchronized`关键字，`Lock`接口提供了更多的功能**。其中一个新功能是`tryLock()`方法的实现。
这个方法试图获取锁，如果锁已被其他线程获取，它将返回`false`并继续往下执行代码。使用`synchronized`关键字时，
如果线程A试图执行一个同步代码块，而线程B已在执行这个同步代码块，则线程A就会被挂起直到线程b运行完这个同步代码块。
使用锁的`tryLock()`方法，通过返回值将得知是否有其他线程正在使用这个锁保护的代码块。
+ **`Lock`接口允许分离读和写操作，允许多个读线程和只有一个写线程**。
+ **相比`synchronized`关键字，`Lock`接口具有更好的性能**。

示例，模拟打印队列：
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Main8 {

    public static void main(String[] args) {
        PrintQueue printQueue = new PrintQueue();
        //创建10个打印工作Job对象
        Thread[] thread = new Thread[10];
        for (int i = 0; i < 10; i++) {
            thread[i] = new Thread(new Job(printQueue), "Thread " + i);
        }
        for (int i = 0; i < 10; i++) {
            thread[i].start();
        }
    }

    //打印队列类
    private static class PrintQueue {

        //声明一个锁对象
        private final Lock queueLock = new ReentrantLock();

        //打印方法
        public void printJob(Object document) {
            //通过调用lock()方法获取对锁对象的控制
            queueLock.lock();
            try {
                Long duration = (long) (Math.random() * 10000);
                System.out.printf("%s: PrintQueue: Printing a Job during %d seconds",
                        Thread.currentThread().getName(), duration / 1000);
                Thread.sleep(duration);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                //释放对锁对象的控制
                queueLock.unlock();
            }
        }

    }

    //打印工作类
    private static class Job implements Runnable {

        private PrintQueue printQueue;

        public Job(PrintQueue printQueue) {
            this.printQueue = printQueue;
        }

        @Override
        public void run() {
            System.out.printf("%s: Going to print a document\n", Thread.currentThread().getName());
            //打印
            printQueue.printJob(new Object());
            System.out.printf("%s: The document has been printed\n", Thread.currentThread().getName());
        }
    }
}
```
