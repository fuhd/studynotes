Netty服务端开发示例
=============================================================
Netty目前为止（2016－06－21），最新版本为4.1.1。前段时间出过5.0版，现在废弃了！
我们可以从 [Netty官网](http://netty.io/)下载开发包，这里就不多说了！

**注：netty可以all-in-one，也可以每个子包单独使用！！**

关于示例，我们使用Gradle构建示例项目：
```gradle
group 'com.fuhd'
version '1.0-SNAPSHOT'

apply plugin: 'java'
apply plugin: 'idea'

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    compile group: 'io.netty', name: 'netty-all', version: '4.1.1.Final'
    testCompile group: 'junit', name: 'junit', version: '4.11'
}

```

```java
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.util.Date;

public class TimeServer {

    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args != null && args.length > 0) {
            try {
                port = Integer.valueOf(args[0]);
            } catch (NumberFormatException e) {
                //采用默认值
            }
        }
        new TimeServer().bind(port);
    }

    public void bind(int port) throws Exception {
        //配置服务端的NIO线程组
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 1024)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new TimeServerHandler());
                        }
                    });
            //绑定端口，同步等待成功
            ChannelFuture f = b.bind(port).sync();
            //等待服务端监听端口关闭
            f.channel().closeFuture().sync();
        } finally {
            //优雅退出，释放线程池资源
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    //服务端业务处理
    private static class TimeServerHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ByteBuf buf = (ByteBuf) msg;
            byte[] req = new byte[buf.readableBytes()];
            buf.readBytes(req);
            String body = new String(req, "UTF-8");
            System.out.printf("The time server receive order : %s\n", body);
            String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body) ?
                    new Date(System.currentTimeMillis()).toString() : "BAD ORDER";
            ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());
            ctx.write(resp);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            ctx.close();
        }

        @Override
        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
        }
    }
}

```
### 分析TimeServer类
我们从`bind()`方法开始讲解。

首先，创建了两个`NioEventLoopGroup`实例。`NioEventLoopGroup`是个 **线程组**，
它包含了一组NIO线程，专门用于 **网络事件的处理**，实际上它们就是 **`Reactor`线程组**。这里创建两个的原因是 **一个
用于服务端接受客户端的连接，另一个用于进行`SocketChannel`的网络读写**。

后面，我们创建了`ServerBootstrap`对象，它是Netty用于启动NIO服务端的 **辅助启动类**，目的是降低服务端的开发复杂度。
`ServerBootstrap`的`group()`方法，将两个NIO线程组当作入参传递到`ServerBootstrap`中。接着设置创建的`Channel`为
`NioServerSocketChannel`，它的功能对应于JDK NIO类库中的`ServerSocketChannel`类。然后配置`NioServerSocketChannel`
的TCP参数，此处将它的`backlog`设置为`1024`，最后绑定I/O事件的处理类`ChildChannelHandler`，它的作用类似于
`Reactor`模式中的`handler`类。

服务端启动辅助类配置完成之后，调用它的`bind()`方法 **绑定监听端口**，随后，调用它的同步阻塞方法`sync()`
等待绑定操作完成。完成之后，Netty会返回一个`ChannelFuture`，它的功能类似于JDK的`java.util.concurrent.Future`，
**主要用于异步操作的通知回调**。

`f.channel().closeFuture().sync()`方法进行阻塞，**等待服务端链路关闭之后`main()`函数才退出**。

另外，NIO线程组的`shutdownGracefully()`进行优雅退出，它会 **释放跟`shutdownGracefully()`相关联的资源**。

### 分析TimeServerHandler类
`TimeServerHandler`继承自`ChannelInboundHandlerAdapter`，它用于 **对网络事件进行读写操作**，
**通常我们只需要关注`channelRead()`和`exceptionCaught()`方法**。

`channelRead()`方法中，将`msg`转换成Netty的`ByteBuf`对象。`ByteBuf`类似于JDK中的`java.nio.ByteBuffer`对象，
不过它提供了更加强大和灵活的功能。通过`ByteBuf`的`readableBytes()`方法可以 **获取缓冲区可读的字节数**，
根据可读的字节数创建`byte`数组，通过`ByteBuf`的`readBytes()`方法 **将缓冲区中的字节数组复制到新建的`byte`数组中**，
最后通过`new String(req,"UTF-8")`构造函数获取请求消息。这时对请求消息进行判断，如果是"QUERY TIME ORDER"
则创建应签消息，通过`ChannelHandlerContext`的`write()`方法异步发送应答消息给客户端。

我们发现在`channelReadComplete()`方法中，还调用了`ChannelHandlerContext`的`flush()`方法，
它的作用是 **将消息发送队列中的消息写入到`SocketChannel`中发送给对方**。从性能角度考虑，
为了防止频繁地唤醒`Selector`进行消息发送，Netty的`write()`方法并不直接将消息写入`SocketChannel`中，
**调用`write()`方法只是把待发送的消息放到发送缓冲数组中，再通过调用`flush()`方法，
将发送缓冲区中的消息全部写到`SocketChannel`中**。

当发生异常时，关闭`ChannelHandlerContext`，释放和`ChannelHandlerContext`相关联的句柄等资源。
