Netty服务端开发示例
=============================================================
Netty目前为止（2016－06－21），最新版本为4.1.1。前段时间出过5.0版，现在废弃了！
我们可以从 [Netty官网](http://netty.io/)下载开发包，这里就不多说了！

**注：netty可以all-in-one，也可以每个子包单独使用！！**

关于示例，我们使用Gradle构建示例项目：
```gradle
group 'com.fuhd'
version '1.0-SNAPSHOT'

apply plugin: 'java'
apply plugin: 'idea'

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    compile group: 'io.netty', name: 'netty-all', version: '4.1.1.Final'
    testCompile group: 'junit', name: 'junit', version: '4.11'
}

```

```java
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.util.Date;

public class TimeServer {

    public static void main(String[] args) throws Exception {
        int port = 8080;
        if (args != null && args.length > 0) {
            try {
                port = Integer.valueOf(args[0]);
            } catch (NumberFormatException e) {
                //采用默认值
            }
        }
        new TimeServer().bind(port);
    }

    public void bind(int port) throws Exception {
        //配置服务端的NIO线程组
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 1024)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new TimeServerHandler());
                        }
                    });
            //绑定端口，同步等待成功
            ChannelFuture f = b.bind(port).sync();
            //等待服务端监听端口关闭
            f.channel().closeFuture().sync();
        } finally {
            //优雅退出，释放线程池资源
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    //服务端业务处理
    private static class TimeServerHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ByteBuf buf = (ByteBuf) msg;
            byte[] req = new byte[buf.readableBytes()];
            buf.readBytes(req);
            String body = new String(req, "UTF-8");
            System.out.printf("The time server receive order : %s\n", body);
            String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body) ?
                    new Date(System.currentTimeMillis()).toString() : "BAD ORDER";
            ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());
            ctx.write(resp);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            ctx.close();
        }

        @Override
        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
            ctx.flush();
        }
    }
}
```
我们从`bind()`方法开始讲解。

首先，创建了两个`NioEventLoopGroup`实例。`NioEventLoopGroup`是个 **线程组**，
它包含了一组NIO线程，专门用于 **网络事件的处理**，实际上它们就是 **`Reactor`线程组**。这里创建两个的原因是 **一个
用于服务端接受客户端的连接，另一个用于进行`SocketChannel`的网络读写**。

后面，我们创建了`ServerBootstrap`对象，它是Netty用于启动NIO服务端的 **辅助启动类**，目的是降低服务端的开发复杂度。
`ServerBootstrap`的`group()`方法，将两个NIO线程组当作入参传递到`ServerBootstrap`中。接着设置创建的`Channel`为
`NioServerSocketChannel`，它的功能对应于JDK NIO类库中的`ServerSocketChannel`类。然后配置`NioServerSocketChannel`
的TCP参数，此处将它的`backlog`设置为`1024`，最后绑定I/O事件的处理类`ChildChannelHandler`，它的作用类似于
`Reactor`模式中的`handler`类。
