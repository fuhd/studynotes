TCP粘包-拆包
========================================================
当我们读取或者发送消息的时候，都需要考虑 **TCP底层的粘包-拆包机制**。TCP是个“流”协议，所谓流，
就是没有界限的一串数据。大家可以想想 **河里的流水**，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务
数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP
拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

### TCP粘包/拆包问题说明
假设客户端分别发送了两个数据包`Ｄ1`和`Ｄ2`给服务端，由于服务端一次读取到的字节数是不确定的，
故可能存在以下`4`种情况：
+ 服务端分两次读取到了两个独立的数据包，分别是`D1`和`D2`，没有粘包和拆包；
+ 服务端一次接收到了两个数据包，`D1`和`D2`粘合在一起，被称为TCP粘包；
+ 服务端分两次读取到了两个数据包，第一次读取到了完整的`D1`包和`D2`包的部分内容，第二次读取到了`D2`
包的剩余内容，这被称为TCP拆包；
+ 服务端分两次读取到了两个数据包，第一次读取到了`D1`包的部分内容`D1_1`，第二次读取到了`D1`包的剩余内容
`D1_2`和`D2`包的整包。

如果此时服务端TCP接收滑窗非常小，而数据包`D1`和`D2`比较大，**很有可能会发生第五种可能**，
即服务端分多次才能将`D1`和`D2`包接收完全，期间发生多次拆包。

### TCP粘包/拆包发生的原因
问题产生的原因有三个：
+ 应用程序`write`写入的字节大小大于套接口发送缓冲区大小；
+ 进行`MMS`大小的TCP分段；
+ 以太网帧的`payload`大于`MＴU`进行`IP`分片。

### 粘包问题的解决策略
由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层
的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：

1. **消息定长**，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
2. **在包尾增加回车换行符进行分割**，例如FTP协议；
3. **将消息分为消息头和消息体，消息头中包含表示消息总长度的字段**，通常设计思路为消息头的第一个字段使用`int32`
来表示消息的总长度；
4. **更复杂的应用层协议**；
