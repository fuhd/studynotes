4种I/O的对比
===================================================
### 异步非阻塞I/O
很多人喜欢将JDK1.4提供的NIO框架称为异步非阻塞I/O，但是，如果严格按照UNIX网络编程模型和JDK的实现进行区分，
实际上它只能被称为非阻塞I/O，不能叫异步非阻塞I/O。**在早期的JDK1.4和1.5 update10版本之前，JDK的`Selector`
基于`select/poll`模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。在JDK1.5 update10和Linux core2.6
以上版本，Sun优化了`Selector`的实现，它在底层使用`epoll`替换了`select/poll`**，上层的API并没有变化，
可以认为是JDK NIO的一次性能优化，但是它仍旧没有改变I/O的模型。

**由JDK1.7提供的NIO2.0，新增了异步的套接字通道，它是真正的异步I/O**，在异步I/O操作的时候可以传递信号变量，
当操作完成之后会回调相关的方法，**异步I/O也被称为AIO**。

### 多路利用器Selector
前面我们介绍过Java NIO的实现关键是多路复用I/O技术，**多路复用的核心就是通过`Selector`来轮询注册在其上的
`Channel`，当发现某个或者多个`Channel`处于就绪状态后，从阻塞状态返回就绪的`Channel`的选择键集合，
进行I/O操作**，由于多路复用器是NIO实现非阻塞I/O的关键，它又是主要通过`Selector`实现的，所以我们将`Selector`
翻译为多路复用器。

### 伪异步I/O
伪异步I/O的概念完全来源于实践。在JDK NIO编程没有流行之前，**为了解决Tomcat通信线程同步I/O导致业务线程
被挂住的问题**，大家想到了一个办法：**在通信线程和业务线程之间做个缓冲区，这个缓冲区用于隔离I/O线程和业务线程
间的直接访问，这样业务线程就不会被I/O线程阻塞**。而对于后端的业务侧来说，将消息或者Task放到线程池后就返回了，
它不再直接访问I/O线程或者进行I/O读写，这样也就不会被同步阻塞。

### 不同I/O模型对比

几种I/O模型的功能和特性对比：

|     | 同步阻塞I/O（BIO） | 伪异步I/O | 非阻塞I/O（NIO）| 异步I/O（AIO）|
| :---- | :---- | :---- | :---- | :---- |
| 客户端个数：I/O线程 | 1：1 | M：N（其中M可以大于N）| M:1（一个I/O线程处理多个客户端连接）|M:0（不需要启动额外的I/O线程，被动回调）|
| I/O类型（阻塞）| 阻塞I/O | 阻塞I/O | 非阻塞I/O | 非阻塞I/O |
| I/O类型（同步）| 同步I/O | 同步I/O | 同步I/O（I/O多路复用）| 异步I/O |
| API使用难度 | 简单 | 简单 | 非常复杂 | 复杂 |
| 调试难度 | 简单 | 简单 | 复杂 | 复杂 |
| 可靠性 | 非常差 | 差 | 高 | 高 |
| 吞吐量 | 低 | 中 | 高 | 高 |
