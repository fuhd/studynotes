业界主流的编解码框架
===========================================================
### Google的Protobuf
Protobuf全称Google Protocol Buffers，它由谷歌开源而来，在谷歌内部久经考验。它 **将数据结构以`.proto`
文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性**。

它的特点如下：
+ 结构化数据存储格式（XML，JSON等）；
+ 高效的编解码性能；
+ 语言无关，平台无关，扩展性好；
+ 官方支持Java，C++和Python三种语言；

首先我们来看下为什么不使用XML，尽管XML的可读性和可扩展性非常好，也非常适合描述数据结构，但是XML解析的
时间开销和XML为了可读性而牺牲的空间开销都非常大，因此不适合做高性能的通信协议。**Protobuf使用二进制编码，
在空间和性能上具有更大的优势**。

Protobuf另一个比较吸引人的地方就是它的 **数据描述文件和代码生成机制**，利用数据描述文件对数据结构进行
说明的优点如下：
+ 文本化的数据结构描述语言，可以实现语言和平台无关，特别适合异构系统间的集成；
+ 通过标识字段的顺序，可以实现协议的前向兼容；
+ 自动代码生成，不需要手工编写同样数据结构的C++和Java版本；
+ 方便后续的管理和维护。相比于代码，结构化的文档更容易管理和维护；

**Protobuf的编解码性能远远高于其他几种序列化框架的序列化和反序列化（Jackson，XStream，Serializable，
hessian2，hessian2压缩，Hession1）**。

### Facebook的Thrift
Thrift源于Facebook，在2007年Facebook将Thrift作为一个开源项目提交给Apache基金会。对于当时的Facebook来说，
**创造Thrift是为了解决Facebook各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性**，
因此Thrift可以支持多种程序语言，如：C++，C#，Cocoa，Erlang，Haskell，Java，Ocaml，Perl，PHP，
Python，Ruby和Smalltalk。

**在多种不同的语言之间通信，Thrift可以作为高性能的通信中间件使用，它支持数据（对象）序列化和多种类型的RPC服务。
Thrift适用于静态的数据交换，需要先确定好它的数据结构**，当数据结构发生变化时，必须重新编辑IDL文件，生成代码和编译，
这一点跟其他IDL工具相比可以视为是Thrift的弱项。**Thrift适用于搭建大型数据交换及存储的通用工具**，对于大型系统中的内部
数据传输，相对于JSON和XML在性能和传输大小上都有明显的优势。

Thrift主要由5部分组成：
+ **语言系统以及IDL编译器**：负责由用户给定的IDL文件生成相应语言的接口代码；
+ **TProtocol**：RPC的协议层，可以选择多种不同的对象序列化方式，如JSON和Binary；
+ **TTransport**：RPC的传输层，同样可以选择不同的传输层实现，如`socket`，`NIO`，`MemoryBuffer`等；
+ **TProcessor**：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口；
+ **Tserver**：聚合`TProtocol`，`TTransport`和`TProcessor`等对象；

**我们重点关注的是编解码框架，与之对应的就是`TProtocol`**。由于Thrift的RPC服务调用和编解码框架绑定在一起，
所以通常我们使用Thrift的时候会采取RPC框架的方式。但是，它的`TProtocol`编解码框架还是可以以类库的方式独立使用的。

与Protobuf比较类似的是，Thrift通过IDL描述接口和数据结构定义，它支持8种Java基本类型，`Map`，`Set`，`List`，
支持可选和必选定义，功能非常强大。因为可以定义数据结构中字段的顺序，所以它也可以支持协议的前向兼容。

Thrift支持三种比较典型的编解码方式：
+ 通用的二进制编解码；
+ 压缩二进制编解码；
+ 优化的可选字段压缩编解码；

由于支持二进制压缩编解码，Thrift的编解码性能表现也相当优异，远远超过Java序列化和RMI等。
