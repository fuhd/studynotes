Netty的核心组件
==========================================================
Netty的主要构件块：

+ **Channel**；
+ **回调**；
+ **Future**；
+ **事件和ChannelHandler**；

这些构建块代表了不同类型的构造：**资源、逻辑以及通知**。你的应用程序将使用它们来访问网络以及流经网络的数据；

### Channel
`Channel`是Java NIO的一个基本构造。它代表 **一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够
执行一个或者多个不同的I/O操作的程序组件）的开放连接**，如读操作和写操作。

### 回调
**一个回调其实就是一个方法**，一个指向已经被提供给另外一个方法的方法的引用。这使得后者（指接受回调的方法）可以在适当
的时候调用前者。回调在广泛的编程场景中都有应用，而且也是在 **操作完成后通知相关方最常见的方法之一**。

**Netty在内部使用了回调来处理事件；当一个回调被触发时，相关的事件可以被一个`ChannelHandler`的实现处理**。示例：
当一个新的连接已经被建立时，`ChannelHandler`的`channelActive()`回调方法将会被调用，并将打印出一条信息。
```java
public class ConnectHandler extends ChannelInboundHandlerAdapter {
    //当一个新的连接已经被建立时，channelActive(ChanelHandlerContext)将会被调用
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("Client " + ctx.channel().remoteAddress() + " connected");
    }
}
```

### Future
**`Future`提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；
它将在未来的某个时刻完成，并提供对其结果的访问**。

JDK预置了接口`java.util.concurrent.Future`，但是其所提供的实现，只允许手动检查对应的操作是否已经完成，
或者一直阻塞直到它完成。这是非常繁琐的（**java8已经改变**），所以Netty提供了它自己的实现————**`ChannelFuture`**，
用于在执行异步操作的时候使用。

**`ChannelFuture`** 提供了几种额外的方法，这些方法使得我们 **能够注册一个或者多个`ChannelFutureListener`实例**。
**监听器的回调方法`operationComplete()`，将会在对应的操作完成时被调用**（如果在`ChannelFutrueListener`添加
到`ChannelFuture`的时候，`ChannelFuture`已经完成，那么该`ChannelFutureListener`将会被直接地通知。）。
然后监听器可以判断该操作是成功地完成了还是出错了。如果是后者，我们可以检索产生的`Throwable`。简而言之，
**由`ChannelFutureListener`提供的通知机制消除了手动检查对应的操作完成情况**。

每个Netty的 **出站I/O操作都将返回一个`ChannelFuture`**；也就是说，**它们都不会阻塞**。正如我们前面所提到过的一样，
Netty完全是异步和事件驱动的。

下面示例展示了一个`ChannelFuture`作为一个I/O操作的一部分返回的例子。


