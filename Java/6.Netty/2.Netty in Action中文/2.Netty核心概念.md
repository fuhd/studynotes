Netty核心概念
================================================
这里，我们将讨论Netty的10个核心类，清楚了解他们的结构对使用Netty很有用。可能有一些不会再工作中用到，
但是也有一些很常用也很核心，你会遇到。
+ **`Bootstrap` 或者 `ServerBootstrap`**；
+ **`EventLoop`**；
+ **`EventLoopGroup`**；
+ **`ChannelPipeline`**；
+ **`Channel`**；
+ **`Future 或者 ChannelFuture`**；
+ **`ChannelInitializer`**；
+ **`ChannelHandler`**；

### Netty速成课
一个Netty程序开始于`Bootstrap`类，`Bootstrap`类是Netty提供的一个可以通过简单配置来 **设置或"引导"程序** 的一个很重要的类。
Netty中设计了 **Handlers** 来处理特定的 **"event"** 和设置Netty中的 **事件**，从而来处理多个协议和数据。
事件可以描述成一个非常通用的方法，因为你可以自定义一个handler,用来将`Object`转成`byte[]`或将`byte[]`转成`Object`；
也可以定义个handler处理抛出的异常。

你会经常编写一个实现`ChannelInboundHandler`的类，**`ChannelInboundHandler`是用来接收消息**，当有消息过来时，
你可以决定如何处理。当程序需要返回消息时可以在`ChannelInboundHandler`里 **write/flush** 数据。
**可以认为应用程序的业务逻辑都是在`ChannelInboundHandler`中来处理的**，业务逻辑的生命周期在`ChannelInboundHandler`中。

Netty连接客户端或绑定服务器需要知道如何发送或接收消息，这是通过不同类型的handlers来做的，多个Handlers是怎么配置的？
Netty提供了`ChannelInitializer`类用来配置Handlers。`ChannelInitializer`是通过`ChannelPipeline`来添加`ChannelHandler`的，
如发送和接收消息，这些Handlers将确定发的是什么消息。`ChannelInitializer`自身也是一个`ChannelHandler`，
在添加完其他的handlers之后会自动从`ChannelPipeline`中删除自己。

所有的Netty程序都是基于`ChannelPipeline`。`ChannelPipeline`和`EventLoop`和`EventLoopGroup`密切相关，
因为它们三个都和事件处理相关，所以这就是为什么它们处理IO的工作由EventLoop管理的原因。

**Netty中所有的IO操作都是异步执行的**，例如你连接一个主机默认是异步完成的；写入/发送消息也是同样是异步。
也就是说操作不会直接执行，而是会等一会执行，**因为你不知道返回的操作结果是成功还是失败，但是需要有检查是否成功的方法或者是注册监听来通知**；
Netty使用`Futures`和`ChannelFutures`来达到这种目的。**Future注册一个监听，当操作成功或失败时会通知**。
`ChannelFuture`封装的是一个操作的相关信息，操作被执行时会立刻返回`ChannelFuture`。

### Channels,Events和IO
**Netty是一个非阻塞、事件驱动的网络框架**。Netty实际上是使用多线程处理IO事件，对于熟悉多线程编程的读者可能会需要同步代码。
这样的方式不好，因为同步会影响程序的性能，Netty的设计保证程序处理事件不会有同步。

下图显示一个`EventLoopGroup`和一个`Channel`关联一个单一的`EventLoop`，Netty中的`EventLoopGroup`包含一个或多个`EventLoop`，
而`EventLoop`就是一个`Channel`执行实际工作的线程。`EventLoop`总是绑定一个单一的线程，在其生命周期内不会改变：

![EventLoopGroup](img/EventLoopGroup.png)

当注册一个`Channel`后，Netty将这个`Channel`绑定到一个`EventLoop`，在`Channel`的生命周期内总是被绑定到一个`EventLoop`。
**在Netty IO操作中，你的程序不需要同步，因为一个指定通道的所有IO始终由同一个线程来执行**。为了帮助理解，
下图显示了`EventLoop和EventLoopGroup`的关系：

![EventLoopGroup继承关系](img/EventLoopGroup继承关系.png)

`EventLoop`和`EventLoopGroup`的关联不是直观的，因为我们说过`EventLoopGroup`包含一个或多个`EventLoop`，
但是上面的图显示`EventLoop`是一个`EventLoopGroup`，这意味着你可以只使用一个特定的`EventLoop`。
