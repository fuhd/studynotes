你的第一个Netty应用
========================================================
Echo客户端和服务器之间的交互非常简单; 客户端建立一个连接后，它送一条或者多条消息到服务器，然后服务器再将该消息送回客户端。
虽然这个交互看起来不那么实用，但却是一个典型的客户端/服务器系统请求/响应交互过程的示例。

### 开发Echo服务器
所有的Netty服务器都需要：
+ 至少一个`ChannelHandler`，这个组件实现了服务器如何处理从客户端收到的数据（它的业务逻辑）；
+ `Bootstrapping`———这是配置服务器的启动代码。至少要做的是，它把服务器绑到一个可以监听连接请求的端口上。

在这一节剩下的部分，我们会描述Eche服务器的业务逻辑和`Bootstrapping`代码。

#### ChannelHandlers和业务逻辑
在第一章我们介绍了`Futures`和`callbacks`，和它们在事件驱动设计中的使用。我们还讨论了 **`ChannelHandler`，
它是一组接口的父类，这些接口的实现类接收并且响应事件通知。在Netty应用中，所有的数据处理逻辑都是包含在这些核心抽象的实现类里的**。

因为你的Echo服务器会响应收到的消息，所以它需要 **实现接口`ChannelInboundHandler`**，这个接口定义了 **作用于输入事件的方法**。
这个简单的应用只需要这个接口的一些方法，所以用 **子类`ChannelInboundHandlerAdapter`** 就足够了，
**这个子类提供了ChannelInboundHandler的缺省实现**。

我们感兴趣的是下面几个方法：
+ `channelRead()`————每次收到消息时被调用；
+ `channelReadComplete()`————用来通知handler，上一个`ChannelRead()`是被这批消息中的最后一个消息调用；
+ `exceptionCaught()`————在读操作异常被抛出时被调用；

Echo服务器的`ChannelHandler`实现是`EchoServerHandler`，如下清单所示：
```java
//这个注解表明一个ChannelHandler可以被多个Channel安全地共享
＠Sharable
public class EchoServerHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf in = (ByteBuf) msg;
    //把消息打印到控制台
    System.out.println("Server received: " + in.toString(CharsetUtil.UTF_8));
    //将收到的消息写入发送端，不刷新输出消息
    ctx.write(in);
  }
  @Override
  public void channelReadComplete(ChannelHandlerContext ctx) {
    //刷新挂起的数据到远端，然后关闭Channel
    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
  }
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    //打印异常堆栈跟踪信息
    cause.printStackTrace();
    //关闭这个Channel
    ctx.close();
  }
}
```
`ChannelInboundHandlerAdapter`有简明直接的API，每个方法都可以被重写(overridden)，钩挂到(hook into)event生命周期的适当时间点。
因为你需要处理所有收到的数据，所以你得重写`channelRead()`。在这个服务器里，你只要简单地把收到的消息送回远端。

重写`exceptionCaught()`让你可以对任何`Throwable`的子类型做出反应—在这里，你打印了这个异常然后关闭了这个连接。
一个更加复杂的应用也许会试着从异常中恢复，但是在这个例子中，仅仅把连接关闭就向远端发出了错误已经发生的信号。

##### 如果异常没有被捕获会发生什么？
每个`Channel`有一个对应的`ChannelPipeline`，这个`ChannelPipeline`有一串`ChannelHandler`实例。默认情况下，
一个handler会传递某个handler方法的调用到下一个handler。所以，如果在这个传递链中`exceptionCaught()`没有实现，
异常会一直走到`ChannelPipeline`的终点，然后被载入日志。因为这个原因，**你的应用应该提供至少一个实现了exceptionCaught()的handler**。

除了`ChannelInboundHandlerAdapter`，还有许多其他`ChannelHandler`子类和实现可以学习。我们会在第六和第七章详细讨论。
现在，请记住这几个要点：
+ ChannelHandlers被不同类型的events调用；
+ 应用程序通过实现或者扩展ChannelHandlers来钩挂到event的生命周期，并且提供定制的应用逻辑；
+ 在结构上，ChannelHandlers解耦你的业务逻辑和网络代码。这会简化开发过程，因为代码会随着需求的变化而变化；

#### Bootstrapping服务器
我们已经讨论了由`EchoServerHandler`实现的核心业务逻辑，现在我们可以来仔细看下服务器的boostrapping过程，这包括：
+ 绑定到一个端口，服务器在这个端口上监听并且接收新的连接请求；
+ 配置Channels，来通知`EchoServerHandler`实例收到的消息；

下面的代码清单是`EchoServer`类的完整代码：
```java
public class EchoServer {

  private final int port;

  public EchoServer(int port) {
    this.port = port;
  }

  public static void main(String[] args) throws Exception {
    if(args.length != 1) {
      System.err.println("Usage: " + EchoServer.class.getSimpleName() + " <port>");
    }
    //设端口值，如果端口输入参数非法，则抛出NumberFormatException
    int port = Integer.parseInt(args[0]);
    //调用服务器的start()方法
    new EchoServer(port).start();
  }

  public void start() throws Exception {
    final EchoServerHandler serverHandler = new EchoServerHandler();
    //创建EventLoopGroup，注(1)
    EventLoopGroup group = new NioEventLoopGroup();
    try {
      //创建ServerBootstrap，注(2)
      ServerBootstrap b = new ServerBootstrap();
      b.group(group)
        .channel(NioServerSocketChannel.class)                      //指定使用一个NIO传输Channel，注(3)
        .localAddress(new InetSocketAddress(port))                  //用指定的端口设置socket地址，注(4)
        .childHandler(new ChannelInitializer<SocketChannel>() {
          @Override
          public void initChannel(SocketChannel ch) throws Exception {
            //在Channel的ChannelPipeline中加入EchoServerHandler，注(5)
            //EchoServerHandler是@sharable的，所以我们可以一直用同一个实例
            ch.pipeline().addLast(serverHandler);
          }
        });
        //异步地绑定服务器，sync()一直等到绑定完成，注(6)
        ChannelFuture f = b.bind().sync();
        //获得这个Channel的closeFuture，阻塞当前线程直到关闭操作完成，注(7)
        f.channel().closeFuture().sync();
    } finally {
      //关闭EventLoopGroup，释放所有资源，注(8)
      group.shutdownGracefully().sync();
    }
  }
}
```
在注(2)中，你创建了一个`ServerBootstrap`实例。因为你在用NIO传输方式，你指定使用注(2)`NioEventLoopGroup`
来接收和处理新的连接，使用注(3)`NioServerSocketChannel`做为channel类型。注(4)在你用已选的端口来配置
`InetSocketAddress`的本地地址之后，服务器就会绑定到这个地址，来监听新的连接请求。

在注(5)中，你用了一个特殊的类`ChannelInitializer`，这是关键。当一个新的连接被接收时，一个新的子`Channel`
会被创建，然后这个`ChannelInitializer`会把一个`EchoServerHandler`实例加到这个`Channel`的`ChannelPipeline`中。
像我们之前解释的那样，这个handler会接收有关输入消息的通知。

虽然NIO是有扩展性的，它的合理配置，特别是涉及到多线程时，并不容易，而Netty的设计封装了大部分的复杂性。
我们会在第三章更详细地讨论相关的抽象（`EventLoopGroup`，`SocketChannel`，`ChannelInitializer`）。

接下来注(6)，你绑定服务器，然后一直等到绑定完成（调用`sync()`让当前线程一直阻塞）。在注(7)，
这个应用程序会一直等到这个服务器的`Channel`关闭（因为你的`Channel`的`closeFuture`上调用了`sync()`）。
注(8)然后你可以关闭`EventLoopGroup`，释放所有资源，包括创建的线程。

以下是Bootstrapping中的必需步骤：
+ 创建一个`ServerBootstrap`实例来启动和绑定服务器；
+ 创建并且分配一个`NioEventLoopgroup`实例来处理event，比如接受新的连接和读/写数据；
+ 指定本地`InetSocketAddress`到服务器绑定的端口；
+ 用一个`EchoServerHandler`实例来初始化每个新的`Channel`；
+ 调用`ServerBootstrap.bind()`来绑定服务器；

### 开发Echo客户端
这里，Echo客户端会：

1. 连接到服务器；
2. 送出一条或者多条消息；
3. 对每条消息，等待并且从服务器收回一条同样的消息；
4. 关闭连接；

开发客户端包括你在服务器端看到的两部分代码：**业务逻辑** 和 **Bootstrapping**。

#### 用ChannelHandlers使用客户端逻辑
和服务器一样，客户端会有一个`ChannelInboundHandler`来处理数据。这个例子中，你会扩展`SimpleChannelInbondHandler`类来处理所有的任务，
如下面代码所示。这需要重写下面这些方法：
+ `channelActive()`————和服务器的连接建立起来后被调用；
+ `channelRead0()`————从服务器收到一条消息时被调用；
+ `exceptionCaught()`————处理过程中异常发生时被调用；

```java
//标记这个类的实例可以被多个channel共享
@Sharable
public class EchoClientHandler extends SimpleChannelInbondHandler<ByteBuf> {
  @Override
  public void channelActive(ChannelHandlerContext ctx) {
    //当收到连接成功的通知，发送一条消息
    ctx.writeAndFlush(Unpooled.copiedBuffer("Netty rocks!", CharsetUtil.UTF_8));
  }
  @Override
  public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {
    //打印收到的消息到日志
    System.out.println("Client received: " + in.toString(CharsetUtil.UTF_8));
  }
  //异常发生时，记录错误日志，关闭Channel
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    cause.printStackTrace();
    ctx.close();
  }
}
```
首先你重写了`channelActive()`，在一个连接建立的时候被调用。这保证了可以尽快地写一些数据到服务器，
在这个例子中，是一个包含“Netty rocks!”字符串的字节缓冲区。

然后你重写了`channelRead0()`方法。每当收到数据时，这个方法会被调用。**注意服务器发送的数据可能被分块收到**。
就是说，如果服务器送出5字节，不能保证所有的5字节会被一次性收到。即使对这么小的数据量，`channelRead0()`
方法可能会被调用两次，第一次用一个`ByteBuf`（Netty的字节容器）存放3字节，第二次用一个`ByteBuf`存放2字节。
作为一个面向流的协议，TCP会保证字节会按它们从服务器发出的顺序被收到。

你重写的第三个方法是`exceptionCaught()`。就像在`EchoServerHandler`中，`Throwable`被载入日志并且
channel被关闭，在这个例子中channel被关闭导致和服务器连接的终止。

##### SimpleChannelInboundHandler对比ChannelInboundHandler
你也许想知道为什么我们在客户端用了`SimpleChannelInboundHandler`，而不是`EchoServerHandler`中用的
`ChannelInboundHandlerAdapter`。这和两个因素有关：**业务逻辑如何处理消息，以及Netty如何管理资源**。

**在客户端，当`channelRead0()`完成时，你收到输入消息并且已经处理完成。当这个方法返回时，`SimpleChannelInboundHandler`
会负责释放用于存放消息的`ByteBuf`的内存引用**。

**在`EchoServerHandler`中，你仍然要把输入的消息送回给发送端，而`write()`操作是异步的，直到`channelRead()`
返回可能都没有完成。所以，`EchoServerHandler`扩展了`ChannelInboundHandlerAdapter`，不会在`channelRead()`
返回的时候释放消息的内存引用**。

在`writeAndFlush()`被调用时，这个消息的内存引用会在`EchoServerHandler`的`channelReadComplete()`方法中被释放。

#### Bootstrapping客户端
你会在下一个示例代码中看到，bootstrapping一个客户端和bootstrapping一个服务器类似，不同于 **服务器绑定到一个监听端口**，
**客户端用主机和端口参数来连接到一个远程地址**，这里就是指Echo服务器。
```java
public class EchoClient {

  private final String host;
  private final int port;

  public EchoClient(String host, int port) {
    this.host = host;
    this.port = port;
  }

  public void start() throws Exception {
    EventLoopGroup group = new NioEventLoopGroup();
    try {
      Bootstrap b = new Bootstrap();        //创建客户端的Bootstrap
      b.group(group)                        //指定EventLoopGroup来处理客户端事件，需要EventLoopGroup的NIO实现
        .channel(NioServerSocketChannel.class) //用于NIO传输的Channel类型
        .remoteAddress(new InetSocketAddress(host, port)) //设置服务器的InetSocketAddress
        .handler(new ChannelInitializer<SocketChannel>() {  
          @Override
          public void initChannel(SocketChannel ch) throws Exception {
            //当一个Channel创建时，把一个EchoClientHandler加入它的pipeline中
            ch.pipeline().addLast(new EchoClientHandler());
          }
        });
      //连接到远端，一直等到连接完成
      ChannelFuture f = b.connect().sync();
      //一直阻塞到Channel关闭
      f.channel().closeFuture().sync();
    } finally {
      //关闭连接池，释放所有资源，？？？也是异常的，同步等待结束？？
      group.shutdownGracefully().sync();
    }
  }

  public static void main(String[] args) throws Exception{
    if(args.length != 2) {
      System.err.println("Usage: " + EchoClient.class.getSimpleName() + " <host> <port>");
      return;
    }
    String host = args[0];
    int port = Integer.parseInt(args[1]);
    new EchoClient(host, port).start();
  }
}
```
跟之前一样，使用的是NIO传输方式。注意，你在客户端和服务器中可以用不同的传输方式；比如，服务器端用NIO，
在客户端用OIO.

让我们回顾下这一小节中的关键点：
+ 创建一个`Bootstrap`实例来初始化客户端；
+ 分配一个`NioEventLoopgroup`实例来处理事件，包括创建新的连接和处理输入输出数据；
+ 创建一个`InetSocketAddress`用于连接到服务器；
+ 当连接建立，一个`EchoClientHandler`会被装入`pipeline`；
+ 所有东西都创建完毕后，调用`Bootstrap.connet()`连接到远端；
