你的第一个Netty应用
========================================================
Echo客户端和服务器之间的交互非常简单; 客户端建立一个连接后，它送一条或者多条消息到服务器，然后服务器再将该消息送回客户端。
虽然这个交互看起来不那么实用，但却是一个典型的客户端/服务器系统请求-响应交互过程的示例。

### 开发Echo服务器
所有的Netty服务器都需要：
+ 至少一个`ChannelHandler`，这个组件实现了服务器如何处理从客户端收到的数据（它的业务逻辑）；
+ `Bootstrapping`———这是配置服务器的启动代码。至少要做的是，它把服务器绑到一个可以监听连接请求的端口上。

在这一节剩下的部分，我们会描述Eche服务器的业务逻辑和`Bootstrapping`代码。

#### ChannelHandlers和业务逻辑
在第一章我们介绍了`Futures`和`callbacks`，和它们在事件驱动设计中的使用。我们还讨论了 **`ChannelHandler`，
它是一组接口的父类，这些接口的实现类接收并且响应事件通知。在Netty应用中，所有的数据处理逻辑都是包含在这些核心抽象的实现类里的**。

因为你的Echo服务器会响应收到的消息，所以它需要 **实现接口`ChannelInboundHandler`**，这个接口定义了 **作用于输入事件的方法**。
这个简单的应用只需要这个接口的一些方法，所以用 **子类`ChannelInboundHandlerAdapter`** 就足够了，
**这个子类提供了ChannelInboundHandler的缺省实现**。

我们感兴趣的是下面几个方法：
+ `channelRead()`————每次收到消息时被调用；
+ `channelReadComplete()`————用来通知handler，上一个`ChannelRead()`是被这批消息中的最后一个消息调用；
+ `exceptionCaught()`————在读操作异常被抛出时被调用；

Echo服务器的`ChannelHandler`实现是`EchoServerHandler`，如下清单所示：
```java
//这个注解表明一个ChannelHandler可以被多个Channel安全地共享
＠Sharable
public class EchoServerHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf in = (ByteBuf) msg;
    //把消息打印到控制台
    System.out.println("Server received: " + in.toString(CharsetUtil.UTF_8));
    //将收到的消息写入发送端，不刷新输出消息
    ctx.write(in);
  }
  @Override
  public void channelReadComplete(ChannelHandlerContext ctx) {
    //刷新挂起的数据到远端，然后关闭Channel
    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
  }
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    //打印异常堆栈跟踪信息
    cause.printStackTrace();
    //关闭这个Channel
    ctx.close();
  }
}
```
`ChannelInboundHandlerAdapter`有简明直接的API，每个方法都可以被重写(overridden)，钩挂到(hook into)event生命周期的适当时间点。
因为你需要处理所有收到的数据，所以你得重写`channelRead()`。在这个服务器里，你只要简单地把收到的消息送回远端。

重写`exceptionCaught()`让你可以对任何`Throwable`的子类型做出反应—在这里，你打印了这个异常然后关闭了这个连接。
一个更加复杂的应用也许会试着从异常中恢复，但是在这个例子中，仅仅把连接关闭就向远端发出了错误已经发生的信号。

##### 如果异常没有被捕获会发生什么？
每个`Channel`有一个对应的`ChannelPipeline`，这个`ChannelPipeline`有一串`ChannelHandler`实例。默认情况下，
一个handler会传递某个handler方法的调用到下一个handler。所以，如果在这个传递链中`exceptionCaught()`没有实现，
异常会一直走到`ChannelPipeline`的终点，然后被载入日志。因为这个原因，**你的应用应该提供至少一个实现了exceptionCaught()的handler**。

除了`ChannelInboundHandlerAdapter`，还有许多其他`ChannelHandler`子类和实现可以学习。我们会在第六和第七章详细讨论。
现在，请记住这几个要点：
+ ChannelHandlers被不同类型的events调用；
+ 应用程序通过实现或者扩展ChannelHandlers来钩挂到event的生命周期，并且提供定制的应用逻辑；
+ 在结构上，ChannelHandlers解耦你的业务逻辑和网络代码。这会简化开发过程，因为代码会随着需求的变化而变化；

#### Bootstrapping服务器
我们已经讨论了由`EchoServerHandler`实现的核心业务逻辑，现在我们可以来仔细看下服务器的boostrapping过程，这包括：
+ 绑定到一个端口，服务器在这个端口上监听并且接收新的连接请求；
+ 配置Channels，来通知`EchoServerHandler`实例收到的消息；

下面的代码清单是`EchoServer`类的完整代码：
```java
public class EchoServer {

  private final int port;

  public EchoServer(int port) {
    this.port = port;
  }

  public static void main(String[] args) throws Exception {
    if(args.length != 1) {
      System.err.println("Usage: " + EchoServer.class.getSimpleName() + " <port>");
    }
    //设端口值，如果端口输入参数非法，则抛出NumberFormatException
    int port = Integer.parseInt(args[0]);
    //调用服务器的start()方法
    new EchoServer(port).start();
  }

  public void start() throws Exception {
    final EchoServerHandler serverHandler = new EchoServerHandler();
    //创建EventLoopGroup，注(1)
    EventLoopGroup group = new NioEventLoopGroup();
    try {
      //创建ServerBootstrap，注(2)
      ServerBootstrap b = new ServerBootstrap();
      b.group(group)
        .channel(NioServerSocketChannel.class)                      //指定使用一个NIO传输Channel，注(3)
        .localAddress(new InetSocketAddress(port))                  //用指定的端口设置socket地址，注(4)
        .childHandler(new ChannelInitializer<SocketChannel>() {
          @Override
          public void initChannel(SocketChannel ch) throws Exception {
            //在Channel的ChannelPipeline中加入EchoServerHandler，注(5)
            //EchoServerHandler是@sharable的，所以我们可以一直用同一个实例
            ch.pipeline().addLast(serverHandler);
          }
        });
        //异步地绑定服务器，sync()一直等到绑定完成，注(6)
        ChannelFuture f = b.bind().sync();
        //获得这个Channel的closeFuture，阻塞当前线程直到关闭操作完成，注(7)
        f.channel().closeFuture().sync();
    } finally {
      //关闭EventLoopGroup，释放所有资源，注(8)
      group.shutdownGracefully().sync();
    }
  }
}
```
在注(2)中，你创建了一个`ServerBootstrap`实例。因为你在用NIO传输方式，你指定使用注(2)`NioEventLoopGroup`
来接收和处理新的连接，使用注(3)`NioServerSocketChannel`做为channel类型。注(4)在你用已选的端口来配置
`InetSocketAddress`的本地地址之后，服务器就会绑定到这个地址，来监听新的连接请求。

在注(5)中，你用了一个特殊的类`ChannelInitializer`，这是关键。当一个新的连接被接收时，一个新的子`Channel`
会被创建，然后这个`ChannelInitializer`会把一个`EchoServerHandler`实例加到这个`Channel`的`ChannelPipeline`中。
像我们之前解释的那样，这个handler会接收有关输入消息的通知。

虽然NIO是有扩展性的，它的合理配置，特别是涉及到多线程时，并不容易，而Netty的设计封装了大部分的复杂性。
我们会在第三章更详细地讨论相关的抽象（`EventLoopGroup`，`SocketChannel`，`ChannelInitializer`）。

接下来注(6)，你绑定服务器，然后一直等到绑定完成（调用`sync()`让当前线程一直阻塞）。在注(7)，
这个应用程序会一直等到这个服务器的`Channel`关闭（因为你的`Channel`的`closeFuture`上调用了`sync()`）。
注(8)然后你可以关闭`EventLoopGroup`，释放所有资源，包括创建的线程。

以下是Bootstrapping中的必需步骤：
+ 创建一个`ServerBootstrap`实例来启动和绑定服务器；
+ 创建并且分配一个`NioEventLoopgroup`实例来处理event，比如接受新的连接和读/写数据；
+ 指定本地`InetSocketAddress`到服务器绑定的端口；
+ 用一个`EchoServerHandler`实例来初始化每个新的`Channel`；
+ 调用`ServerBootstrap.bind()`来绑定服务器；
