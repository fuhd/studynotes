Netty的核心组件
=====================================================
Netty的主要组成模块：
+ **Channels**；
+ **Callbacks**；
+ **Futures**；
+ **Events和handlers**；

### Channels
一个`Channel`是`Java NIO`的一个基本抽象。它代表了：**一个连接到比如硬件设备，文件，网络socket等实体的开放连接，
或者是一个能够完成一种或多种譬如读或写等不同I/O操作的程序**。

目前，**可以把一个`Channel`想象成一个输入和输出数据的媒介**。同样地，它可以被打开或者关闭，连接或者断开。

### Callbacks
一个`callback`就是一个方法，一个提供给另一个的方法的引用。这让另一个方法可以在适当的时候回过头来调用这个`callback`方法。
`Callbacks`在很多编程情形中被广泛使用，是 **用于通知相关方** 某个操作已经完成最常用的方法之一。

Netty在处理事件时内部使用了`callback`；当一个`callback`被触发，事件可以被`ChannelHandler`的接口实现处理。
下面的代码清单是这样一个例子：当一个新的连接建立后，`ChannelHandler`的`callback`方法`channelActive()`会被调用，
然后打印一条消息。
```java
public class ConnectHandler extends ChannelInboundHandlerAdapter {
  //当一个新的连接建立时，channelActive(ChannelHandlerContext ctx)被调用
  @Override
  public void channelActive(ChannelHandlerContext ctx) throws Exception {
    System.out.println("Client " + ctx.channel().remoteAddress() + " connected");
  }
}
```

### Future
一个`Future`提供了另一个当操作完成时如何通知应用的方法。**`Future`对象充当了一个存放异步操作结果的占位符(placeholder)角色；
它会在将来某个时间完成并且提供对操作结果的访问**。

JDK搭载了接口`java.util.concurrent.Future`, 但是提供的接口实现只允许你手动检查操作是否已经完成，
或者就一直阻塞到操作完成。这非常麻烦，所以 **Netty提供了它自己的`ChannelFuture`实现，用于执行异步操作**。

`ChannelFuture`提供了额外的方法让我们 **可以注册一个或者多个`ChannelFutureListener`实例**。
监听者的callback方法 **`operationComplete()`在操作完成时被调用**。然后监听者可以查看这个操作是否成功完成，还是出错了。
如果出错了，我们可以从`future`获取`Throwable`。简单来说，**`ChannelFutureListener`提供的通知机制免去了手动检查操作完成情况的麻烦**。

每个Netty输出的I/O操作都会返回一个`ChannelFuture`；就是说，没有一个操作是阻塞的。就像我们之前所说的，
**Netty由下至上都是异步和事件驱动的**。

下面示例中，一个`ChannelFuture`做为一个I/O操作的一部分被返回。这里，`connect()`会无阻塞地直接返回，
调用会在后台完成。什么时候会完成取决于多个因素，但是这个担心已经从代码里被抽离(abstract away)出来了。
因为这个线程没有阻塞在等待这个操作完成，它可以同时做其他事情，因此更有效率地利用资源。
```java
Channel channel = ......;
//Does not block
//异步连接到远端
ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1", 25));
```
下面示例代码展示了如何利用`ChannelFutureListener`。首先你连接到一个远端。
然后用`connect()`返回的`ChannelFuture`注册一个新的`ChannelFutureListener`。当监听器被通知连接建立时，
检查状态(1：注释位置，解释用)。如果这个操作成功，你写数据到这个`Channel`。否则你从`ChannelFuture`中读取`Throwable`。
