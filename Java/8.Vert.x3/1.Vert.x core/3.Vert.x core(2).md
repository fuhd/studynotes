Vert.x core(2)
====================================

这一节主要讲述Verticles。

vert.x附带一个简单，可扩展，像actor一样部署的并发模型工具`Verticles`，你可以使用你自己写的。
这个模型是完全可选的，如果你不想使用它，vert.x不强迫你使用这种方式创建你的应用程序。

这个模型并不要求是一个严格actor模型的实现，但它们确实有相似之处，特别是关注并发性，伸缩性和部署。
`Verticles`代码块由vert.x部署和运行。

一个应用程序通常由同时运行在同一个vert.x实例中的多个`Verticle`实例组成。不同的`Verticle`实例相互
通信是通过在 **事件总线**（event bus）上发送消息实现。

### 写Verticles
Verticle类必须实现`Verticle`接口。如果你喜欢，你可以直接实现它，但通常使用更简单的方法就是继承
抽象类`AbstractVerticle`。下面是一个`Verticle`示例：
```java
public class MyVerticle extends AbstractVerticle {
  //Called when verticle is deployed
  public void start()  {
  }
  //Optional - called when verticle is undeployed
  public void stop() {
  }
}
```
通常情况下，你要重写`start`方法。当vert.x部署Verticles时，`start`将被调用，`start`方法执行完成的时候，
verticle就正式开始工作。你也可以选择重写`stop`方法（可选的），当verticle卸载时，vert.x将调用它。`stop`
方法完成时，verticle被认为正式停止工作。

### 异步启动或停止verticle
因为你的Verticle启动需要一些时间，所以有的时候你不想等待，你想在这段时间做些其它事情。例如，你想在
Verticle启动阶段（比如在调用`start`方法完成之前），部署一些其它的Verticles。在`start`方法完成
之前，你不能阻塞其它Verticles的部署，要不然就打破了“黄金规则”。

那我们要怎么做呢？一条路就是 **实现异步的start方法** 。该版本的`start`方法需要一个`Future`作为参数。
当该方法返回时，Verticle并 **不表示** 已经部署完成。一段时间后，你需要做的事情都完成后（比如启动其它
Verticles），你能在`Future`上完成调用，示例：
```java
public class MyVerticle extends AbstractVerticle {
  public void start(Future<Void> startFuture) {
    //Now deploy some other verticle:
    vertx.deployVerticle("com.foo.OtherVerticle", res  -> {
      if (res.succeeded()) {
        startFuture.complete();
      } else {
        startFuture.fail();
      }
    });
  }
}
```
同样，也有一个异步版本的stop方法。如果你想做一些需要时间的Verticle清理，你可以使用它，示例：
```java
public class MyVerticle extends AbstractVerticle {
  public void start() {
    //Do something
  }
  public void stop(Future<Void> stopFuture) {
    obj.doSomethingThatTakesTime(res -> {
      if (res.succeeded()) {
        stopFuture.complete();
      } else {
        stopFuture.fail();
      }
    });
  }
}
```
提示：在Verticle的`stop`方法里，你不需要手工卸载`child Verticle`。当Verticle卸载时，会自动
卸载`child Verticle`。

### Verticle类型
这里有三个不同的Verticle类型：
+ **标准Verticles**：这是最常见的，最有用的类型。它们总是由一个事件循环线程来执行。
+ **Worker Verticles**：它运行使用worker pool里的一个线程，一个实例同一时刻只会被一个线程执行。
+ **多线程的Worker Verticles**：它运行使用worker pool里的一个线程，一个实例能被多个线程并发地执行。

### 标准Verticles
当他们被创建并且其`start`方法由事件轮询调用时，标准Verticles被分配给一个事件轮询线程。当在一个事件轮询
的核心API上通过任何方法调用handler（处理器）时，vert.x将保证这些处理器 **被相同的事件轮询执行（分配的事件轮询线程？？？）** 。

这意味着在你的`Verticle`实例中，我们能保证所有的代码总是在相同的事件轮询上执行（只要你不创建自己的线程
去调用它！！）。**自己注：是不是意思是说一个`Verticle`示例会绑定一个固定的事件轮询上？？？**

这意味着你可以在你的应用程序中以单线程的方式写所有代码，不再同步的担心，避免了许多竞争条件和死锁，特别是
传统多线程应用程序开发如此盛行的现在。

### Worker verticles
Worker verticles挺像标准Verticles，但它不是由事件轮询执行，而是由vert.x的worker线程池中的线程执行。
Worker verticles被设计用来处理阻塞代码，因为他们不会阻塞任何事件轮询。

如果你不想使用Worker verticle来运行阻塞代码，你也可以在一个事件轮询上直接内联运行阻塞代码（见前面的运行阻塞代码示例！）。
如果你想发布一个Worker verticle，你需要调用`setWorker`方法，示例：
```java
//设置为true，表示是Worker verticle线程
DeploymentOptions options = new DeploymentOptions().setWorker(true);
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);
```
Worker verticle实例绝不会被vert.x并发调用执行，但能在不同的时间由不同线程调用执行。
### 多线程Worker verticles
一个多线程Worker verticles有点像常规的worker verticle，但它能被多线程并发地执行。

注意：多线程Worker verticles是一个高级特性，大多数应用程序不需要他们。因为这些Verticles的并发，
你必须非常小心地在多线程程序中使用标准的java技术来保证一致性状态。

### 以编程的方式部署Verticles
你可以使用`deployVerticle`方法之一来部署一个Verticle。示例：
```java
Verticle myVerticle = new MyVerticle();
vertx.deployVerticle(myVerticle);
```
你也能通过指定verticle的名字来部署一个Verticle。verticle名字是用来查找指定的`VerticleFactory`，
而`VerticleFactory`是用来实例化一个真实的verticle实例。不同的Verticle工厂用于不同的语言里，
进行Verticle的实例化，示例：
```java
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle");
//Deploy a avaScript verticle
vertx.deployVerticle("verticles/myverticle.js");
//Deploy a Ruby verticle verticle
vertx.deployVerticle("verticles/my_verticle.rb");
```
### 映射Verticle名字到Verticle工厂的规则
使用名称来部署Verticle的时候，这个名字用来选择一个实际的Verticle工厂实例化Verticle。Verticle名字
能有一个前缀（这是一个字符串），后跟随一个冒号，目前用于查找Verticle工厂。例如：
```
js:foo.js                                           //Use the JavaScript verticle factory
groovy:com.mycompany.SomeGroovyCompiledVerticle     //Use the Groovy verticle factory
service:com.mycompany:myorderservice                //Uses the service verticle factory
```
如果没有前缀，vert.x将通过后缀来查找工厂，示例：
```
foo.js                                  //Will also use the JavaScript verticle factory
SomeScript.groovy                       //Will use the Groovy verticle factory
```
如果没有前缀或后缀，vert.x将把它当作Java的全类名进行实例化。

###　Verticle工厂在哪里？
大多数Ｖerticle工厂从类路径加载，Vert.x启动时注册。你也可以用`registerVerticleFactory`和
`unregisterVerticleFactory`注册或取消注册Verticle工厂。

### 等待Verticle部署完成
Verticle部署是异步的，调用部署返回后，可以用一些时间来完成。如果你想在部署完成时得到一个通知，
你可以指定一个处理完成执行程序。示例：
```java
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", res -> {
  if (res.succeeded()) {
    System.out.println("Deployment id is: " + res.result());
  } else {
    System.out.println("Deployment failed!");
  }
});
```
如果部署成功，处理完成执行程序将提供一个包含部署ID字符串的结果。如果你想取消部署，这个部署ID后面还能用到。

### 取消部署Verticle
部署能通过`undeploy`方法来取消。取消部署本身是异步的，所以如果你想在取消部署完成时能得到通知，你可以
指定一个处理完成执行程序。示例如下：
```java
vertx.undeploy(deploymentID, res -> {
  if (res.succeeded()) {
    System.out.println("Undeployed ok");
  } else {
    System.out.println("Undeploy failed!");
  }
});
```
### 指定Verticle实例的数目
使用Verticle名字来部署Verticle时，你能指定你想部署的Verticle实例的数目：
```java
DeploymentOptions options = new DeploymentOptions().setInstances(16);
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);
```
这样跨多核伸缩是比较容易的。示例，你可能有一个web服务的Verticle要部署在你多核的机器上，你想要部署多个
实例来充分利用所有的CUP核心。

### 配置Verticle
部署时，可以传递一个JSON对象的配置给Verticle：
```java
JsonObject config = new JsonObject().put("name", "tim").put("directory", "/blah");
DeploymentOptions options = new DeploymentOptions().setConfig(config);
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);
```
通过`Context`对象或直接使用`config`方法让配置变得可用。另外，配置返回一个JSON对象，所以你可以像下面一样检索数据：
```java
//config()是DeploymentOptions的方法
System.out.println("Configuration: " + config().getString("name"));
```
### 在Verticle里访问环境变量
环境变量与系统属性是通过JAVA API可以访问的：
```java
System.getProperty("prop");
System.getenv("HOME");
```
### Verticle组隔离
默认情况下，vert.x有一个扁平的`classpath`。即，vert.x使用当前类加载器部署Verticle，根本不用再
创建一个新的。多数情况下，这是最简单，清晰，稳健的做法。

然而，某些情况下，你想在你的应用程序中部署与其它隔离的Verticle。例如这样一种情况，在同一个vert.x实例中，
**以相同的类名部署两个不同版本的Verticle**，或者你在同一个jar包的不同版本中使用两个不同的Verticle。

当使用一个隔离组时，你要提供一个你想隔离的类名列表给`setIsolatedClasses`方法（一个全限定类名，就像
`com.mycompany.myproject.engine.myclass`）或者是一个匹配一个包中所有类的通配符（例如，
`com.mycompany.myproject.*`）。

请注意，只有匹配的类被隔离，其它的任何类都有当前类加载器加载。

如果你想加载的类或资源不在目前的主类路径（classpath）里，你可以通过`setExtraClasspath`方法添加额外
的类路径（**慎重使用些功能**）。下面有一个示例，使用隔离组来隔离Verticle部署：
```java
DeploymentOptions options = new DeploymentOptions().setIsolationGroup("mygroup");
options.setIsolatedClasses(Arrays.asList("com.mycompany.myverticle.*",
    "com.mycompany.somepkg.SomeClass", "org.somelibrary.*"));
vertx.deployVerticle("com.mycompany.myverticle.VerticleClass", options);
```
