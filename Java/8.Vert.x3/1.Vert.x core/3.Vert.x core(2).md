Vert.x core(2)
====================================

这一节主要讲述Verticles。

vert.x附带一个简单，可扩展，像actor一样部署的并发模型工具`Verticles`，你可以使用你自己写的。
这个模型是完全可选的，如果你不想使用它，vert.x不强迫你使用这种方式创建你的应用程序。

这个模型并不要求是一个严格actor模型的实现，但它们确实有相似之处，特别是关注并发性，伸缩性和部署。
`Verticles`代码块由vert.x部署和运行。

一个应用程序通常由同时运行在同一个vert.x实例中的多个`Verticle`实例组成。不同的`Verticle`实例相互
通信是通过在 **事件总线**（event bus）上发送消息实现。

### 写Verticles
Verticle类必须实现`Verticle`接口。如果你喜欢，你可以直接实现它，但通常使用更简单的方法就是继承
抽象类`AbstractVerticle`。下面是一个`Verticle`示例：
```java
public class MyVerticle extends AbstractVerticle {
  //Called when verticle is deployed
  public void start()  {
  }
  //Optional - called when verticle is undeployed
  public void stop() {
  }
}
```
通常情况下，你要重写`start`方法。当vert.x部署Verticles时，`start`将被调用，`start`方法执行完成的时候，
verticle就正式开始工作。你也可以选择重写`stop`方法（可选的），当verticle卸载时，vert.x将调用它。`stop`
方法完成时，verticle被认为正式停止工作。

### 异步启动或停止verticle
因为你的Verticle启动需要一些时间，所以有的时候你不想等待，你想在这段时间做些其它事情。例如，你想在
Verticle启动阶段（比如在调用`start`方法完成之前），部署一些其它的Verticles。在`start`方法完成
之前，你不能阻塞其它Verticles的部署，要不然就打破了“黄金规则”。

那我们要怎么做呢？一条路就是 **实现异步的start方法** 。该版本的`start`方法需要一个`Future`作为参数。
当该方法返回时，Verticle并 **不表示** 已经部署完成。一段时间后，你需要做的事情都完成后（比如启动其它
Verticles），你能在`Future`上完成调用，示例：
```java
public class MyVerticle extends AbstractVerticle {
  public void start(Future<Void> startFuture) {
    //Now deploy some other verticle:
    vertx.deployVerticle("com.foo.OtherVerticle", res  -> {
      if (res.succeeded()) {
        startFuture.complete();
      } else {
        startFuture.fail();
      }
    });
  }
}
```
同样，也有一个异步版本的stop方法。如果你想做一些需要时间的Verticle清理，你可以使用它，示例：
```java
public class MyVerticle extends AbstractVerticle {
  public void start() {
    //Do something
  }
  public void stop(Future<Void> stopFuture) {
    obj.doSomethingThatTakesTime(res -> {
      if (res.succeeded()) {
        stopFuture.complete();
      } else {
        stopFuture.fail();
      }
    });
  }
}
```
