Vert.x core(2)
====================================

这一节主要讲述Verticles。

vert.x附带一个简单，可扩展，像actor一样部署的并发模型工具`Verticles`，你可以使用你自己写的。
这个模型是完全可选的，如果你不想使用它，vert.x不强迫你使用这种方式创建你的应用程序。

这个模型并不要求是一个严格actor模型的实现，但它们确实有相似之处，特别是关注并发性，伸缩性和部署。
`Verticles`代码块由vert.x部署和运行。

一个应用程序通常由同时运行在同一个vert.x实例中的多个`Verticle`实例组成。不同的`Verticle`实例相互
通信是通过在 **事件总线**（event bus）上发送消息实现。

### 写Verticles
Verticle类必须实现`Verticle`接口。如果你喜欢，你可以直接实现它，但通常使用更简单的方法就是继承
抽象类`AbstractVerticle`。下面是一个`Verticle`示例：
```java
public class MyVerticle extends AbstractVerticle {
  //Called when verticle is deployed
  public void start()  {
  }
  //Optional - called when verticle is undeployed
  public void stop() {
  }
}
```
通常情况下，你要重写`start`方法。当vert.x部署Verticles时，`start`将被调用，`start`方法执行完成的时候，
verticle就正式开始工作。你也可以选择重写`stop`方法（可选的），当verticle卸载时，vert.x将调用它。`stop`
方法完成时，verticle被认为正式停止工作。

### 异步启动或停止verticle
因为你的Verticle启动需要一些时间，所以有的时候你不想等待，你想在这段时间做些其它事情。例如，你想在
Verticle启动阶段（比如在调用`start`方法完成之前），部署一些其它的Verticles。在`start`方法完成
之前，你不能阻塞其它Verticles的部署，要不然就打破了“黄金规则”。

那我们要怎么做呢？一条路就是 **实现异步的start方法** 。该版本的`start`方法需要一个`Future`作为参数。
当该方法返回时，Verticle并 **不表示** 已经部署完成。一段时间后，你需要做的事情都完成后（比如启动其它
Verticles），你能在`Future`上完成调用，示例：
```java
public class MyVerticle extends AbstractVerticle {
  public void start(Future<Void> startFuture) {
    //Now deploy some other verticle:
    vertx.deployVerticle("com.foo.OtherVerticle", res  -> {
      if (res.succeeded()) {
        startFuture.complete();
      } else {
        startFuture.fail();
      }
    });
  }
}
```
同样，也有一个异步版本的stop方法。如果你想做一些需要时间的Verticle清理，你可以使用它，示例：
```java
public class MyVerticle extends AbstractVerticle {
  public void start() {
    //Do something
  }
  public void stop(Future<Void> stopFuture) {
    obj.doSomethingThatTakesTime(res -> {
      if (res.succeeded()) {
        stopFuture.complete();
      } else {
        stopFuture.fail();
      }
    });
  }
}
```
提示：在Verticle的`stop`方法里，你不需要手工卸载`child Verticle`。当Verticle卸载时，会自动
卸载`child Verticle`。

### Verticle类型
这里有三个不同的Verticle类型：
+ **标准Verticles**：这是最常见的，最有用的类型。它们总是由一个事件循环线程来执行。
+ **Worker Verticles**：它运行使用worker pool里的一个线程，一个实例同一时刻只会被一个线程执行。
+ **多线程的Worker Verticles**：它运行使用worker pool里的一个线程，一个实例能被多个线程并发地执行。

### 标准Verticles
当他们被创建并且其`start`方法由事件轮询调用时，标准Verticles被分配给一个事件轮询线程。当在一个事件轮询
的核心API上通过任何方法调用handler（处理器）时，vert.x将保证这些处理器 **被相同的事件轮询执行（分配的事件轮询线程？？？）** 。

这意味着在你的`Verticle`实例中，我们能保证所有的代码总是在相同的事件轮询上执行（只要你不创建自己的线程
去调用它！！）。**自己注：是不是意思是说一个`Verticle`示例会绑定一个固定的事件轮询上？？？**

这意味着你可以在你的应用程序中以单线程的方式写所有代码，不再同步的担心，避免了许多竞争条件和死锁，特别是
传统多线程应用程序开发如此盛行的现在。

### Worker verticles
Worker verticles挺像标准Verticles，但它不是由事件轮询执行，而是由vert.x的worker线程池中的线程执行。
Worker verticles被设计用来处理阻塞代码，因为他们不会阻塞任何事件轮询。

如果你不想使用Worker verticle来运行阻塞代码，你也可以在一个事件轮询上直接内联运行阻塞代码（见前面的运行阻塞代码示例！）。
如果你想发布一个Worker verticle，你需要调用`setWorker`方法，示例：
```java
//设置为true，表示是Worker verticle线程
DeploymentOptions options = new DeploymentOptions().setWorker(true);
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);
```
Worker verticle实例绝不会被vert.x并发调用执行，但能在不同的时间由不同线程调用执行。
### 多线程Worker verticles
一个多线程Worker verticles有点像常规的worker verticle，但它能被多线程并发地执行。

注意：多线程Worker verticles是一个高级特性，大多数应用程序不需要他们。因为这些Verticles的并发，
你必须非常小心地在多线程程序中使用标准的java技术来保证一致性状态。

### 以编程的方式部署Verticles
你可以使用`deployVerticle`方法之一来部署一个Verticle。示例：
```java
Verticle myVerticle = new MyVerticle();
vertx.deployVerticle(myVerticle);
```
你也能通过指定verticle的名字来部署一个Verticle。verticle名字是用来查找指定的`VerticleFactory`，
而`VerticleFactory`是用来实例化一个真实的verticle实例。不同的Verticle工厂用于不同的语言里，
进行Verticle的实例化，示例：
```java
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle");
//Deploy a avaScript verticle
vertx.deployVerticle("verticles/myverticle.js");
//Deploy a Ruby verticle verticle
vertx.deployVerticle("verticles/my_verticle.rb");
```
### 映射Verticle名字到Verticle工厂的规则
