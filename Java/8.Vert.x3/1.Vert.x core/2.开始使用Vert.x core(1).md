开始使用Vert.x core(1)
========================================
开始玩Vert.x就要从创建`Vertx`实例开始，那如何创建`Vertx`实例呢？示例：
```java
Vertx vertx = Vertx.vertx();
```
如果你使用 **Verticles**，**要注意**：多数应用仅仅需要单个`Vertx`实例，如果需要，也能够创建多个`Vertx`实例。
例如，在 **事件总线** 或者 **不同的servers/clients组** 之间隔离。

### 指定选项来创建Vertx对象
```java
Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
```
这个`VertxOptions`对象有许多设置，允许你配置像集群，HA，工作线程池大小和其它一些设置。

### 创建一个集群的Vertx对象
如果你创建Vert.x集群，你通常会使用 **异步变量** 来创建`Vertx`对象。这是因为把不同的`Vertx`实例集群到
一个组中，通过需要一些时间（也许是几秒）。这个时候，我们不阻塞调用线程，所以我们会给你一个异步的结果。

### fluent API
fluent API就是多个方法调用可以串起来，有点像java8 Stream API。示例：
```java
request.response().putHeader("Content-Type", "text/plain").write("some text").end();
```
这是Vert.x API的惯用模式。

### 不要调用我们，我们会调用你
Vert.x API主要是 **事件驱动** 的。这意味着，当Vert.x中发生的事情是你感兴趣的，Vert.x将调用你，
向你发送一个事件。一些事件示例：
+ 定时器被触发
+ 一些数据从套接字过来
+ 一些数据从磁盘上读取
+ 发生一个异常
+ 一个HTTP Server接收到一个请求

你可能通过Vert.x的事件处理器API来处理事件。示例，每秒接收一个定时器事件：
```java
vertx.setPeriodic(1000, id -> {
  // This handler will get called every second
  System.out.println("timer fired!");
});
```
或者接收一个HTTP请求：
```java
server.requestHandler(request -> {
  // This handler will be called every time an HTTP request is received at the server
  request.response().end("hello world!");
});
```
当一个事件过来时，Vert.x将异常调用你的事件处理程序。

### 不要阻塞我
除了极少数例外（如：一些文件系统操作），Vert.x API是不阻塞调用线程的。如果一个结果可以立即提供，
它将立即返回，否则，你通常要提供一个处理程序来接收一段时间后的事件。因为没有Vert.x API阻塞线程，
这意味着你可以 **使用Vert.x通过少量的线程来处理大量并发**。

常规阻塞API调用线程可能会阻塞：
+ 从套接字读取数据
+ 向磁盘写数据
+ 发送消息给接收者并等待响应
+ 其它情况......

在这所有的情况下，当你的线程在等待结果时，实际上是没有价值的。这意味着，如果你想在大量并发中使用阻塞
API，那么你需要大量的线程，以防止你的应用程序暂停。

另外，线程在 **内存** 与 **上下文切换** 上都有开销。

### Reactor and Multi-Reactor
我们之前说过，Vert.x API是事件驱动的。大多数情况下，Vert.x是通过使用一个叫做 **事件轮询的线程** 调用你的处理器。
事件轮询传递陆续到达的事件给不同的处理程序，因为没有阻塞，一个事件轮询线程可以在极短的时间里传递巨量的事件。示例，
单个事件轮询线程能非常快速地处理成千上万个HTTP请求。我们把这个模式称为 **反应堆模式**。Node.js就是这个模式。

**在一个标准的反应堆中，有一个单一的事件轮询线程，它在一个循环中运行，传递所有事件到所有处理器（给所有处理器？？？）。
单线程有一个问题，它在任意一个时间点仅能运行在单核心上。所以，如果你想让你的反应堆应用跑满你的多核心CPU，
你必须启动并管理多个不同的进程，Vert.x不同的地方就在这里，而不是一个单一的事件轮询。每个Vertx实例维护着
几个不同的事件轮询线程。默认情况下，一个Vert.x实例拥有的事件轮询线程数与CPU核心数量相同，但这也可以修改的。**

**我们称为个模式为多反应堆模式，以区分单线程的反应堆模式。**

**注意：即使Vertx实例维护着多个事件轮询线程，但任何特定的处理程序都不会同时（并行？？）执行。
在大多数情况下（vorker Verticles例外），都会使用相同的事件轮询线程**。

### 黄金法则：不要阻塞事件轮询
我们知道vert.x API是非阻塞的，事件轮询也是非阻塞的。但如果 **在自己的处理器中，自己阻塞了事件轮询**，那这些
对你也没有太多帮助。如果你阻塞了事件轮询，它将什么也干不了，如果你阻塞了所有的事件轮询，那你的应用程序就完全停止了。
所以不要那样做，要不然会 **得到警告**。阻塞的场景包括：
+ Thread.sleep()
+ 在锁上等待
+ 在互斥或监视上等待（如：同步部分）
+ 做一个长生命周期的数据库操作并等待结果
+ 做一个复杂的计算，需要大量时间
+ 在一个轮询中旋转（是死循环中？？）

也就是，消耗大量时间的操作，你就要注意了！那什么叫消耗大量时间？如果你有一个单一的事件轮询，你要处理
10000/秒的HTTP请求，那么显然请求之间的间隔不能超过0.1毫秒，所以你不能阻塞超过0.1毫秒的时间。

如果你的应用程序没有响应，这可能是个信号，你的代码在某处阻止了该事件轮询。为了帮助你判断问题，
当事件轮询在一段时间内没有返回，vert.x会自动记录警告日志。vert.x也提供了精确的堆栈跟踪，告诉你当
前阻塞在哪里。如果你想改变这些警告或者改变设置，你可以在创建 `Vertx`对象之前，通过`VertxOptions`
来处理。

### 运行阻塞代码
事实上，在JVM生态里，许多库包是同步API的，许多方法可能是阻塞的。一个很好的例子是JDBC API---它天生就是
同步的，vert.x无论怎么努力也没有魔法让它异步。

我们不去重写一切使它们变成异步，但我们提供一种方法在你的应用程序中安全地使用“传统”阻塞的API。

正如前面讨论的，你不能直接从事件轮询中调用阻塞操作，因为这将阻止它做任何其他有用的工作。所以，那我们应该
如何做呢？

通过调用`executeBlocking`来指定 **执行程序** 和 **结果处理程序** 这两个 **阻塞** 代码，当阻塞的
执行代码处理完成时，结果处理程序将被异步回调执行！
```java
vertx.executeBlocking(future -> {
  //Call some blocking API that takes a significant amount of time to return
  String result = someAPI.blockingMethod("hello");
  future.complete(result);
}, res -> {
  System.out.println("The result is: " + res.result());
});
```
默认情况下，如果`executeBlocking`在相同的上下文（例如，同一个`verticle`实例）被调用数次，
然后不同的`executeBlocking`是串行执行的（即一个接一个地执行）。

如果你不在乎调用`executeBlocking`顺序，可以指定`false`作为它的参数：
```java
<T> void executeBlocking(Handler<Future<T>> blockingCodeHandler,
  boolean ordered,
  Handler<AsyncResult<T>> resultHandler)
```
在这种情况下，任何`executeBlocking`可以在`worker pool`中并行执行。

另一个运行阻塞代码的方法是使用`verticle`。一个`worker verticle`总是由`worker pool`中的一个线程来执行。
