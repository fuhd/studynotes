开始使用Vert.x core
========================================
开始玩Vert.x就要从创建`Vertx`实例开始，那如何创建`Vertx`实例呢？示例：
```java
Vertx vertx = Vertx.vertx();
```
如果你使用 **Verticles**，**要注意**：多数应用仅仅需要单个`Vertx`实例，如果需要，也能够创建多个`Vertx`实例。
例如，在 **事件总线** 或者 **不同的servers/clients组** 之间隔离。

### 指定选项来创建Vertx对象
```java
Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
```
这个`VertxOptions`对象有许多设置，允许你配置像集群，HA，工作线程池大小和其它一些设置。

### 创建一个集群的Vertx对象
如果你创建Vert.x集群，你通常会使用 **异步变量** 来创建`Vertx`对象。这是因为把不同的`Vertx`实例集群到
一个组中，通过需要一些时间（也许是几秒）。这个时候，我们不阻塞调用线程，所以我们会给你一个异步的结果。

### fluent API
fluent API就是多个方法调用可以串起来，有点像java8 Stream API。示例：
```java
request.response().putHeader("Content-Type", "text/plain").write("some text").end();
```
这是Vert.x API的惯用模式。

### 不要调用我们，我们会调用你
Vert.x API主要是 **事件驱动** 的。这意味着，当Vert.x中发生的事情是你感兴趣的，Vert.x将调用你，
向你发送一个事件。一些事件示例：
+ 定时器被触发
+ 一些数据从套接字过来
+ 一些数据从磁盘上读取
+ 发生一个异常
+ 一个HTTP Server接收到一个请求

你可能通过Vert.x的事件处理器API来处理事件。示例，每秒接收一个定时器事件：
```java
vertx.setPeriodic(1000, id -> {
  // This handler will get called every second
  System.out.println("timer fired!");
});
```
或者接收一个HTTP请求：
```java
server.requestHandler(request -> {
  // This handler will be called every time an HTTP request is received at the server
  request.response().end("hello world!");
});
```
当一个事件过来时，Vert.x将异常调用你的事件处理程序。

### 不要阻塞我
除了极少数例外（如：一些文件系统操作），Vert.x API是不阻塞调用线程的。如果一个结果可以立即提供，
它将立即返回，否则，你通常要提供一个处理程序来接收一段时间后的事件。因为没有Vert.x API阻塞线程，
这意味着你可以 **使用Vert.x通过少量的线程来处理大量并发**。

常规阻塞API调用线程可能会阻塞：
+ 从套接字读取数据
+ 向磁盘写数据
+ 发送消息给接收者并等待响应
+ 其它情况......

在这所有的情况下，当你的线程在等待结果时，实际上是没有价值的。这意味着，如果你想在大量并发中使用阻塞
API，那么你需要大量的线程，以防止你的应用程序暂停。

另外，线程在 **内存** 与 **上下文切换** 上都有开销。

### Reactor and Multi-Reactor
我们之前说过，Vert.x API是事件驱动的。大多数情况下，Vert.x是通过使用一个叫做 **事件轮询的线程** 调用你的处理器。
事件轮询传递陆续到达的事件给不同的处理程序，因为没有阻塞，一个事件轮询线程可以在极短的时间里传递巨量的事件。示例，
单个事件轮询线程能非常快速地处理成千上万个HTTP请求。我们把这个模式称为 **反应堆模式**。Node.js就是这个模式。

**在一个标准的反应堆中，有一个单一的事件轮询线程，它在一个循环中运行，传递所有事件到所有处理器（给所有处理器？？？）。
单线程有一个问题，它在任意一个时间点仅能运行在单核心上。所以，如果你想让你的反应堆应用跑满你的多核心CPU，
你必须启动并管理多个不同的进程，Vert.x不同的地方就在这里，而不是一个单一的事件轮询。每个Vertx实例维护着
几个不同的事件轮询线程。默认情况下，一个Vert.x实例拥有的事件轮询线程数与CPU核心数量相同，但这也可以修改的。**

**我们称为个模式为多反应堆模式，以区分单线程的反应堆模式。**

**注意**：即使Vertx实例维护着多个事件轮询线程，但任何特定的处理程序都不会同时（并行？？）执行。
在大多数情况下（vorker Verticles例外），都会使用相同的事件轮询线程。
