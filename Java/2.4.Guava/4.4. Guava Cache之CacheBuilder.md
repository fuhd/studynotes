Guava Cache之CacheBuilder
========================================================
CacheBuilder类通过 **建造者(Builder)模式** 为我们提供了一种获取 **Cache** 和 **LoadingCache** 实例的方式。
CacheBuilder提供了许多选项，我们可以选择部分来创建Cache实例，不需要列出所有的选项，这是Builder模式的魅力。

### 示例1
这个例子演示的是在 **缓存条目加载到缓存中后，我们如何指定条目失效**：
```java
package com.fhd.java;

import com.google.common.base.Ticker;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import java.util.concurrent.TimeUnit;

public class CacheBuilderTest {
    public static void main(String[] args) {

        LoadingCache<String, TradeAccount> tradeAccountCache = CacheBuilder.newBuilder()
                .expireAfterWrite(5L, TimeUnit.MINUTES)
                .maximumSize(5000L)
                .removalListener(new TradeAccountRemovalListener())
                .ticker(Ticker.systemTicker())
                .build(new CacheLoader<String, TradeAccount>() {
                    @Override
                    public TradeAccount load(String key) throws Exception {
                        return tradeAccountService.getTradeAccountById(key);
                    }
                });
    }
}

class TradeAccount {

    private String id;      //ID
    private String owner;   //所有者
    private double balance; //余额

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getOwner() {
        return owner;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }
}
```
我们来简要的对第一个例子做一些说明：
首先，我们调用了 **expireAfterWrite方法**，它可以 **自动的使缓存条目在指定的时间后失效**，在本例中，是5分钟。
第二步，我们通过 **maximumSize方法**，5000作为传入值，指定了 **缓存的最大大小**，当缓存的大小 **逼近到最大值时**，
缓存中一些 **最近很少使用** 到的条目将会被移除，不一定在缓存大小达到最大值甚至超过最大值才移除。
我们注册了一个 **RemovalListener监听器** 实例，它可以在缓存中的条目 **被移除后接收通知**。我们添加了一个 **Ticker实例**，
通过调用ticker方法，此方法提供了 **缓存条目过期的时间，纳秒级的精密度**。
最后，我们调用了 **build方法**，传入了一个新的 **CacheLoader**实例，**当缓存中的key存在，value不存在时**，
这个实例将被用来重新获取TradeAccount对象。

### 示例2
在接下来的实例中，我们来看看 **怎么使缓存条目失效，基于上一次条目被访问后所经过的时间**:
```java
LoadingCache<String, Book> bookCache = CacheBuilder.newBuilder()
    .expireAfterAccess(20L, TimeUnit.MINUTES)
    .softValues()
    .removalListener(new BookRemovalListener())
    .build(new CacheLoader<String, Book>() {
        @Override
        public Book load(String key) throws Exception {
            return bookService.getBookByIsbn(key);
        }
    });
```
说明：
+ 通过调用 **expireAfterAccess** 方法，我们指定了缓存中的条目 **在上一次访问** 经过20分钟后失效。
+ 我们不再明确的指定缓存的最大值， 而是通过调用 **softValues()** 方法，**让JVM虚拟机将缓存中的条目包装成软引用对象**，
以限制的缓存大小。如果内存空间不足，缓存中的条目将会被移除。需要注意的是，哪些软引用可以被垃圾回收是 **由JVM内部进行的LRU计算所决定的**。
+ 我们添加了一个类似的RemovalListener监听器，用于处理缓存中value值不存在的条目。

### 示例3
介绍如何 **自动刷新** LongCache缓存中的条目值：
```java
LoadingCache<String, TradeAccount> tradeAccountCache = CacheBuilder.newBuilder()
    .concurrencyLevel(10)
    .refreshAfterWrite(5L, TimeUnit.SECONDS)
    .ticker(Ticker.systemTicker())
    .build(new CacheLoader<String,TradeAccount>() {
        @Override
        public TradeAccount load(String key)throws Exception {
            return tradeAccountService.getTradeAccountById(key);
        }
    });
```
说明：
+ 通过调用 **concurrencyLevel** 方法，我们设置了 **并发更新操作的数量** 为10，如果不设置的话，**默认值为4**。
+ 不再明确的移除缓存条目，而是通过 **refreshAfterWrite** 方法在给定的时间过去后，**刷新缓存中的条目值**，
当缓存条目的值被调用并且已经超过了设置的时间，刷新缓存的触发器将处于活动状态。
+ 我们添加了 **纳秒级别的Ticker**，以刷新那些符合条件的条目值。
+ 最后，通过调用 **build方法**，我们指定了需要使用的Loader。






