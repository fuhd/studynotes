Http协议拦截器
======================================================
`HTTP`协议拦截器是一种实现 **一个特定方面的`HTTP`协议的代码程序**。通常情况下，
协议拦截器会将 **一个或多个头消息** 加入到接受或者发送的消息中。协议拦截器 **也可以操作消息的内容实体**
— **消息内容的压缩/解压缩** 就是个很好的例子。通常，这是通过使用“装饰”开发模式，一个包装实体类用于装饰原来的实体来实现。
一个拦截器可以合并，形成一个逻辑单元。

协议拦截器可以通过 **共享信息协作** —— 比如处理状态 —— **通过HTTP执行上下文**。协议拦截器可以使用
`Http`上下文存储一个或者多个连续请求的处理状态。

通常，**只要拦截器不依赖于一个特定状态的`http`上下文，那么拦截执行的顺序就无所谓**。如果协议拦截器有相互依赖关系，
必须以特定的顺序执行，那么它们应该按照特定的顺序加入到协议处理器中。

**协议处理器必须是线程安全的**。类似于`servlets`，协议拦截器不应该使用变量实体，除非访问这些变量是同步的（线程安全的）。

下面是个例子，讲述了本地的上下文是如何在连续请求中记录处理状态的：
```java
CloseableHttpClient httpclient = HttpClients
        .custom()
        .addInterceptorLast(new HttpRequestInterceptor() {
                public void process(final HttpRequest request, final HttpContext context)
                        throws HttpException, IOException {
                    AtomicInteger count = (AtomicInteger) context.getAttribute("count");
                    request.addHeader("Count", Integer.toString(count.getAndIncrement()));
                }
        })
        .build();
AtomicInteger count = new AtomicInteger(1);  
HttpClientContext localContext = HttpClientContext.create();  
localContext.setAttribute("count", count);  
HttpGet httpget = new HttpGet("http://localhost/");  
for (int i = 0; i < 10; i++) {
    CloseableHttpResponse response = httpclient.execute(httpget, localContext);
    try {
        HttpEntity entity = response.getEntity();  
    } finally {  
        response.close();  
    }  
}
```
