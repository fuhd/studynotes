请求执行
============================================================
`HttpClient`最基本的功能就是执行`Http`方法。一个`Http`方法的执行涉及到 **一个或者多个Http请求/Http响应的交互**，
通常这个过程都会自动被`HttpClient`处理，对用户透明。

### HTTP请求
`HttpClient`支持`HTTP/1.1`这个版本定义的所有`Http`方法：**GET,HEAD,POST,PUT,DELETE,TRACE和OPTIONS**。
对于每一种`http`方法，`HttpClient`都定义了一个相应的类：**HttpGet, HttpHead, HttpPost, HttpPut, HttpDelete,
HttpTrace和HttpOptions**。

`Request-URI`即统一资源定位符，用来标明`Http`请求中的资源。**`Http request URIs`包含协议名、主机名、主机端口（可选）、
资源路径、query（可选）和片段信息（可选）**。示例：
```java
HttpGet httpget = new HttpGet("http://www.google.com/search?hl=en&q=httpclient&btnG=Google+Search&aq=f&oq=");
```
`HttpClient`提供`URIBuilder`工具类来简化`URIs`的创建和修改过程。示例：
```java
URI uri = new URIBuilder()
    .setScheme("http")  
    .setHost("www.google.com")  
    .setPath("/search")  
    .setParameter("q", "httpclient")  
    .setParameter("btnG", "Google Search")  
    .setParameter("aq", "f")  
    .setParameter("oq", "")  
    .build();  
HttpGet httpget = new HttpGet(uri);  
System.out.println(httpget.getURI());  
```
上述代码会在控制台输出：
```
http://www.google.com/search?q=httpclient&btnG=Google+Search&aq=f&oq=  
```

### HTTP响应
服务器收到客户端的`http`请求后，就会对其进行解析，然后把响应发给客户端，这个响应就是
HTTP response。HTTP响应第一行是协议版本，之后是数字状态码和相关联的文本段。示例：
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_OK, "OK");  
System.out.println(response.getProtocolVersion());  
System.out.println(response.getStatusLine().getStatusCode());  
System.out.println(response.getStatusLine().getReasonPhrase());  
System.out.println(response.getStatusLine().toString());  
```
上述代码会在控制台输出：
```
HTTP/1.1  
200  
OK  
HTTP/1.1 200 OK
```

### 消息头
一个`Http`消息可以包含一系列的消息头，用来对`http`消息进行描述，比如消息长度，消息类型等等。
`HttpClient`提供了方法来获取、添加、移除、枚举消息头。
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, "OK");  
response.addHeader("Set-Cookie", "c1=a; path=/; domain=localhost");  
response.addHeader("Set-Cookie", "c2=b; path=\"/\", c3=c; domain=\"localhost\"");  
Header h1 = response.getFirstHeader("Set-Cookie");  
System.out.println(h1);  
Header h2 = response.getLastHeader("Set-Cookie");  
System.out.println(h2);  
Header[] hs = response.getHeaders("Set-Cookie");  
System.out.println(hs.length);
```
上述代码会在控制台输出：
```
Set-Cookie: c1=a; path=/; domain=localhost  
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"  
2  
```
最有效的获取指定类型的消息头的方法还是 **使用HeaderIterator接口**。示例：
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, "OK");  
response.addHeader("Set-Cookie", "c1=a; path=/; domain=localhost");  
response.addHeader("Set-Cookie", "c2=b; path=\"/\", c3=c; domain=\"localhost\"");  
HeaderIterator it = response.headerIterator("Set-Cookie");  
while (it.hasNext()) {
  System.out.println(it.next());
}
```
上述代码会在控制台输出：
```
Set-Cookie: c1=a; path=/; domain=localhost
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"
```
**HeaderIterator** 也提供非常便捷的方式，将`Http`消息解析成单独的消息头元素。示例：
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, "OK");  
response.addHeader("Set-Cookie", "c1=a; path=/; domain=localhost");  
response.addHeader("Set-Cookie", "c2=b; path=\"/\", c3=c; domain=\"localhost\"");  
HeaderElementIterator it = new BasicHeaderElementIterator(response.headerIterator("Set-Cookie"));  
while (it.hasNext()) {
    HeaderElement elem = it.nextElement();   
    System.out.println(elem.getName() + " = " + elem.getValue());
    NameValuePair[] params = elem.getParameters();  
    for (int i = 0; i < params.length; i++) {  
        System.out.println(" " + params[i]);  
    }  
}
```
上述代码会在控制台输出：
```
c1 = a  
path=/  
domain=localhost  
c2 = b  
path=/  
c3 = c  
domain=localhost
```

### HTTP实体
`Http`消息可以携带`http`实体，这个`http`实体既可以是`http`请求，也可以是`http`响应的。`Http`实体，
可以在某些`http`请求或者响应中发现，但不是必须的。`Http`规范中定义了两种包含请求的方法：**POST** 和 **PUT**。
`HTTP`响应一般会包含一个内容实体。当然这条规则也有异常情况，如Head方法的响应，204没有内容，304没有修改或者205内容资源重置。

`HttpClient`根据来源的不同，划分了 **三种不同的Http实体内容**。
+ **streamed流式**: **内容是通过流来接受或者在运行中产生**。特别是，`streamed`这一类包含从`http`响应中获取的实体内容。
一般说来，**`streamed`实体是不可重复的**。
+ **self-contained自我包含式**: 内容在内存中或通过独立的连接或其它实体中获得。**`self-contained`类型的实体内容通常是可重复的**。
这种类型的实体通常用于关闭http请求。
+ **wrapping包装式**: 这种类型的内容是从另外的`http`实体中获取的。

当从`Http`响应中读取内容时，上面的三种区分对于连接管理器来说是非常重要的。**对于由应用程序创建而且只使用`HttpClient`发送的请求实体，
`streamed`和`self-contained`两种类型的不同就不那么重要了**。这种情况下，建议考虑如`streamed`流式这种不能重复的实体，
和可以重复的`self-contained`自我包含式实体。
#### 可重复的实体
一个实体是可重复的，也就是说它包含的内容可以被多次读取。这种多次读取只有`self contained`（自包含）的实体能做到
（比如 **ByteArrayEntity** 或者 **StringEntity**)。
#### 使用Http实体
由于一个 **`Http`实体** 既可以表示 **二进制内容**，又可以表示 **文本内容**，所以`Http`实体要支持 **字符编码**
（为了支持后者，即文本内容）。

当需要执行一个完整内容的`Http`请求或者`Http`请求已经成功，服务器要发送响应到客户端时，`Http`实体就会被创建。

如果要 **从`Http`实体中读取内容**，我们可以利用 **`HttpEntity`类的`getContent`方法来获取实体的输入流
（java.io.InputStream)**，或者 **利用`HttpEntity`类的`writeTo(OutputStream)`方法来获取输出流**，
这个方法会把所有的内容写入到给定的流中。

当实体类已经被接受后，我们可以利用`HttpEntity`类的`getContentType()`和`getContentLength()`
方法来读取`Content-Type`和`Content-Length`两个头消息（如果有的话）。由于`Content-Type`
包含`mime-types`的字符编码，比如`text/plain`或者`text/html`，`HttpEntity`类的`getContentEncoding()`
方法就是读取这个编码的。如果头信息不存在，`getContentLength()`会返回`-1`，`getContentType()`会返回`NULL`。
如果`Content-Type`信息存在，就会返回一个`Header`类。

**当为发送消息创建`Http`实体时，需要同时附加`meta`信息**。示例：
```java
StringEntity myEntity = new StringEntity("important message", ContentType.create("text/plain", "UTF-8"));  
System.out.println(myEntity.getContentType());  
System.out.println(myEntity.getContentLength());  
System.out.println(EntityUtils.toString(myEntity));  
System.out.println(EntityUtils.toByteArray(myEntity).length);
```
上述代码会在控制台输出：
```
Content-Type: text/plain; charset=utf-8  
17  
important message  
17  
```

### 确保底层的资源连接被释放
为了确保系统资源被正确地释放，我们要么 **管理`Http`实体的内容流**、要么 **关闭`Http`响应**。示例：
```java
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpget = new HttpGet("http://localhost/");
CloseableHttpResponse response = httpclient.execute(httpget);
try {
    HttpEntity entity = response.getEntity();
    if (entity != null) {
        InputStream instream = entity.getContent();
        try {
            // do something useful
        } finally {
            instream.close();
        }
    }
} finally {
    response.close();
}
```
关闭`Http`实体内容流和关闭`Http`响应的区别在于，**前者通过消耗掉`Http`实体内容来保持相关的`http`连接，
然后后者会立即关闭、丢弃`http`连接**。

**请注意`HttpEntity`的`writeTo(OutputStream)`方法，当`Http`实体被写入到`OutputStream`后，
也要确保释放系统资源。如果这个方法内调用了`HttpEntity`的`getContent()`方法，
那么它会有一个`java.io.InpputStream`的实例，我们需要在`finally`中关闭这个流**。

但是也有这样的情况，我们只需要获取`Http`响应内容的一小部分，而获取整个内容、并实现连接的可重复性代价太大，
这时我们可以 **通过关闭响应的方式来关闭内容输入、输出流**。示例：
```java
CloseableHttpClient httpclient = HttpClients.createDefault();  
HttpGet httpget = new HttpGet("http://localhost/");  
CloseableHttpResponse response = httpclient.execute(httpget);  
try {
    HttpEntity entity = response.getEntity();  
    if (entity != null) {  
        InputStream instream = entity.getContent();  
        int byteOne = instream.read();  
        int byteTwo = instream.read();  
        // Do not need the rest  
    }  
} finally {
    response.close();
}
```
上面的代码执行后，连接变得不可用，**所有的资源都将被释放**。

### 消耗HTTP实体内容
