请求执行
============================================================
`HttpClient`最基本的功能就是执行`Http`方法。一个`Http`方法的执行涉及到 **一个或者多个Http请求/Http响应的交互**，
通常这个过程都会自动被`HttpClient`处理，对用户透明。

### HTTP请求
`HttpClient`支持`HTTP/1.1`这个版本定义的所有`Http`方法：**GET,HEAD,POST,PUT,DELETE,TRACE和OPTIONS**。
对于每一种`http`方法，`HttpClient`都定义了一个相应的类：**HttpGet, HttpHead, HttpPost, HttpPut, HttpDelete,
HttpTrace和HttpOptions**。

`Request-URI`即统一资源定位符，用来标明`Http`请求中的资源。**`Http request URIs`包含协议名、主机名、主机端口（可选）、
资源路径、query（可选）和片段信息（可选）**。示例：
```java
HttpGet httpget = new HttpGet("http://www.google.com/search?hl=en&q=httpclient&btnG=Google+Search&aq=f&oq=");
```
`HttpClient`提供`URIBuilder`工具类来简化`URIs`的创建和修改过程。示例：
```java
URI uri = new URIBuilder()
    .setScheme("http")  
    .setHost("www.google.com")  
    .setPath("/search")  
    .setParameter("q", "httpclient")  
    .setParameter("btnG", "Google Search")  
    .setParameter("aq", "f")  
    .setParameter("oq", "")  
    .build();  
HttpGet httpget = new HttpGet(uri);  
System.out.println(httpget.getURI());  
```
上述代码会在控制台输出：
```
http://www.google.com/search?q=httpclient&btnG=Google+Search&aq=f&oq=  
```

### HTTP响应
服务器收到客户端的`http`请求后，就会对其进行解析，然后把响应发给客户端，这个响应就是
HTTP response。HTTP响应第一行是协议版本，之后是数字状态码和相关联的文本段。示例：
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_OK, "OK");  
System.out.println(response.getProtocolVersion());  
System.out.println(response.getStatusLine().getStatusCode());  
System.out.println(response.getStatusLine().getReasonPhrase());  
System.out.println(response.getStatusLine().toString());  
```
上述代码会在控制台输出：
```
HTTP/1.1  
200  
OK  
HTTP/1.1 200 OK
```

### 消息头
一个`Http`消息可以包含一系列的消息头，用来对`http`消息进行描述，比如消息长度，消息类型等等。
`HttpClient`提供了方法来获取、添加、移除、枚举消息头。
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, "OK");  
response.addHeader("Set-Cookie", "c1=a; path=/; domain=localhost");  
response.addHeader("Set-Cookie", "c2=b; path=\"/\", c3=c; domain=\"localhost\"");  
Header h1 = response.getFirstHeader("Set-Cookie");  
System.out.println(h1);  
Header h2 = response.getLastHeader("Set-Cookie");  
System.out.println(h2);  
Header[] hs = response.getHeaders("Set-Cookie");  
System.out.println(hs.length);
```
上述代码会在控制台输出：
```
Set-Cookie: c1=a; path=/; domain=localhost  
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"  
2  
```
最有效的获取指定类型的消息头的方法还是 **使用HeaderIterator接口**。示例：
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, "OK");  
response.addHeader("Set-Cookie", "c1=a; path=/; domain=localhost");  
response.addHeader("Set-Cookie", "c2=b; path=\"/\", c3=c; domain=\"localhost\"");  
HeaderIterator it = response.headerIterator("Set-Cookie");  
while (it.hasNext()) {
  System.out.println(it.next());
}
```
上述代码会在控制台输出：
```
Set-Cookie: c1=a; path=/; domain=localhost
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"
```
**HeaderIterator** 也提供非常便捷的方式，将`Http`消息解析成单独的消息头元素。示例：
```java
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, "OK");  
response.addHeader("Set-Cookie", "c1=a; path=/; domain=localhost");  
response.addHeader("Set-Cookie", "c2=b; path=\"/\", c3=c; domain=\"localhost\"");  
HeaderElementIterator it = new BasicHeaderElementIterator(response.headerIterator("Set-Cookie"));  
while (it.hasNext()) {
    HeaderElement elem = it.nextElement();   
    System.out.println(elem.getName() + " = " + elem.getValue());
    NameValuePair[] params = elem.getParameters();  
    for (int i = 0; i < params.length; i++) {  
        System.out.println(" " + params[i]);  
    }  
}
```
上述代码会在控制台输出：
```
c1 = a  
path=/  
domain=localhost  
c2 = b  
path=/  
c3 = c  
domain=localhost
```

### HTTP实体
`Http`消息可以携带`http`实体，这个`http`实体既可以是`http`请求，也可以是`http`响应的。`Http`实体，
可以在某些`http`请求或者响应中发现，但不是必须的。`Http`规范中定义了两种包含请求的方法：**POST** 和 **PUT**。
`HTTP`响应一般会包含一个内容实体。当然这条规则也有异常情况，如Head方法的响应，204没有内容，304没有修改或者205内容资源重置。

`HttpClient`根据来源的不同，划分了 **三种不同的Http实体内容**。
+ **streamed流式**: **内容是通过流来接受或者在运行中产生**。特别是，`streamed`这一类包含从`http`响应中获取的实体内容。
一般说来，**`streamed`实体是不可重复的**。
+ **self-contained自我包含式**: 内容在内存中或通过独立的连接或其它实体中获得。**`self-contained`类型的实体内容通常是可重复的**。
这种类型的实体通常用于关闭http请求。
+ **wrapping包装式**: 这种类型的内容是从另外的`http`实体中获取的。

当从`Http`响应中读取内容时，上面的三种区分对于连接管理器来说是非常重要的。**对于由应用程序创建而且只使用`HttpClient`发送的请求实体，
`streamed`和`self-contained`两种类型的不同就不那么重要了**。这种情况下，建议考虑如`streamed`流式这种不能重复的实体，
和可以重复的`self-contained`自我包含式实体。
#### 可重复的实体
一个实体是可重复的，也就是说它包含的内容可以被多次读取。这种多次读取只有`self contained`（自包含）的实体能做到
（比如 **ByteArrayEntity** 或者 **StringEntity**)。
