连接到Redis
========================================================
spring-data-redis提供了一套与实现无关的连接器api(最主要的实现还是`Jedis`)，
`org.springframework.data.redis.connection`包以及`RedisConnection`、`RedisConnectionFactory`接口等。
如果遇到特别情况，获取本地库（实现的api，比如`Jedis`）也是方便的。`RedisConnection`提供专用方法`getNativeConnection()`
来返回原始的基础对象用于通信。

### RedisConnection and RedisConnectionFactory
`RedisConnection`是通过`RedisConnectionFactory`创建的。另外，这个工厂起着`PersistenceExceptionTranslator`的作用，
一旦定义，它允许透明的异常转换。

根据配置，工厂可以返回一个新的连接或现有的连接（在连接池或本地共享连接被使用的情况下）。

### 配置Jedis连接器
示例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"
        p:host-name="server" p:port="6379" />
</beans>
```

### Redis Sentinel Support(Redis官方提供的集群管理工具)
`Redis Sentinel`通过`RedisSentinelConfiguration`来支持`Redis`的HA方案。
```java
/**jedis*/
@Bean
public RedisConnectionFactory jedisConnectionFactory() {
    RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
        .master("mymaster")
        .sentinel("127.0.0.1", 26379)
        .sentinel("127.0.0.1", 26380);
    return new JedisConnectionFactory(sentinelConfig);
}
```
`RedisSentinelConfiguration`可以通过`PropertySource`定义：
```
spring.redis.sentinel.master: master节点名称
spring.redis.sentinel.nodes: 通过逗号分隔的`host:port`列表
```
有时候需要与`Sentinels`直接交互，使用`RedisConnectionFactory.getSentinelConnection()`
或者`RedisConnection.getSentinelCommands()`，允许你访问配置中第一个活动的`Sentinel`。

### 通过RedisTemplate对象工作
大多数用户可能使用`RedisTemplate`及其相应的包`org.springframework.data.redis.core` -
由于其丰富的功能集。模板实际上是`Redis`模块的中心类。模板提供了`Redis`交互的高级抽象。
虽然`RedisConnection`提供接受和返回二进制值（字节数组）的低级方法，但模板负责序列化和连接管理，
从而避免用户处理这些细节。

此外，模板提供了操作视图（根据`Redis`命令引用进行分组），它提供丰富的，一般化的接口，
用于对某种类型或某个键（通过KeyBound接口）进行处理，如下所述：

**表：操作视图**

| 接口 | 描述 |
| :------------- | :------------- |
| **Key类型操作**       |       |
| ValueOperations | Redis字符串（或值）操作 |
| ListOperations | Redis list操作 |
| SetOperations | Redis set操作 |
| ZSetOperations | Redis zset (或者 sorted set) 操作 |
| HashOperations | Redis hash操作 |
| HyperLogLogOperations | Redis HyperLogLog操作，如（pfadd，pfcount，...）|
| **Key绑定操作** |         |
| BoundValueOperations | Redis 字符串（或值）key绑定操作 |
| BoundListOperations | Redis list key绑定操作 |
| BoundSetOperations | Redis set key绑定操作 |
| BoundZSetOperations | Redis zset(或者 sorted set) key绑定操作 |
| BoundHashOperations | Redis hash key绑定操作 |

配置后，**模板是线程安全的**，可以跨多个实例使用。

开箱即用，`RedisTemplate`使用java基本的序列化器进行大多数操作。这意味着模板写入或读取的任何对象
都通过java进行序列化或反序列化。可以在模板上轻松地更改序列化机制，`Redis`模块提供的
`org.springframework.data.redis.serializer`包中提供了几个实现。您还可以将任何序列化器设置为`null`，
并通过将 **`enableDefaultSerializer`** 属性设置为`false`，使用带有原始字节数组的`RedisTemplate`。

**请注意，模板要求所有键都为非空值 - 只要底层序列化程序接受它们，值就可以为null**;

**或需要某个模板视图的情况下，将视图声明为依赖关系并注入模板：容器将自动执行转换，消除opsFor[X]调用**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"
        p:use-pool="true"/>
    <!-- redis template definition -->
    <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"
        p:connection-factory-ref="jedisConnectionFactory"/>
    ......
</beans>
```
```java
public class Example {
    // inject the actual template
    @Autowired
    private RedisTemplate<String, String> template;
    // inject the template as ListOperations
    @Resource(name="redisTemplate")
    private ListOperations<String, String> listOps;

    public void addLink(String userId, URL url) {
        listOps.leftPush(userId, url.toExternalForm());
    }
}
```
