对象已死？
================================================
堆中几乎都存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象
有哪些“存活”着，哪些已经“死去”！

### 引用计数法
很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器
就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。

但是，**java语言中没有选用引用计数算法来管理内存**，其中最主要的原因是它很难解决对象之间的相互循环引用的
问题。

### 根搜索算法
在主流的商用程序语言中（java和C#），都是使用 **根搜索算法（GC Roots Tracing）** 判定对象是否存活。
这个算法的基本思路就是 **通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索
所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明
此对象是不可用的**。

在Java语言里，可作为GC Roots的对象包括下面几种：
+ 虚拟机栈（栈帧中的本地变量表）中的引用的对象；
+ 方法区中的类静态属性引用的对象；
+ 方法区中的常量引用的对象；
+ 本地方法栈中JNI（即一般说的Native方法）的引用的对象；

### 再谈引用
无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否
存活都与“引用”有关。

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为 **强引用**，**软引用**，**弱引用**，
**虚引用** 四种，这四种引用强度依次逐渐减弱。
+ 强引用就是指在程序代码之中普遍存在的，类似`Object obj = new Object()`这类的引用，**只要强引用
还存在，垃圾收集器永远不会回收掉被引用的对象**；
+ 软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，**在系统将要发生内存溢出异常之前，
将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常**。
+ 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次
垃圾回收发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象**。
+ 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其
生存时间构成影响，也无法通过虚引用来取得一个对象实例。**为一个对象设置虚引用关联的唯一目的就是希望能在这个
对象被收集器回收时收到一个系统通知**；
