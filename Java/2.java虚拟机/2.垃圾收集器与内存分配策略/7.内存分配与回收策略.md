内存分配与回收策略
=================================================================
Java技术体系中所提倡的 **自动内存管理** 最终可以归结为自动化地解决了两个问题：**给对象分配内存** 以及 **回收分配给对象的内存**。

对象的内存分配，往大方向上讲，就是在 **堆上分配**（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配）,
对象 **主要分配在新生代的`Eden`区上**，如果启动了本地线程分配缓冲，将按线程优先在`TLAB`上分配。
少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的。

接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节中的代码在测试时 **使用`Client`模式** 虚拟机运行，
没有手工指定收集器组合，换句话说，**验证的是使用`Serial/Serial Old`收集器** 下（`ParNew/Serial Old`收集器组合的规则
也基本一致）的内存分配和回收的策略。

### 对象优先在Eden分配
大多数情况下，**对象在新生代`Eden`区中分配**。当`Eden`区没有足够的空间进行分配时，虚拟机将发起一次 **`Minor GC`**。
虚拟机提供了 **`-XX:+PrintGCDetails`** 这个收集器 **日志参数**，告诉虚拟机在 **发生垃圾收集行为时打印回收日志**。
并且在进程退出的时候输出当前内存各区域的分配情况。

示例，在运行时通过 **`-Xms20M, -Xmx20M，-Xmn10M`** 这三个参数限制Java堆大小为20MB，且不可扩展，
其中10MB分配给新生代，剩下的10MB分配给老年代。**`-XX:SurvivorRatio=8`** 决定了 **新生代中`Eden`区与
一个`Survivor`区的空间比例是8比1**。
```java
package jvm;

public class Test1 {

    private static final int _1MB = 1024 * 1024;

    /**
     * VM 参数： -XX:+UseSerialGC -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
     */
    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        //出现一次Minor GC
        allocation4 = new byte[4 * _1MB];
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```
执行结果：
```
[GC (Allocation Failure) [DefNew: 7144K->347K(9216K), 0.0060731 secs] 7144K->6491K(19456K), 0.0061309 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
Heap
 def new generation   total 9216K, used 4607K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff029178, 0x00000000ff400000)
  from space 1024K,  33% used [0x00000000ff500000, 0x00000000ff556e28, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)
 Metaspace       used 2855K, capacity 4494K, committed 4864K, reserved 1056768K
  class space    used 312K, capacity 386K, committed 512K, reserved 1048576K
```
**这次GC发生的原因是给`allocation4`分配内存的时候，发现`Eden`已经被占用了6MB，剩余空间已经不足以分配`allocation4`
所需的4MB内存，因此发生`Minor GC`。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入`Survivor`空间
（`Survivor`空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去**。
