内存分配与回收策略
=================================================================
Java技术体系中所提倡的 **自动内存管理** 最终可以归结为自动化地解决了两个问题：**给对象分配内存** 以及 **回收分配给对象的内存**。

对象的内存分配，往大方向上讲，就是在 **堆上分配**（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配）,
对象 **主要分配在新生代的`Eden`区上**，如果启动了本地线程分配缓冲，将按线程优先在`TLAB`上分配。
少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的。

接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节中的代码在测试时 **使用`Client`模式** 虚拟机运行，
没有手工指定收集器组合，换句话说，**验证的是使用`Serial/Serial Old`收集器** 下（`ParNew/Serial Old`收集器组合的规则
也基本一致）的内存分配和回收的策略。

### 对象优先在Eden分配
大多数情况下，**对象在新生代`Eden`区中分配**。当`Eden`区没有足够的空间进行分配时，虚拟机将发起一次 **`Minor GC`**。
虚拟机提供了 **`-XX:+PrintGCDetails`** 这个收集器 **日志参数**，告诉虚拟机在 **发生垃圾收集行为时打印回收日志**。
并且在进程退出的时候输出当前内存各区域的分配情况。

示例，在运行时通过 **`-Xms20M, -Xmx20M，-Xmn10M`** 这三个参数限制Java堆大小为20MB，且不可扩展，
其中10MB分配给新生代，剩下的10MB分配给老年代。**`-XX:SurvivorRatio=8`** 决定了 **新生代中`Eden`区与
一个`Survivor`区的空间比例是8比1**。
```java
package jvm;

public class Test1 {

    private static final int _1MB = 1024 * 1024;

    /**
     * VM 参数： -XX:+UseSerialGC -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
     */
    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        //出现一次Minor GC
        allocation4 = new byte[4 * _1MB];
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```
执行结果：
```
[GC (Allocation Failure) [DefNew: 7144K->347K(9216K), 0.0060731 secs] 7144K->6491K(19456K), 0.0061309 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
Heap
 def new generation   total 9216K, used 4607K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff029178, 0x00000000ff400000)
  from space 1024K,  33% used [0x00000000ff500000, 0x00000000ff556e28, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)
 Metaspace       used 2855K, capacity 4494K, committed 4864K, reserved 1056768K
  class space    used 312K, capacity 386K, committed 512K, reserved 1048576K
```
**这次GC发生的原因是给`allocation4`分配内存的时候，发现`Eden`已经被占用了6MB，剩余空间已经不足以分配`allocation4`
所需的4MB内存，因此发生`Minor GC`。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入`Survivor`空间
（`Survivor`空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去**。

#### `Minor GC`和`Full GC`有什么不一样吗？
+ **新生代GC（Minor GC）**：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，
所以`Minor GC`非常频繁，一般回收速度也比较快。
+ **老年代GC（Major GC/Full GC）**：指发生在老年代的GC，出现了`Major GC`，经常会伴随至少一次的`Minor GC`
（但非绝对的，在`ParallelScavenge`收集器的收集策略里就有直接进行`Major GC`的策略选择过程）。
**`Major GC`的速度一般会比`Minor GC`慢10倍以上**。

### 大对象直接进入老年代
所谓大对象就是指，需要 **大量连续内存空间** 的Java对象，最典型的大对象就是那种 **很长的字符串及数组**。
大对象对虚拟机的内存分配来说就是一个坏消息（比遇到一个大对象更加坏的消息就是遇到一群“朝生夕死”的“短命大对象”，
写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获得足够的连续空间来
“安置”它们。

虚拟机提供了一个 **`-XX:PretenureSizeThreshold`** 参数， **令大于这个设置值的对象直接在老年代中分配。
这样做的目的是避免在`Eden`区及两个`Survivor`区之间发生大量的内存拷贝**。

示例：
```java
package jvm;

public class Test2 {

    private static final int _1MB = 1024 * 1024;

    /**
     * VM 参数：
     * -XX:+UseSerialGC
     * -XX:+PrintGCDetails
     * -Xms20M
     * -Xmx20M
     * -Xmn10M
     * -XX:SurvivorRatio=8
     * -XX:PretenureSizeThreshold=3145728
     */
    public static void testAllocation() {
        //使用了-XX:PretenureSizeThreshold=3145728，这个JVM参数，可以直接分配在老年代中了
        byte[] allocation = new byte[4 * _1MB];
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```
结果：
```
Heap
 def new generation   total 9216K, used 1328K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  16% used [0x00000000fec00000, 0x00000000fed4c138, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)
 Metaspace       used 2950K, capacity 4494K, committed 4864K, reserved 1056768K
  class space    used 324K, capacity 386K, committed 512K, reserved 1048576K
```
我们看到`Eden`空间几乎没有被使用，而老年代10MB空间被使用了40％，也就是4MB的`allocation`对象直接
就分配在老年代中，这是因为`PretenureSizeThreshold`被设置为3MB（就是3145728B，这个参数不能与`-Xms`之类
的参数一样直接写3MB），因此超过3MB的对象都会直接在老年代中进行分配。

**注意：`PretenureSizeThreshold`参数只对`Serial`和`ParNew`两款收集器有效，`Parallel Scavenge`收集器
不认识这个参数，`Parallel Scavenge`收集器一般并不需要设置，如果遇到必须使用此参数的场合，可以考虑
`ParNew`加`CMS`的收集器组合**。

### 长期存活的对象将进入老年代
虚拟机既然采用了 **分代收集** 的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，
哪些对象应放在老年代中。为了做到这点，**虚拟机给每个对象定义了一个对象年龄（Age）计数器**。
**如果对象在`Eden`出生并经过第一次`Minor GC`后仍然存活，并且能被`Survivor`容纳的话，将被移动到`Survivor`
空间中，并将对象年龄设为1。对象在`Survivor`区中每熬过一次`Minor GC`，年龄就增加1岁，当它的年龄增加到一定
程序（默认为15岁）时，就会被晋升到老年代中**。对象晋升老年代的 **年龄阀值**，可以通过参数：**`-XX:MaxTenuringThreshold`**
来设置。

下面，我们分别以`-XX:MaxTenuringThreshold=1`和`-XX:MaxTenuringThreshold=15`两种设置来执行相同的示例代码。

#### `-XX:MaxTenuringThreshold=1`
```java
package jvm;

public class Test4 {

    private static final int _1MB = 1024 * 1024;

    /**
     * VM 参数：
     * -XX:+UseSerialGC
     * -XX:+PrintGCDetails
     * -Xms20M
     * -Xmx20M
     * -Xmn10M
     * -XX:SurvivorRatio=8
     * -XX:MaxTenuringThreshold=1
     */
    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3;
        allocation1 = new byte[_1MB / 4];
        allocation2 = new byte[4 * _1MB];
        /*
         * 下面这句代码，触发了第一次Minor GC，因为Eden区域只有8M，
         * allocation3的对象太大，Survivor装不下，所以要移到老年代去
         */
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        //这里触发第二次Minor GC
        allocation3 = new byte[4 * _1MB];
    }

    public static void main(String[] args) {
        testAllocation();
    }
}
```
执行结果：
```
[GC (Allocation Failure) [DefNew: 5352K->601K(9216K), 0.0050545 secs] 5352K->4697K(19456K), 0.0051049 secs] [Times: user=0.00 sys=0.01, real=0.00 secs]
[GC (Allocation Failure) [DefNew: 4860K->2K(9216K), 0.0015709 secs] 8956K->4686K(19456K), 0.0016218 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 9216K, used 4263K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290f8, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400b48, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 4683K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  45% used [0x00000000ff600000, 0x00000000ffa92e78, 0x00000000ffa93000, 0x0000000100000000)
 Metaspace       used 2867K, capacity 4494K, committed 4864K, reserved 1056768K
  class space    used 314K, capacity 386K, committed 512K, reserved 1048576K
```

#### `-XX:MaxTenuringThreshold=15`
