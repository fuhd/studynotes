垃圾收集器
================================================
收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

![垃圾收集器](img/垃圾收集器.jpg)

这里讨论的收集器基于Sun HotSpot虚拟机1.6版 Update 22，它包含的所有收集器如上图所示。
上图展示了7种作用于不同分代的收集器，**如果两个收集器之间存在连线，就说明它们可以搭配使用**。

### Serial收集器（新生代）
`Serial`收集器是最基本 ，历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。
这个收集器是一个 **单线程的收集器**，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程
去完成垃圾收集工作，**更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束**。
这对很多应用来说都是难以接受的！

似乎`Serial`收集器成了一个老而无用，食之无味弃之可惜的鸡肋了，但实际上到现在为止，它依然是 **虚拟机
运行在`Client`模式下的默认新生代收集器**。它也有着优于其他收集器的地方：简单而高效，对于限定单个CPU
的环境来说，`Serial`收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
所以，**`Serial`收集器对于运行在`Client`模式下的虚拟机来说是一个很好的选择**。

### ParNew收集器（新生代）
**`ParNew`收集器其实就是`Serial`收集器的多线程版本**，除了使用多多条线程进行垃圾收集之外，其余都完全一样。

`ParNew`收集器除了多线程收集之外，其他与`Serial`收集器相比并没有太多创新之处，但它却是许多运行在
`Server`模式下的虚拟机中首先的新生代收集器，其中有一个与性能无关但很重要的原因是，除了`Serial`收集器外，
目前只有它能与`CMS`收集器配合工作（不幸的是，`CMS`作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生
代收集器`Parallel Scavenge`配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择`ParNew`
或`Serial`收集器中的一个）。

`ParNew`收集器在单CPU的环境中绝对不会有比`Serial`收集器更好的效果。当然，随着可以使用的CPU的数量的
增加，它对于GC时系统资源的利用还是很有好处的。**它默认开启的收集线程数与CPU的数量相同**，在CPU非常多（
譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用
**`-XX:ParallelGCThreads`** 参数来限制垃圾收集的线程数。

### Parallel Scavenge收集器（新生代）
`Parallel Scavenge`收集器也是一个新生代收集器，它也是使用复制算法的收集器。它的关注点与其他收集器不同，
`CMS`等收集器的关注点尽可能地缩短垃圾收集时用户线程停顿时间，而`Parallel Scavenge`收集器的目标则是
**达到一个可控制的吞叶量**。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 **吞吐量 =
运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）** ，虚拟机总共运行了100分钟，其中垃圾收集花掉
1分钟，那吞吐量就是99%。
