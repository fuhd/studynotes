垃圾收集器
================================================
收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

![垃圾收集器](img/垃圾收集器.jpg)

这里讨论的收集器基于Sun HotSpot虚拟机1.6版 Update 22，它包含的所有收集器如上图所示。
上图展示了7种作用于不同分代的收集器，**如果两个收集器之间存在连线，就说明它们可以搭配使用**。

### Serial收集器（新生代）
`Serial`收集器是最基本 ，历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。
这个收集器是一个 **单线程的收集器**，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程
去完成垃圾收集工作，**更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束**。
这对很多应用来说都是难以接受的！

似乎`Serial`收集器成了一个老而无用，食之无味弃之可惜的鸡肋了，但实际上到现在为止，它依然是 **虚拟机
运行在`Client`模式下的默认新生代收集器**。它也有着优于其他收集器的地方：简单而高效，对于限定单个CPU
的环境来说，`Serial`收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
所以，**`Serial`收集器对于运行在`Client`模式下的虚拟机来说是一个很好的选择**。

### ParNew收集器（新生代）
**`ParNew`收集器其实就是`Serial`收集器的多线程版本**，除了使用多多条线程进行垃圾收集之外，其余都完全一样。

`ParNew`收集器除了多线程收集之外，其他与`Serial`收集器相比并没有太多创新之处，但它却是许多运行在
`Server`模式下的虚拟机中首先的新生代收集器，其中有一个与性能无关但很重要的原因是，除了`Serial`收集器外，
目前只有它能与`CMS`收集器配合工作（不幸的是，`CMS`作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生
代收集器`Parallel Scavenge`配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择`ParNew`
或`Serial`收集器中的一个）。

`ParNew`收集器在单CPU的环境中绝对不会有比`Serial`收集器更好的效果。当然，随着可以使用的CPU的数量的
增加，它对于GC时系统资源的利用还是很有好处的。**它默认开启的收集线程数与CPU的数量相同**，在CPU非常多（
譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用
**`-XX:ParallelGCThreads`** 参数来限制垃圾收集的线程数。

### Parallel Scavenge收集器（新生代）
`Parallel Scavenge`收集器也是一个新生代收集器，它也是使用复制算法的收集器。它的关注点与其他收集器不同，
`CMS`等收集器的关注点尽可能地缩短垃圾收集时用户线程停顿时间，而`Parallel Scavenge`收集器的目标则是
**达到一个可控制的吞叶量**。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 **吞吐量 =
运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）** ，虚拟机总共运行了100分钟，其中垃圾收集花掉
1分钟，那吞吐量就是99%。

**停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地
利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务**。

`Parallel Scavenge`收集器提供了两个参数用于精确控制吞吐量，分别是 **控制最大垃圾收集停顿时间** 的
**`-XX:MaxGCPauseMillis`** 参数及直接 **设置吞吐量大小** 的 **`-XX:GCTimeRatio`** 参数。

`MaxGCPauseMillis`参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。
**GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的**：系统把新生代调小一些，收集300M新生代肯定比收集
500M快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，
每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

`GCTimeRatio`参数的值应当是一个 `0< x <100` 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的
倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/(1+19)），默认值为99，就是允许最大1％（1/(1+99)）
的垃圾收集时间。

由于与吞吐量关系密切，`Parallel Scavenge`收集器也经常被称为 **“吞吐量优先”收集器**。除上述两个参数之外，
`Parallel Scavenge`收集器还有一个参数 **`-XX:+UseAdaptiveSizePolicy`** 值得关注。这是一个开关参数，
当这个参数打开之后，就不需要手工指定新生代的大小（**-Xmn**）以及`Eden`与`Survivor`区的比例（**-XX:SurvivorRatio**），
还包括晋升老年代对象年龄（**-XX:PretenureSizeThreshold**）等细节参数了，虚拟机会根据当前系统的运行
情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。这种调节方式称为 **GC自适应的调节策略（GC Ergonomics）**。
**如果对收集器运作原理不太了解，手工优化存在困难的时候，使用`Parallel Scavenge`收集器配合自适应调节策略，
把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如`-Xmx`设置最大堆），
然后使用`MaxGCPauseMillis`参数（更关注最大停顿时间）或`GCTimeRatio`参数（更关注吞吐量）给虚拟机设立一个优化目标，
那些具体细节参数的调节工作就由虚拟机完成了**！
