函数式接口
==========================
lambda表达式必须实现一个函数式接口。`java.util.function`包下的接口是官方提供的函数式接口。

### 函数式接口与函数类型
示例：
```java
//函数接口
public interface UnaryOperator<T> { T apply(T t); }
```
描述了如下函数：
```java
//函数类型，第1个T是参数，第2个T是返回类型，f是引用
f: T -> T
```
`f: T -> T`就是 **函数类型** 。函数类型是`lambda`必须匹配的，这包括通过装箱或拆箱，增大或缩小范围等手段实现的类型适配。

### java.util.function包
`java.util.function`包中有 **4种** 基本的函数式接口类型，总共衍生了 **40多** 种函数式接口类型。
这40多种类型都是通过 **3种不同路由的各种组合** 由这4个类型演化而来的。4种基本的函数式接口类型，如下表：

接口|参数类型|返回类型|示例
---|-------|-------|----
Consumer<T>|T|void|s -> System.out.print(s)
Predicate<T>|T|boolean|s -> s.isEmpty()
Supplier<T>|无|T|() -> new String()
Function<T,U>|T|U|s -> new Integer(s)

**注**：关于泛型叁数。`T`表示`type`，代表类型；`E`表示`element`，代表集合中的元素；`K`表示`key`，代表Map中的key；
`V`表示`value`，代表Map中的value；`T`不够用时，还会用到`U`或`S`，表示任意类型。`R`表示`Return`，代表返回类型。
#### 原生特化
这些接口使用原生类型替换掉类型参数。代码示例：
```java
interface LongFunction<R>{R apply(long value);}
interface ToIntFunction<T>{int applyAsInt(T value);}
interface LongToIntFunction{int applyAsInt(long value);}
```
#### Consumer，Predicate与Function的函数类型都接收单个参数，也有接收两个参数的相应接口
示例：
```java
interface BiConsumer<T,U>{void accept(T t,U u);}
interface BiFunction<T,U,R>{R apply(T t,U u);}
interface ToIntBiFunction<T,U>{int apply(T t,U u);}
```
#### Function的常见用法要求其参数与结果拥有相同的类型
示例：
```java
interface UnaryOperator<T> extends Function<T,T> {..................}
interface BinaryOperator<T> extends BiFunction<T,T,T> {.............}
interface IntBinaryOperator {int applyAsInt(int left,int right);}
```

### 自定义函数式接口
如果你的用例没有被`java.util.function`包下的函数式接口涵盖，那么你可以很轻松地声明自己的函数式接口，
不过最佳实践则是在可能的情况下使用库中的函数式接口。

自定义函数式接口，要使用`@FunctionalInterface`来注解自定义的函数式接口。这样编译器就可以 **检查接口只会声明
一个抽象方法** ，同时相应的`Javadoc`也会自动添加说明部分。

### java.util.function包下的函数式接口

接口|描述
---|------
BiConsumer<T,U>|接受两个输入参数，不返回结果
BiFunction<T,U,R>|接受两个输入参数，并返回一个结果
BinaryOperator<T>|接受两个输入参数，并返回一个结果，它们三个都是同一类型
BiPredicate<T,U>|接受两个输入参数，并返回一个boolean值
BooleanSupplier|没有输入参数，但返回一个boolean值
Consumer<T>|接受一个参数，不返回结果
DoubleBinaryOperator|接受两个double类型的参数，并返回一个double类型的结果
DoubleConsumer|接受一个double类型的参数，不返回结果
DoubleFunction<R>|接受一个double类型的参数，并返回一个结果
DoublePredicate|接受一个double类型的参数，并返回一个boolean结果
DoubleSupplier|没有输入参数，但返回一个double类型的结果
DoubleToIntFunction|接受一个double类型的参数，并返回一个int类型的值
DoubleToLongFunction|接受一个double类型的参数，并返回一个long类型的值
DoubleUnaryOperator|接受一个double类型的参数，并返回一个double类型的值
Function<T,R>|接受一个参数，并返回一个结果
IntBinaryOperator|接受两个int类型参数，并返回一个int类型的结果
IntConsumer|接受一个int类型参数，不返回结果
IntFunction<R>|接受一个int类型参数，返回一个结果
IntPredicate|接受一个int类型参数，返回一个boolean结果
IntSupplier|没有输入参数，但返回一个int类型结果
IntToDoubleFunction|接受一个int类型的参数，并返回一个double类型的结果
IntToLongFunction|接受一个int类型的参数，并返回一个long类型的结果
IntUnaryOperator|接受一个int类型的参数，并返回一个int类型的结果
LongBinaryOperator|接受两个long类型的参数，并返回一个long类型的结果
LongConsumer|接受一个long类型的参数，不返回结果
LongFunction<R>|接受一个long类型的参数，返回一个结果
LongPredicate|接受一个long类型的参数，返回一个boolean值结果
LongSupplier|没有输入参数，但返回一个long类型的结果
LongToDoubleFunction|接受一个long类型的参数，并返回一个double类型的结果
LongToIntFunction|接受一个long类型的参数，并返回一个int类型的结果
LongUnaryOperator|接受一个long类型的参数，并返回一个long类型的结果
ObjDoubleConsumer<T>|接受一个Object类型的参数和一个double类型的参数，不返回结果
ObjIntConsumer<T>|接受一个Object类型的参数和一个int类型的参数，不返回结果
ObjLongConsumer<T>|接受一个Object类型的参数和一个long类型的参数，不返回结果
Predicate<T>|接受一个参数，并返回一个boolean类型的结果
Supplier<T>|没有输入参数，但返回一个结果
ToDoubleBiFunction<T,U>|接受两个参数，并返回一个double类型的结果
ToDoubleFunction<T>|接受一个参数，并返回一个double类型的结果
ToIntBiFunction<T,U>|接受两个参数，并返回一个int类型的结果
ToIntFunction<T>|接受一个参数，并返回一个int类型的结果
ToLongBiFunction<T,U>|接受两个参数，并返回一个long类型的结果
ToLongFunction<T>|接受一个参数，并返回一个long类型的结果
UnaryOperator<T>|接受一个参数，并返回一个与参数相同类型的结果
