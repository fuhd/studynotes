流基础
=====================
因为 **流不存储值：流的目的是处理值**。例如，考虑一个将集合作为源的流：创建流并不会导致数据流动，
当终止操作需要值时，流会从集合中获取值将其提供；最后，当所有集合值都被流提供后，流就被耗尽了，并且无法再
次使用。**流背后的中心思想是延迟计算：直到需要时才计算值** 。

从概念上来说，**流** 与 **迭代器** 非常类似，不过流具有一些重要的改进：

+ 流以一种对客户端更加友好的方式处理 **无元素** 的情况。
+ 迭代器总是以确定的顺序来处理值，与之不同，**流可以是无序的** 。
+ 流具有方法（中间操作），这些方法会接受行为性参数（对流的转换），然后返回转换后的流。这样就可以将流链接
到管道中。这不仅可以提供流式编程，还能在极大程度上提升性能。
+ 流会保留关于源的属性的信息，例如源值是否是有序的，总数是否是已知的，这样就可以对值处理进行优化，而迭代
器则是做不到这一点的，除了值本身外，迭代器并不保留任何其他信息。

延迟计算的一个重要优势可以通过`Stream`的“搜索”方法一探究竟：`findFirst`，`findAny`，`anyMatch`，
`allMatch`与`noneMatch`。它们都称为 **短路** 操作符，因为使用了这些方法就没必要处理流中的所有元素了。
例如，`anyMatch`需要找到一个满足其谓词（boolean值函数），让流处理完成的单个流元素，`allMatch`则需要
找到一个不满足其谓词的流元素。这无须生成和处理不必要的元素，能够极大地降低工作量，对于无限流来说，我们只需
要将 **延迟计算** 与 **短路操作符** 组合起来就可以完成流的处理。

延迟计算还提供了另外一个好处：可以 **将多个逻辑运算合并到一起并统一应用到数据上** 。示例：
```java
OptionalDouble maxDistance = IntList.parallelStream()
  .map(i -> new Point(i % 3, i / 3))
  .mapToDouble(p -> p.distance(0,0))
  .max();
```
这种流式风格自然又易读，不过要想理解它则需要考虑到 **隐匿的延迟计算** 。出于演示的目的，如果将管道拆分为
**流声明** 与 **终止操作调用** ，那就更容易看清楚这一点了：
```java
//流声明
DoubleStream ds = IntList.parallelStream()
  .map(i -> new Point(i % 3, i / 3))
  .mapToDouble(p -> p.distance(0,0));
//终止操作调用
OptionalDouble maxDistance = ds.max();
```

### 面向并行的代码
java中，虽然 **顺序处理** 依然是个非常重要的计算模型，不过它不再是唯一一个参考模型（java8提供了 **并行处理** ）。
无论是串行还是并行，代码的运行结果与如何执行没有关系，那么我们就需要重新思考计算模型了（尝试用并行处理）。

一般来说，一个操作在两种模式下并不一定会产生出完全相同的结果：例如，`forEach`就可以在不确定的顺序下执行。**`forEach`
与其他非确定性操作在串行与并行模式下的顺序都是不确定的** 。与之相反，在这两种模式下顺序确定的操作则会保证以确定的顺序执行。
之所以会提供`forEach`之类的非确定性操作，**原因在于不必要的确定性是有着很高的性能代价的** 。如果选择相应的确定性版本
（例如：`forEachOrdered`），那就要清楚地认识到顺序是问题之所需，而非仅仅是随意的选择。

**关键是思维上的转变，我们再来整理一下：** 迭代的程序包含了两类信息，**要做什么**，以及 **如何做**。
将这两个概念解耦就得到一种开发模型，我们编写面向 **并行** 的代码，只需要指定 **函数式行为** 即可，然后再单独指定其 **执行模式** 。
在理想的情况下，**会将执行的实现委托给库来做** 。

### 原生流
Java5中引入的自动装箱与自动拆箱特性使得程序员无须考虑原生类型值与相应的包装类型值之间的差别。编译器经常
会发现在方法调用或是赋值时，本来需要的是包装值，但实际提供的却是原生值（反之亦然），它会自动进行转换。
这是非常便捷的，并且有助于编写可读性更好的程序。不过，这会导致 **频繁的装箱与拆箱操作，对性能造成很大影响** 。例如，
在如下看似没有问题的代码中增加变量i的值：
```java
Optional<Integer> max = Arrays.asList(1,2,3,4,5)
  .stream()
  .map(i -> i + 1)
  .max(Integer::compareTo);
```
这会在每次增加i值之前分别执行`Integer`的方法`intValue`与`valueOf`。我们希望在处理 **大规模集合值** 的应用中 **避免
这种开销** 。一种方式就是 **定义流，其元素是原生值而非引用值** 。除了 **性能上的改进** 外，这么做还会带来其他好处，对于只处理
数字的方法，如sum，以及创建包含一系列数字的流来说都很有用。例如，借助于类型`IntStream`（表示原生int值的流），上述代码可以
写成下面这样：
```java
OptionalInt max = IntStream.rangeClosed(1,5)
  .map(i -> i + 1)
  .max();
```
这么做会改进 **可读性** （使用了专门的`range`与`max`方法）与 **效率** （不再需要装箱与拆箱操作）。
**对于足够大的数据集来说，未装箱代码的速度要比相应装箱的代码快一个数量级** 。

原生流类型有`IntStream`，`LongStream`与`DoubleStream`，这取自最常用的数字类型，成本收益也是最好的。
如果应用需要其他数字类型的流，那么下面这些类型也是支持的。`float`值可以放到`DoubleStream`中；`char`,
`short`与`byte`值可以放到`IntStream`中；原生流的APIs都很相似，并且所有原生流都与引用流类型Stream很相似。

下面再来看看可能发生的 **流类型转换** ：
+ 原生流类型`IntStream`与`LongStream`拥有方法`asDoubleStream`，`IntStream`还有方法`asLongStream`，
这会导致每个原生值的范围变大，例如：
```java
DoubleStream ds = IntStream.rangeClosed(1,10).asDoubleStream();
```
+ 对于装箱来说，每个原生流类型都有一个方法`boxed`，它会返回恰当的包装类型的一个Stream，例如：
```java
Stream<Integer> is = IntStream.rangeClosed(1,10).boxed();
```
+ 对于拆箱来说，会通过调用恰当的映射转换操作，并提供恰当的拆箱方法将包装值的Stream转换为原生流。例如，
如下代码创建了一个Stream<Integer>，然后将其转换为IntStream：
```java
Stream<Integer> integerStream = Stream.of(1,2);
IntStream intStream = integerStream.mapToInt(Integer::intValue);
```
