使用和避免null
==============================================================
轻率地使用`null`可能会导致很多令人惊愕的问题。通过学习Google底层代码库，我们发现`95%`的集合类不接受`null`值作为元素。
我们认为， 相比默默地接受`null`，**使用快速失败操作拒绝`null`值对开发者更有帮助**。

此外，`Null`的含糊语义让人很不舒服。`Null`很少可以明确地表示某种语义，例如，`Map.get(key)`返回`Null`时，
可能表示`map`中的值是`null`，亦或`map`中没有`key`对应的值。`Null`可以表示失败、成功或几乎任何情况。
使用`Null`以外的特定值，会让你的逻辑描述变得更清晰。

`Null`确实也有合适和正确的使用场景，如在性能和速度方面`Null`是廉价的，而且在对象数组中，出现`Null`也是无法避免的。
但相对于底层库来说，**在应用级别的代码中，`Null`往往是导致混乱，疑难问题和模糊语义的元凶**，
就如同我们举过的`Map.get(key)`的例子。最关键的是，**`Null`本身没有定义它表达的意思**。

鉴于这些原因，**很多`Guava`工具类对`Null`值都采用快速失败操作**，除非工具类本身提供了针对`Null`值的因变措施。
此外，`Guava`还提供了很多工具类，让你更方便地用特定值替换`Null`值。

### Optional
`Guava`用`Optional<T>`表示 **可能为null的T类型引用**。一个`Optional`实例 **可能包含非`null`的引用**（我们称之为 **引用存在**），
也 **可能什么也不包括**（称之为 **引用缺失**）。它从不说包含的是`null`值，而是用存在或缺失来表示。

#### 创建Optional实例（以下都是静态方法）
| 方法 | 描述 |
| :--- | :--- |
| Optional.of(T) | 创建指定引用的`Optional`实例，若引用为`null`则快速失败 |
| Optional.absent() | 创建引用缺失的`Optional`实例 |
| Optional.fromNullable(T) | 创建指定引用的`Optional`实例，若引用为`null`则表示缺失 |

示例：
```java
package guava;

import com.google.common.base.Optional;

public class OptionalTest1 {

    public static void main(String[] args) {
        //创建指定引用的Optional实例，若引用为null则快速失败
        Optional<Integer> optional1 = Optional.of(5);
        //如果Optional包含非null的引用（引用存在），返回true，若引用为null，则抛异常
        System.out.println(optional1.isPresent());

        //创建引用缺失的Optional实例
        Optional<Integer> optional12 = Optional.absent();
        //这里不会抛异常，直接返回false
        System.out.println(optional12.isPresent());

        //创建指定引用的Optional实例，若引用为null则表示缺失
        Optional<Integer> optional3 = Optional.fromNullable(5);
        System.out.println(optional3.isPresent());
        Optional<Integer> optional4 = Optional.fromNullable(null);
        //引用缺失也不会抛异常，而是返回false
        System.out.println(optional4.isPresent());
    }
}
```
#### 用Optional实例查询引用（以下都是非静态方法）
| 方法 | 描述 |
| :--- | :--- |
| boolean isPresent() | 如果`Optional`包含非`null`的引用（引用存在），返回`true` |
| T get() | 返回`Optional`所包含的引用，若引用缺失，则抛出`java.lang.IllegalStateException` |
| T or(T) | 返回`Optional`所包含的引用，若引用缺失，返回指定的值 |
| T orNull() | 返回`Optional`所包含的引用，若引用缺失，返回`null` |
| Set<T> asSet() | 返回`Optional`所包含引用的单例不可变集，如果引用存在，返回一个只有单一元素的集合，如果引用缺失，返回一个空集合。 |

示例：
```java
package guava;

import com.google.common.base.Optional;

import java.util.Set;

public class OptionalTest2 {
    public static void main(String[] args) {
        Optional<Integer> optional1 = Optional.fromNullable(null);
        try {
            //返回Optional所包含的引用，若引用缺失，则抛出java.lang.IllegalStateException
            System.out.println(optional1.get());
        } catch (IllegalStateException e) {
            System.out.println(e.getMessage());
        }

        //返回Optional所包含的引用，若引用缺失，返回指定的值
        System.out.println(optional1.or(0));

        //返回Optional所包含的引用，若引用缺失，返回null
        System.out.println(optional1.orNull());

        //返回Optional所包含引用的单例不可变集，如果引用存在，返回一个只有单一元素的集合，如果引用缺失，返回一个空集合。
        Optional<Integer> optional2 = Optional.fromNullable(6);
        Set<Integer> set = optional2.asSet();
        set.forEach(i -> System.out.println(i));
    }
}
```
### 使用Optional的意义在哪儿？
使用`Optional`除了赋予`null`语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。**`Optional`迫使你积极思考引用缺失的情况，
因为你必须显式地从`Optional`获取引用**。直接使用`null`很容易让人忘掉某些情形。

如同 **输入参数**，**方法的返回值** 也可能是`null`。和其他人一样，你绝对很可能会忘记别人写的方法`method(a,b)`会返回一个`null`，
就好像当你实现`method(a,b)`时，也很可能忘记输入参数`a`可以为`null`。**将方法的返回类型指定为`Optional`，
也可以迫使调用者思考返回的引用缺失的情形**。
