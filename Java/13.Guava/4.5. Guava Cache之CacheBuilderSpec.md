Guava Cache之CacheBuilderSpec
===============================================================
**CacheBuilderSpec类以解析代表CacheBuilder配置的字符串的形式来创建CacheBuilder实例**。
需要说明的是，Guava **没有处理编译时异常**，这将会导致当传入的字符串无效时，会出现编译时异常，
下面是一个可以用来创建CacheBuilderSpec实例的有效字符串：
```java
//配置CacheBuilder的字符串
String configString = "concurrencyLevel=10,refreshAfterWrite=5s";
```
注意：间隔的整数后面的 **‘s’,‘m’，‘h’或‘d’** 对应于 **秒，分钟，小时或天数**，这里没有毫秒甚至纳秒级别的设置，
当我们指定好了配置的字符串，我们可以通过下面的方式创建一个CacheBuilderSpec实例：
```java
//配置CacheBuilder的字符串
String configString = "concurrencyLevel=10,refreshAfterWrite=5s";
//解析字符串，创建CacheBuilderSpec实例
CacheBuilderSpec spec = CacheBuilderSpec.parse(configString);
```
我们可以通过下面的方式，使用CacheBuilderSpec实例创建CacheBuilder实例：
```java
//配置CacheBuilder的字符串
String configString = "concurrencyLevel=10,refreshAfterWrite=5s";
//解析字符串，创建CacheBuilderSpec实例
CacheBuilderSpec spec = CacheBuilderSpec.parse(configString);
//通过CacheBuilderSpec实例构造CacheBuilder实例
CacheBuilder.from(spec);
```
这里，我们调用了CacheBuilder中的 **静态from** 方法，使用CacheBuilderSpec对象构造了CacheBuilder实例，
通过格式化的字符串设置了CacheBuilder的属性，我们可以使用返回的CacheBuilder实例。完整示例如下：
```java
//配置CacheBuilder的字符串
String spec = "concurrencyLevel=10,expireAfterAccess=5m,softValues";
//解析字符串，创建CacheBuilderSpec实例
CacheBuilderSpec cacheBuilderSpec = CacheBuilderSpec.parse(spec);
//通过CacheBuilderSpec实例构造CacheBuilder实例
CacheBuilder cacheBuilder = CacheBuilder.from(cacheBuilderSpec);
//ticker：设置缓存条目过期时间
//removalListener：监听缓存条目的移除
cacheBuilder.ticker(Ticker.systemTicker())
    .removalListener(new TradeAccountRemovalListener())
    .build(new CacheLoader<String, TradeAccount>() {
        @Override
        public TradeAccount load(String key) throws Exception {
            return tradeAccountService.getTradeAccountById(key);
        }
    });
```