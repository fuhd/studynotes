Guava Cache之LoadingCache
==============================================================
### LoadingCache
LoadingCache接口扩展了Cache接口的 **自动装载** 的功能，考虑下面的代码实例：
```java
Book book = loadingCache.get(id);
```
在上面的代码中， 如果book对象 **在get方法调用执行的时候不可用**，LoadingCache知道怎样返回对象，
保存在缓存中，然后返回value值。

#### 加载值
由于 **LoadingCache的实现是线程安全的**，通过 **同样的key值** 调用get方法，当缓存还在装载的时候就会阻塞线程。
一旦value值被加载，该调用将返回最原始的调用get方法返回的value值，然而，**多个通过不同key值的调用则会并发的加载**，
如果我们拥有一个键值的集合，并且想要去检索每个键对应的value值，我们需要像下面这样调用：
```java
ImmutableMap<key,value> map = cache.getAll(Iterable<? Extends  key>);
```
如上所示，getAll方法返回了一个不可变的Map集合。

### 刷新值
LoadingCache同样提供了一种 **缓存中更新value值** 的机制：
```java
refresh(key);
```
**通过调用refresh方法，LoadingCache会检索到对应key新的value值**，当前的value值在新的value值返回前不会被从缓存出废弃，
这意味着如果在加载的过程中调用get方法，则会返回缓存中当前的value值。如果 **在refresh方法调用中出现异常**，原始的value值会依然在缓存中保存。
需要记住的是：**如果value值被异步的检索，在value值被真正的更新前，方法都将会返回原始的value值**。





