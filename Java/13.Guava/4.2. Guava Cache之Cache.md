Guava Cache之Cache
============================================================
Guava Cache缓存机制有两个基本的接口：**Cache和LoadingCache，LoadingCache接口继承自Cache接口**。

### Cache
Cache接口提供了 **键和值的映射**，但是Cache接口中提供的一些方法比HashMap提供的更基本。
Cache使用了传统的 **put方法** 设置value值：
```java
put(key,value);
```
但是获取value的时候，Guava Cache有自己的调用风格，如下：
```java
V value = cache.get(key, Callable<? Extends V> value);
```
上面的方法会 **检索当前的value值，如果值不存在的话会从Callback实例中提取value值，通过key关联value，并返回相应的value值**，
它为我们提供了通过调用一个方法来替代下面风格的编程：
```java
value = cache.get(key);
if(value == null){
    value = someService.retrieveValue();
    cache.put(key,value);
}
```
一个 **回调函数** 的使用意味着一个 **异步操作** 可能会发生，但是 **如果我们不需要执行一个异步任务我们又该怎么做呢**？
我们可以使用com.google.common.util.concurrent包里面的 **Callables类**，Callables提供了一个方法用于处理Callable接口，
使用代码如下所示：
```java
 Callable<String> value = Callables.returning("Foo");
```
在上面的代码中，我们调用 **returning()方法** 构造并返回了一个 **Callable实例**，当这个Callable实例调用get方法
时会返回我们传递的“Foo”值，所以我们可以重新实现一下我们最初的代码：
```java
cache.get(key,Callables.returning(someService.retrieveValue());
```
