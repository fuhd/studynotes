shiro缓存机制
=====================================================================
Shiro 提供了类似于 Spring 的 Cache 抽象，即 Shiro 本身不实现 Cache，但是对 Cache 进行了又抽象，
方便更换不同的底层 Cache 实现。

Cache 接口：
```java 
public interface Cache<K, V> {
    //根据 Key 获取缓存中的值
    public V get(K key) throws CacheException;
    //往缓存中放入 key-value，返回缓存中之前的值
    public V put(K key, V value) throws CacheException;
    //移除缓存中 key 对应的值，返回该值
    public V remove(K key) throws CacheException;
    //清空整个缓存
    public void clear() throws CacheException;
    //返回缓存大小
    public int size();
    //获取缓存中所有的 key
    public Set<K> keys();
    //获取缓存中所有的 value
    public Collection<V> values();
}
```

Shiro 提供的 CacheManager 接口：
```java 
public interface CacheManager {
    //根据缓存名字获取一个 Cache
    public <K, V> Cache<K, V> getCache(String name) throws CacheException;
}
```

Shiro 还提供了 CacheManagerAware 用于注入 CacheManager：
```java 
public interface CacheManagerAware {
    //注入 CacheManager
    void setCacheManager(CacheManager cacheManager);
}
```

shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如 Realm）是否
实现了 CacheManagerAware 并自动注入相应的 CacheManager。

### Realm 缓存
Shiro 提供了 CachingRealm，其实现了 CacheManagerAware 接口，提供了缓存的一些基础实现；
另外 AuthenticatingRealm 及 AuthorizingRealm 分别提供了对 AuthenticationInfo 和
AuthorizationInfo 信息的缓存。

Realm属性：
+ `cachingEnabled`：启用缓存，默认 false；
+ `authenticationCachingEnabled`：启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 false；
+ `authenticationCacheName`：缓存 AuthenticationInfo 信息的缓存名称；
+ `authorizationCachingEnabled`：启用授权缓存，即缓存 AuthorizationInfo 信息，默认 false；
+ `authorizationCacheName`：缓存 AuthorizationInfo 信息的缓存名称；
+ `cacheManager`：缓存管理器；

和 Spring 集成时可以考虑直接使用 Spring 的 Cache 抽象，可以考虑使用 SpringCacheManagerWrapper，
其对 Spring Cache 进行了包装， 转换为 Shiro 的 CacheManager 实现。示例：

https://github.com/zhangkaitao/es/blob/master/web/src/main/java/org/apache/shiro/cache/spring/SpringCacheManagerWrapper.java

### Session 缓存
如 securityManager 实现了 SessionsSecurityManager，其会自动判断 SessionManager 是否实现了 CacheManagerAware 接口，
如果实现了会把 CacheManager 设置给它。然后 sessionManager 会判断相应的 sessionDAO（如继承自 CachingSessionDAO）是否实现了
CacheManagerAware， 如果实现了会把 CacheManager 设置给它；


