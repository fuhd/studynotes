AOF
====================================================================

### 使用AOF
开启AOF功能需要设置配置：**`appendonly yes`，默认不开启**。AOF文件名通过 **`appendfilename`** 配置设置，
**默认文件名是`appendonly.aof`**。保存路径同RDB持久化方式一致，通过 **dir** 配置指定。AOF的工作流程操作：
**命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）**。

流程如下：
1. 所有的写入命令会追加到 **`aof_buf`** （缓冲区）中。
2. AOF缓冲区根据对应的策略向硬盘做同步操作。
3. 随着AOF文件越来越大，需要定期对AOF文件 **进行重写，达到压缩的目的**。
4. 当Redis服务器重启时，可以加载AOF文件进行数据恢复。

### 命令写入
AOF命令写入的内容直接是 **文本协议格式**。例如`set hello world`这条命令，在 **AOF缓冲区** 会追加如下文本：
```
＊3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\n\nworld\r\n
```
这里介绍关于AOF的两个疑惑：
1. AOF为什么直接采用文本协议格式？可能的理由如下：
  + 文本协议具有很好的兼容性。
  + 开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了一次处理开始。
  + 文本协议具有可读性，方便直接修改和处理。
2. AOF为什么把命令追加到`aof_buf`中？**Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，
那么性能完全取决于当前硬盘负载。先写入缓冲区`aof_buf`中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略**，
在性能和完全性方面做出平衡。

### 文件同步
Redis提供了 **多种** AOF缓冲区同步文件策略，由参数 **`appendfsync`** 控制，不同值的含义如下：

| 可配置值 | 说明 |
|------------ | :----------------- |
| always | 命令写入`aof_buf`后调用系统`fsync`操作同步到AOF文件，`fsync`完成后线程返回 |
| everysec | 命令写入aof_buf后调用系统`write`操作，`write`完成后线程返回。`fsync`同步文件操作由专门线程每秒调用一次 |
| no | 命令写入`aof_buf`后调用系统`write`操作，不对AOF文件做`fsync`同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒 |

系统调用`write`和`fsync`说明：
+ **`write`** 操作会触发 **延迟写（delayed write）机制**。Linux在内核提供 **页缓冲区** 用来提高硬盘IO性能。
**`write`操作在写入系统缓冲区后直接返回**。同步硬盘操作依赖于系统调度机制，例如，缓冲区页空间写满或达到
特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。
+ **`fsync`** 针对 **单个文件操作（比如AOF文件），做强制硬盘同步**，`fsync`将阻塞直到写入硬盘完成后返回，
保证了数据持久化。

+ 配置为 **`always`** 时，**每次写入都要同步AOF文件**，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，
显然跟Redis高性能特性背道而驰，**不建议配置**。
+ 配置为 **`no`**，由于操作系统每次同步AOF文件的 **周期不可控**，而且会 **加大每次同步硬盘的数据量**，
虽然提升了性能，**但数据安全性无法保证**。
+ 配置为 **`everysec`，是建议的同步策略，也是默认配置**，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下
丢失1秒的数据。（严格来说最多丢失1秒数据是不准确的）
