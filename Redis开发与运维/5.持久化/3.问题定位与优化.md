问题定位与优化
===============================================================
**Redis持久化功能一直是影响Redis性能的高发地**。

### fork操作
当Redis做 **RDB** 或 **AOF重写** 时，一个必不可少的操作就是 **执行`fork`操作创建子进程**，对于大多数
操作系统来说 **`fork`是个重量级** 的。虽然 **`fork`创建的子进程不需要拷贝父进程的物理内存空间，但是会复制
父进程的空间内存页表**。例如对于 **10GB** 的Redis进程，需要复制 **大约20MB** 的内存页表，
因此 **`fork`操作耗时跟进程总内存量息息相关，如果使用虚拟化技术，特别是Xen虚拟机，`fork`操作会更耗时**。

#### fork耗时问题定位
对于高流量的Redis实例QPS可达5万以上，如果`fork`操作耗时在秒级别将拖慢Redis几万条命令执行，对线上
应用延迟影响非常明显。**正常情况下`fork`耗时应该是每GB消耗20毫秒左右**。可以在 **`info stats`&& 统计中查
**`latest_fork_usec`** 指标获取最近一次`fork`操作耗时，单位 **微秒**。

如何改善`fork`操作的耗时：
1. **优先使用物理机** 或者 **高效支持`fork`操作的虚拟化技术**，避免使用`Xen`。
2. 控制Redis实例最大可用内存，**`fork`耗时跟内存量成正比，线上建议每个Redis实例内存控制在10GB以内**。
3. 合理配置Linux内存分配策略，避免物理内存不足导致 `fork`失败，具体细节见“Linux配置优化”一节。
4. **降低`fork`操作的频率**，如适度放宽AOF自动触发时机，避免不必要的全量复制等。

### 子进制开销监控和优化
子进程负责 **AOF** 或者 **RDB文件的重写**，它的运行过程主要涉及 **CPU**、**内存**、**硬盘** 三部分的消耗。

#### CPU
+ **CPU开销分析**。子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90％。
+ **CPU消耗优化**。Redis是CPU密集型服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。

**不要和其他CPU密集型服务部署在一起，造成CPU过度竞争。如果部署多个Redis实例，尽量保证同一时刻只有一个子进程
执行重写工作**，具体细节见“多实例部署”。
