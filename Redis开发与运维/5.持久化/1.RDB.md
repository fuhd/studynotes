RDB
===================================================================
Redis支持 **RDB** 和 **AOF** 两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时
利用之前持久化的文件即可实现数据恢复。

**RDB持久化是把当前进程数据生成快照保存到硬盘的过程**，触发RDB持久化过程分为 **手动触发** 和 **自动触发**。

### 触发机制
手动触发分别对应 **`save`** 和 **`bgsave`** 命令：
+ **save命令：** **阻塞当前Redis服务器**，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，
**线上环境不建议使用**。
+ **bgsave命令： Redis进程执行`fork`操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。
阻塞只发生在`fork`阶段，一般时间很短**。

显然 **`bgsave`命令是针对`save`阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用`bgsave`的方式，
而`save`命令已经废弃**。

除了执行命令手动触发之外，**Redis内部还存在自动触发RDB的持久化机制**，例如：
1. 使用`save`相关配置，如 **`save m n`**。表示 **m秒内数据集存在n次修改时，自动触发`bgsave`**。
2. 如果 **从节点执行全量复制操作**，主节点自动执行`bgsave`生成RDB文件并发送给从节点。
3. 执行 **`debug reload`命令** 重新加载Redis时，也会自动触发`save`操作。
4. **默认情况下执行`shutdown`命令时，如果没有开启`AOF`持久化功能则自动执行`bgsave`**。

### 流程说明
`bgsave`是主流的触发RDB持久化方式。
1. 执行`bgsave`命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在`bgsave`命令直接返回。
2. 父进程执行`fork`操作创建子进程，`fork`操作过程中父进程会阻塞，通过`info stats`命令查看`latest fork usec`选项，
可以获取最近一个`fork`操作的耗时，单位为微秒。
3. 父进程`fork`完成后，`bgsave`命令返回 `Background saving started`信息并不再阻塞父进程，
可以继续响应其他命令。
4. 子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行`lastsave`命令
可以获取最后一次生成RDB的时间，对应`info`统计的`rdb_last_save_time`选项。
5. 进程发送信号给父进程表示完成，父进程更新统计信息。

### RDB文件的处理
#### 保存
RDB文件保存在 **`dir`配置指定的目录** 下，文件名通过 **`dbfilename`** 配置指定。可以通过执行
**`config set dir {newDir}`** 和 **`config set dbfilename {newFileName}`** 运行期动态执行，
当下次运行时RDB文件会保存到新目录。

**注意：** 当遇到坏盘或磁盘写满等情况时，可以通过 `config set dir {newDir}` 在线修改文件路径到可用的
磁盘路径，之后执行`bgsave`进行磁盘切换，**同样适用于AOF持久化文件**。

#### 压缩
**Redis默认采用LZF算法** 对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，**默认开启**，
可以通过参数 **`config set rdbcompression {yes|no}`** 动态修改。

**注意：** 虽然压缩RDB会消耗CPU，但可大幅降低文件的体积，方便保存到硬盘或通过网络发送给从节点，**因此线上建议开启**。
