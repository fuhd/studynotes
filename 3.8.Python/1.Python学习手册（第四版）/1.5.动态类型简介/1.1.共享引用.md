共享引用
================================================================================
到现在为止，我们已经看到了单个变量被赋值引用了多个对象的情况。现在，**在交互模式下，引入另一个变
量，并看一下变量名和对象的变化**：
```python
>>> a = 3
>>> b = a
```
实际的效果就是变量`a`和`b`都引用了相同的对象（也就是说，**指向了相同的内存空间**）。在这Python
中叫做 **共享引用————多个变量名引用了同一个对象**。

下一步，假设运行另一个语句扩展了这样的情况：
```python
>>> a = 3
>>> b = a
>>> a = 'spam'
```
尽管这样，**这并不会改变`b`的值，`b`仍然引用原始的对象————整数3**。如果我们把变量`b`改成'spam'
的话，也会发生同样的事情：赋值只会改变`b`，不会对`a`有影响。例如，思考下面这三条语句：
```python
>>> a = 3
>>> b = a
>>> a = a + 2
```
Python让变量`a`引用对象3，让`b`引用与`a`相同的对象。最后的那个赋值将`a`设置为一个完全不同的对
象（在这种情况下，整数5是表达式`+`的计算结果）。**这并不会产生改变了`b`的副作用**。事实上，**是
没有办法改变对象3的值，因为整数是不可变的**，因此没有方法在原处修改它。

在Python中，**变量总是一个指向对象的指针**，而不是可改变的内存区域的标签。给一个变量赋一个新的值，
并不是替换了原始的对象，**而是让这个变量去引用完全不同的一个对象**。实际的效果就是对一个变量赋值，
**仅仅会影响那个被赋值的变量**。

**当可变的对象以及原处的改变进入这个场景，那么这个情形会有某种改变**，后续介绍。

## 1.共享引用和在原处修改
**有一些对象和操作确实会在原处改变对象**。例如，在一个 **列表** 中对一个偏移进行赋值确实会改变
这个列表对象，而不是生成一个新的列表对象。**对于支持这种在原处修改的对象，共享引用时的确需要加倍
的小心**，因为对一个变量名的修改会影响其他的变量。

关于列表的示例：
```python
>>> L1 = [2,3,4]
>>> L2 = L1
```
`L1`是一个包含了对象2、3和4的列表。在运行两个赋值后，`L1`和`L2`引用了相同的对象。如果我们现在像
下面这样去扩展这个交互：
```python
>>> L1 = [2,3,4]
>>> L2 = L1
>>> L1[0] = 24
>>> L1
[24, 3, 4]
>>> L2
[24, 3, 4]
```
在这里，没有改变`L1`，改变了`L1`所引用的对象的一个元素。这类修改会覆盖列表对象中的某部分。因为这
个列表对象是与其他对象共享的，那么一个像这样在原处的改变不仅仅会对`L1`有影响。在这个例子中，也会
对`L2`产生影响，因为它与`L1`都引用了相同的对象。

**如果你不想要这样的现象发生，需要Python拷贝对象，而不是创建引用**。有很多种拷贝一个列表的办法，
包括内置列表函数以及标准库的`copy`模块。也许最常用的办法就是从头到尾的分片：
```python
>>> L1 = [2,3,4]
>>> L2 = L1[:]
>>> L1[0] = 24
>>> L1
[24, 3, 4]
>>> L2
[2, 3, 4]
```
这里，**对`L1`的修改不会影响`L2`，因为`L2`引用的是`L1`所引用对象的一个拷贝**。也就是说，两个变
量指向了不同的内存区域。

**注意这种分片技术不会应用在其他的可变的核心类型（字典与集合，因为它们不是序列）上，复制一个字典
或集合应该使用`X.copy()`方法调用。而且，注意标准库中的`copy`模块有一个通用的复制任意对象类型的
调用，也有一个拷贝嵌套对象结构（例如，嵌套了列表的一个字典）的调用**：
```python
import copy
X = copy.copy(Y)
X = copy.deepcopy(Y)
```
我们将在后续深入了解列表和字典，并复习共享引用和拷贝的概念。这里记住有些对象是可以在原处改变的（
即可变的对象），这种对象往往对这些现象总是很开放。**在Python中，这种对象包括了列表、字典以及一些
通过`class`语句定义的对象。如果这不是你期望的现象，可以根据需要直接拷贝对象**。









































dd
