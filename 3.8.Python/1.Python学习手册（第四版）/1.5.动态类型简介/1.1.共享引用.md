共享引用
================================================================================
到现在为止，我们已经看到了单个变量被赋值引用了多个对象的情况。现在，**在交互模式下，引入另一个变
量，并看一下变量名和对象的变化**：
```python
>>> a = 3
>>> b = a
```
实际的效果就是变量`a`和`b`都引用了相同的对象（也就是说，**指向了相同的内存空间**）。在这Python
中叫做 **共享引用————多个变量名引用了同一个对象**。

下一步，假设运行另一个语句扩展了这样的情况：
```python
>>> a = 3
>>> b = a
>>> a = 'spam'
```
尽管这样，**这并不会改变`b`的值，`b`仍然引用原始的对象————整数3**。如果我们把变量`b`改成'spam'
的话，也会发生同样的事情：赋值只会改变`b`，不会对`a`有影响。例如，思考下面这三条语句：
```python
>>> a = 3
>>> b = a
>>> a = a + 2
```
Python让变量`a`引用对象3，让`b`引用与`a`相同的对象。最后的那个赋值将`a`设置为一个完全不同的对
象（在这种情况下，整数5是表达式`+`的计算结果）。**这并不会产生改变了`b`的副作用**。事实上，**是
没有办法改变对象3的值，因为整数是不可变的**，因此没有方法在原处修改它。

在Python中，**变量总是一个指向对象的指针**，而不是可改变的内存区域的标签。给一个变量赋一个新的值，
并不是替换了原始的对象，**而是让这个变量去引用完全不同的一个对象**。实际的效果就是对一个变量赋值，
**仅仅会影响那个被赋值的变量**。

**当可变的对象以及原处的改变进入这个场景，那么这个情形会有某种改变**，后续介绍。

## 1.共享引用和在原处修改
**有一些对象和操作确实会在原处改变对象**。例如，在一个 **列表** 中对一个偏移进行赋值确实会改变
这个列表对象，而不是生成一个新的列表对象。**对于支持这种在原处修改的对象，共享引用时的确需要加倍
的小心**，因为对一个变量名的修改会影响其他的变量。

关于列表的示例：
```python
>>> L1 = [2,3,4]
>>> L2 = L1
```
`L1`是一个包含了对象2、3和4的列表。在运行两个赋值后，`L1`和`L2`引用了相同的对象。如果我们现在像
下面这样去扩展这个交互：
```python
>>> L1 = [2,3,4]
>>> L2 = L1
>>> L1[0] = 24
>>> L1
[24, 3, 4]
>>> L2
[24, 3, 4]
```
在这里，没有改变`L1`，改变了`L1`所引用的对象的一个元素。这类修改会覆盖列表对象中的某部分。因为这
个列表对象是与其他对象共享的，那么一个像这样在原处的改变不仅仅会对`L1`有影响。在这个例子中，也会
对`L2`产生影响，因为它与`L1`都引用了相同的对象。

**如果你不想要这样的现象发生，需要Python拷贝对象，而不是创建引用**。有很多种拷贝一个列表的办法，
包括内置列表函数以及标准库的`copy`模块。也许最常用的办法就是从头到尾的分片：
```python
>>> L1 = [2,3,4]
>>> L2 = L1[:]
>>> L1[0] = 24
>>> L1
[24, 3, 4]
>>> L2
[2, 3, 4]
```
这里，**对`L1`的修改不会影响`L2`，因为`L2`引用的是`L1`所引用对象的一个拷贝**。也就是说，两个变
量指向了不同的内存区域。

**注意这种分片技术不会应用在其他的可变的核心类型（字典与集合，因为它们不是序列）上，复制一个字典
或集合应该使用`X.copy()`方法调用。而且，注意标准库中的`copy`模块有一个通用的复制任意对象类型的
调用，也有一个拷贝嵌套对象结构（例如，嵌套了列表的一个字典）的调用**：
```python
import copy
X = copy.copy(Y)
X = copy.deepcopy(Y)
```
我们将在后续深入了解列表和字典，并复习共享引用和拷贝的概念。这里记住有些对象是可以在原处改变的（
即可变的对象），这种对象往往对这些现象总是很开放。**在Python中，这种对象包括了列表、字典以及一些
通过`class`语句定义的对象。如果这不是你期望的现象，可以根据需要直接拷贝对象**。

## 2.共享引用和相等
出于完整的考虑，本章前面介绍的垃圾收集的行为与常量相比，某些类型需要更多地思考。参照下边的语句：
```python
>>> x = 42
>>> x = 'shrubbery'
```
**因为Python缓存并复用了小的整数和小的字符串**，这里的对象42也许并不像我们所说的被回收。相反地，
它将 **可能仍被保存在一个系统表中**，等待下一次你的代码生成另一个42来重复利用。尽管这样，**大多
数种类的对象都会在不再引用时马上回收。对于那些不会被回收的，缓存机制与代码并没有什么关系**。

例如，由于Python的引用模型，**在Python程序中有两种不同的方法去检查是否相等**。让我们创建一个共
享引用来说明：
```python
>>> L = [1,2,3]
>>> M = L
>>> L == M
True
>>> L is M
True
```
这里的第一种技术“**==操作符**”，**测试两个被引用的对象是否相同的值**。这种方法往往在Python中用
作 **相等的检查**。第二种方法“**is操作符**”，是在 **检查对象的同一性**。如果两个变量名精确地指
向同一个对象，它会返回True，**所以这是一种更严格形式的相等测试**。

实际上，**`is`只是比较实现引用的指针，所以如果必要的话是代码中检测共享引用的一种办法。如果变量
名引用值相等，但是是不同的对象，它的返回值将是False**：
```python
>>> L = [1,2,3]
>>> M = [1,2,3]
>>> L == M
True
>>> L is M
False
```
看看当我们对 **小的数字** 采用同样的操作时的结果：
```python
>>> X = 42
>>> Y = 42
>>> X == Y
True
>>> X is Y
True
```
**在这次交互中，`X`和`Y`应该是`==`的（具有相同的值），但不是`is`的（同一个对象），因为我们运行
了两个不同的常量表达式。不过，因为小的整数和字符串被缓存并复用了，所以`is`告诉我们`X`和`Y`是引用
了一个相同的对象**。

实际上，如果你确实想刨根问底的话，你能够 **向Python查询对一个对象引用的次数：在`sys`模块中的
`getrefcount`函数会返回对象的引用次数**。例如，在`IDLE GUI`中查询整数对象1时，它会报告这个对
象有837次重复引用（绝大多数都是IDLE系统代码所使用的）：
```python
>>> import sys
>>> sys.getrefcount(1)
837
```
**这种对象缓存和复用的机制与代码是没有关系的**（除非你运行这个检查）。因为不能改变数字和字符串，
所以无论对同一个对象有多少个引用都没有关系。然而，这种现象也反映了Python为了执行速度而采用的优化
其模块的众多方法中的一种。
