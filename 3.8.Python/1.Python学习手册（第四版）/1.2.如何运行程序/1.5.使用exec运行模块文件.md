使用exec运行模块文件
================================================================================
实际上，除了这里介绍的，还有更多的方法可以运行模块文件中保存的代码。例如，
`exec(open('module.py').read())`内置函数调用，**是从交互提示模式启动文件而不必导入以及随后
的重载的一种方法。每次`exec`都运行文件的最新版本，而不需要随后的重载**：
```python
>>> exec(open('script1.py').read())
```
```
linux2
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
```
**`exec`调用有着类似于`import`的效果，但是，它从技术上不会导入模块，默认情况下，每次以这种方式
调用`exec`的时候，它都重新运行文件，就好像我们把文件粘贴到了调用`exec`的地方。因此，`exec`不需
要在文件修改后进行模块重载，它忽略了常规的模块导入逻辑**。

**缺点是，由于`exec`的工作机制就好像在调用它的地方粘贴了代码一样，和前面提到的`from`一样，对于
当前正在使用的变量有潜在的默认覆盖的可能**。例如，我们的`script1.py`赋给了一个名为`x`的变量。
如果这个名字已经在`exec`调用的地方使用了，那么这个名称的值将被覆盖。
```python
>>> x = 999
>>> x
```
```
999
```
```python
>>> exec(open('script1.py').read())
```
```
linux2
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
```
```python
>>> x
```
```
'Spam!'
```
相反，**基本的`import`语句每个进程只运行文件一次，并且它会把文件生成到一个单独的模块名称空间中，
以便它的赋值不会改变你的作用域中的变量。为模块名称空间分隔所付出的代价是，在修改之后需要重载**。
