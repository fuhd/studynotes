模块的导入和重载
================================================================================
用简单的术语来讲，**每一个以扩展名`py`结尾的Python源代码文件都是一个模块**。其他的文件可以 **通
过导入一个模块读取这个模块的内容**。导入从本质上来讲，就是载入另一个文件，并能够读取那个文件的内容。

这种基于模块的方式使 **模块** 变成了 **Python程序架构的一个核心概念**。更大的程序往往以 **多个
模块文件的形式出现**，并且导入了其他模块文件的工具。**其中的一个模块文件设计成主文件，或叫做顶层
文件（就是那个启动后能够运行整个程序的文件）**。

例如，如果开始一个交互对话（从系统命令行、从开始菜单或者在IDLE中），你可以运行之前创建的文件
`script1.py`，通过简单的 **`import`** 来实现：
```shell
$ python
Python 3.7.0 | packaged by conda-forge | (default, Sep 30 2018, 14:56:18)
[GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] :: Anaconda custom (64-bit) on linux
Type "help", "copyright", "credits" or "license" for more information.
```
```python
>>> import script1
```
```
linux
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
>>>
```
这可以运行，**但是在默认情况下，只是在每次会话的第一次运行。在第一次导入之后，其他的导入都不会再
工作**，甚至在另一个窗口中改变并保存了模块的源代码文件也不行。**这是有意设计的结果。导入是一个开
销很大的操作**，以至于每个文件、每个程序运行不能够重复多于一次。

**但是如果真的想要Python在同一次会话中再次运行文件（不停止和重新启动会话），需要调用`imp`标准库
模块中可用的`reload`函数**（这个函数也是一个Python2.6内置函数，但在Python3中不是内置的）。
```python
# imp这个模块好像过时了，已经废弃了
>>> from imp import reload
>>> reload(script1)
```
```
linux
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
<module 'script1' from '/home/fuhd/work/workspace/python1/script1.py'>
```
这里的`from`语句直接从一个模块中复制一个名字。`reload`函数载入并运行了文件最新版本的代码，如果
已经在另一个窗口中修改并保存了它，那将反映出修改变化。

**`reload`函数希望获得的参数是一个已经加载了的模块对象的名称，所以如果在重载之前，请确保已经成
功地导入了这个模块**。值得注意的是，`reload`函数在模块对象的名称前还需要括号，`import`则不需要。
`reload`是被调用的函数，而`import`是一个语句。这也就是为什么你必须把模块名称传递给`reload`函
数作为括号中的参数，并且这也是在重载时得到了额外的一行输出的原因。**最后一行输出是`reload`调用后
的返回值的打印显示，`reload`函数的返回值是一个Python模块对象**。
```
注意：

用一个from载入的名字不会通过一个reload直接更新，但是，用一条import语句访问的名字则会。如果你的名字似乎不会在一次重载后改
变，尝试使用import和module.attribute名称引用。
```

## 1.模块的显要特性：属性
**导入和重载提供了一种自然的程序启动的选择，因为导入操作将会在最后一步执行文件**。从一般意义上来说，
**模块往往就是变量名的封装，被认作是命名空间。在一个包中的变量名就是所谓的属性，也就是说，属性就是
绑定在特定的对象上的变量名**。

**在典型的应用中，导入者得到了模块文件中在顶层所定义的所有变量名**。这些变量名通常被赋值给通过模块
函数、类、变量以及其他被导出的工具。这些往往都会在其他文件中或程序中使用。**表面上来看，一个模块文
件的变量名可以通过两Python语句读取： import和from，以及reload调用**。

为了讲清楚，请使用文本编辑器创建一个名为`myfile.py`的单行的Python模块文件，其内容如下所示：
```python
title = "The Meaning of Life"
```
**当文件导入时，它的代码运行并生成了模块的属性。这个赋值语句创建了一个名为`title`的模块的属性**。
可以通过两种不同的办法从其他组件获得这个模块的`title`属性。**第一种，你可以通过使用一个`import`
语句将模块作为一个整体载入，并使用模块名后跟一个属性来获取它**：
```shell
$ python
```
```python
>>> import myfile
>>> print(myfile.title)
Hte Meaning of Life
>>>
```
一般来说，**这里的点号表达式代表了`object.attribute`的语法，可以从任何的`object`中取出其任意
的属性，并且这是Python代码中的一个常用操作**。在这里，我们已经使用了它去获取在模块`myfile`中的
一个字符串变量`title`，即`myfile.title`。

**作为替代方案**，可以通过这样的语句从模块文件中获得 **（实际上是复制）变量名**：
```shell
$ python
```
```python
>>> from myfile import title
>>> print(title)
Hte Meaning of Life
>>>
```
**`from`和`import`很相似，只不过增加了对载入组件的变量名的额外的赋值**。从技术上讲，**`from`
复制了模块的属性，以便属性能够成为接收者的直接变量**。因此，能够直接以`title`（一个变量）引用导
入字符串而不是`myfile.titile`（一个属性引用）。

**无论使用的是`import`还是`from`去执行导入操作，模块文件`myfile.py`的语句都会执行，并且导入
的组件在顶层文件中得到了变量名的读取权**。也许在这个简单的例子中只有一个变量名（变量`title`被赋
值给一个字符串），**但是如果开始在模块中定义对象，例如，函数和类时，这个概念将会很有用。这样一些
对象就变成了可重用的组件，可以通过变量名被一个或多个客户端模块读取**。

在实际应用中，模块文件往往定义了一个以上的可被外部文件使用的变量名。下面这个例子中定义了三个变量名：
```python
a = 'dead'
b = 'parrot'
c = 'sketch'
print(a,b,c)
```
保存为文件`treenames.py`，运行时看到的结果：
```shell
$ python threenames.py
```
```
dead parrot sketch
```
**所有的这个文件的代码运行起来就和第一次从其他地方导入（无论是通过`import`或者`from`）后一样。
这个文件的客户端通过`import`得到了具有属性的模块，而客户端使用`from`时，则会获得文件变量名的
复本**。
```
注意：

import和from列出模块名时，都是使用myfile，没有.py后缀。然而，系统shell命令行中，一定要记得加上后缀名，但是import语句中
则不用。
```
一旦你开始就像这里一样在模块文件编写多个变量名，**内置的`dir`函数** 开始发挥作用了。**你可以使
用它来获得模块内部的可用的变量名的列表**。下面代码返回了一个Python字符串列表：
```python
>>> dir(treenames)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__',
'__package__', '__spec__', 'a', 'b', 'c']
```
通过把导入模块的名称传至括号里，进行调用后，**它将返回这个模块内部的所有属性**。其中返回的一些变
量名是“免费”获得的。**一些以双下划线开头并结尾的变量名，这些通常都是由Python预定义的内置变量名，
对于解释器来说有特定的意义。那些通过代码赋值而定义的变量（a,b和c）在`dir`结果的最后显示**。

### 1.1.模块和命名空间
模块导入是一种运行代码文件的方法，同样是Python程序最大的程序结构。一般来说，Python程序往往由多个
模块文件构成，通过`import`语句连接在一起。**每个模块文件是一个独立完备的变量包，即一个命名空间。
一个模块文件不能看到其他文件定义的变量名，除非它显式地导入了那个文件，所以模块文件在代码文件中起到
了最小化命名冲突的作用。因为每个文件都是一个独立完备的命名空间，即使在它们拼写相同的情况下，一个文
件中的变量名是不会与另一个文件中的变量冲突的**。实际上，就像你将看到的那样，正是由于模块将变量封装
为不同部分，Python具有了能够避免命名冲突的优点。
```
注意：

import VS from：我应该指出，from语句在某种意义上战胜了模块的名称空间分隔的目的，因为from把变量从一个文件复制到另一个
文件，这可能导致在导入的文件中相同名称的变量被覆盖（并且，如果发生这种情况的话，不会为你给出警告）。这根本上会导致名称空
间重叠到一起，至少在复制的变量上会重叠。

因此，有些人建议使用import而不是from。然而，我不建议这么做，不仅因为from更短，而且因为它传说中的问题在实际中几乎不是问
题。此外，这是由你来控制的问题，可以在from中列出想要的变量，只要你理解它们将是要赋的值，这不会比编写赋值语句更危险，而赋
值是你可能想要使用的另一功能。
```

## 2.import和reload的使用注意事项
由于某种原因，一旦人们知道通过`import`和`reload`运行文件，有些人就会倾向于仅使用这个方法，而
忽略了 **能够运行最新版本的代码的其他选择（例如，图标点击、IDLE菜单选项以及系统命令行）**。这会
让人变得困惑，你需要记住是何时导入的，才能知道能不能够`reload`，你需要记住当调用`reload`时需要
使用括号，并且要记住让代码的最新版本运行时首先要使用`reload`。此外，**`reload`是不可传递的，重
载一个模块的话只会重载该模块，而不能够重载该模块所导入的任何模块，因此，有时候必须`reload`多个文
件**。

由于这些复杂的地方（并且我们将会在后边碰到其他的麻烦，包括前面提示中所讨论的`reload/from`问题），
从现在开始就要避免使用`import`和`reload`启动程序，这是一个好主意。例如，**下一节所介绍的`IDLE
Run -> Run Module`的菜单选项，提供了一个简单并更少错误的运行文件的方法，并且总是运行代码的最新
版本。系统`shell`命令行提供了类似的优点，如果使用这些技术的话，不需要使用`reload`**。
