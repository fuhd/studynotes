字典
================================================================================
**Python中的字典不是序列，而是一种映射（`mapping`）**。映射并没有任何可靠的从左至右的顺序，它
们简单地 **将键映射到值**。字典是Python核心对象集合中的唯一的一种映射类型，**也具有可变性**——
——可以就地改变，**并可以随需求增大或减小**，就像列表那样。

## 1.映射操作
**作为常量编写时，字典编写在大括号中，并包含一系列的“键：值”对**。示例：
```python
>>> D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
```
我们可以 **通过键对这个字典进行索引来读取或改变键所关联的值**。字典的索引操作使用的是和序列相同
的语法，**但是在方括号中的元素是键**，而不是相对位置：
```python
>>> D['food']
'Spam'
>>> D['quantity'] += 1
>>> D
{'quantity': 5, 'food': 'Spam', 'color': 'pink'}
```
**尽管可以使用大括号这种常量形式**，最好还是见识一下不同的创建字典的方法。例如，**下面开始一个空
的字典，然后每次以一个键来填写它。与列表中禁止边界外的赋值不同，对一个新的字典的键赋值会创建该键**：
```python
>>> D = []
>>> D['name'] = 'Bob'
>>> D['job'] = 'dev'
>>> D['age'] = 40
>>> D
{'job': 'dev', 'age': 40, 'name': 'Bob'}
>>> D['name']
'Bob'
```

## 2.重访嵌套
在上面的例子中，我们使用字典去描述一个假设的人物，用了三个键。尽管这样，假设信息更复杂一些。也许
我们需要去记录名（`first name`）和姓（`last name`），并有多个工作（`job`）的头衔。事实上这
产生了另一个 **Python对象嵌套** 的应用。示例：
```python
rec = {'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'mgr'], 'age': 40.5}
```
这里值的情况变得复杂得多：一个嵌套的字典作为`name`的值，并用一个嵌套的列表作为`job`的值从而支持
多个角色和未来的扩展。能够获取这个结构的组件，就像之前在矩阵中所做的那样，**但是这次索引的是字典
的键，而不是列表的偏移量**。
```python
>>> rec['name']
{'first': 'Bob', 'last': 'Smith'}
>>> rec['name']['last']
'Smith'
>>> rec['job']
['dev', 'mgr']
>>> rec['job'][-1]
'mgr'
>>> rec['job'].append('janitor')
>>> rec
{'name': {'first': 'Bob', 'last': 'Smith'}, 'job': ['dev', 'mgr', 'janitor'], 'age': 40.5}
```
这个例子说明了Python核心数据类型的灵活性，就像你所看到的那样，嵌套允许直接并轻松地建立复杂的信息
结构。使用C这样的底层语言建立一个类似的结构，我们将不得不去事先安排并且声明结构和数组，填写值，将
每一个都连接起来等。**在Python中，这所有的一切都是自动完成的————运行表达式创建了整个的嵌套对象
结构。事实上，这是Python这样的脚本语言的主要优点之一**。

同样重要的是，在底层语言中，当我们不再需要该对象时，必须小心地去释放掉所有对象空间。**在Python中，
当最后一次引用对象后（例如，将这个变量用其他的值进行赋值），这个对象所占用的内存空间将会自动清理
掉**。
```python
>>> rec = 0
```
从技术来说，**Python具有一种叫做垃圾收集的特性，在程序运行时可以清理不再使用的内存**，并将你从
必须管理代码中这样的细节中解放出来。**在Python中，一旦一个对象的最后一次引用被移除，空间将会立
即回收**。

## 3.键的排序：for循环
**因为字典不是序列，它们并不包含任何可靠的从左到右的顺序。这意味着如果我们建立一个字典，并将它打
印出来，它的键也许会以我们输入时不同的顺序出现**：
```python
>>> D = {'a': 1, 'b': 2, 'c': 3}
>>> D
{'a': 1, 'c': 3, 'b': 2}
```
那么，**如果在一个字典的元素中，我们确实需要强调某种顺序的时候，应该怎么做呢**？一个常用的解决办
法就是 **通过字典的`keys`方法收集一个键的列表，使用列表的`sort`方法进行排序，然后使用Python的
`for`循环逐个进行显示结果**：
```python
>>> D
{'a': 1, 'b': 2, 'c': 3}
>>> Ks = list(D.keys())
>>> Ks
['a', 'b', 'c']
>>> for key in Ks:
...   print(key, '=>', D[key])
...
a => 1
b => 2
c => 3
```
**在最近版本的Python中，通过使用最新的`sorted`内置函数可以一趟完成**。`sorted`调用返回结果并
对各种对象类型进行排序，在这个例子中，**自动对字典的键排序**：
```python
>>> D = {'a':1, 'c': 3, 'b': 2}
>>> for key in sorted(D):
...   print(key, '=>', D[key])
...   
a => 1
b => 2
c => 3
```
这种情况是要学习Python的`for`循环的理由。`for`循环是遍历一个序列中的所有元素并按顺序对每一元素
运行一些代码的简单并有效的一种方法。**一个用户定义的循环变量（这里中`key`）用作每次运行过程中当
前元素的参考量**。

**`for`循环可以使用在任意一个序列对象**，并且就像列表解析一样，甚至可以用在一些不是序列的对象中。
例如，**`for`循环可以循环字符串中的字符**，打印每个字符的大写：
```python
>>> for c in 'spam':
...   print(c.upper())
...
S
P
A
M
```

## 4.迭代和优化
如果`for`循环看起来就像之前介绍的列表解析表达式一样，那也没错。它们都是真正通用迭代工具。事实上，
**它们都能够工作于遵守迭代协议的任意对象**。

本书稍后将会详细介绍迭代协议。现在记住，**从左到右地扫描一个对象的每个Python工具都使用迭代协议。
这就是为什么前面一节所介绍的`sorted`调用直接工作于字典之上，我们不必调用`keys`方法来得到一个序
列，因为字典是可迭代的对象，可以用一个`next`返回后续的键**。

这也意味着像下面这样的任何列表解析表达式都可以计算一列数字的平方：
```python
>>> squares = [x ** 2 for x in [1,2,3,4,5]]
>>> squares
[1, 4, 9, 16, 25]
```
能够编写成一个等效的`for`循环，通过在运行时手动增加列表来创建最终的列表：
```python
>>> squares = []
>>> for x in [1,2,3,4,5]:
...   squares.append(x ** 2)
...
>>> squares
[1, 4, 9, 16, 25]
```
尽管这样，**列表解析和相关的函数编程工具，如`map`和`filter`，通常运行得比`for`循环快**（也许
快了两倍）,这是对有大数据集合的程序有重大影响的特性之一。

## 5.不存在的键：if测试
字典还有另一个要点：**尽管我们能够通过给新的键赋值来扩展字典，但是获取一个不存在的键值仍然是一个错
误**。
```python
>>> D = {'a': 1, 'c': 3, 'b': 2}
>>> D['e'] = 99
>>> D
{'e': 99, 'b': 2, 'c': 3, 'a': 1}
>>> D['f']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'f'
```
这就是我们所想要的：**获取一个并不存在的东西往往是一个程序错误**。但是，在一些通用程序中，**我们
编写程序时并不是总知道当前存在什么键。在这种情况下，我们如何处理并避免错误发生呢？一个技巧就是首先
进行测试。`in`关系表达式允许我们查询字典中一个键是否存在，并可以通过使用Python的`if`语句对结果
进行分支处理**（就像`for`一样，确保在这里两次按下Enter键来交互地运行`if`）:
```python
>>> D = {'a': 1, 'b': 2, 'c': 3}
>>> if not 'f' in D:
...   print('missing')
...
missing
```
这里所使用的形式很直接：它包含关键字`if`，紧跟着一个其结果为真或假的表达式，如果测试的结果是真的
话将运行一些代码。
