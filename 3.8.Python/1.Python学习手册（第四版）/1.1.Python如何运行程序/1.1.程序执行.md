程序执行
================================================================================
## 1.程序员视角
就最简单的形式而言，一个Python程序仅是一个包含Python语句的文本文件。例如，下面这个命名为
`script0.py`的文件，是我们能够想到的最简单的Python脚本，但它算得上是一个典型的Python程序：
```python
print('hello world')
print(2 ** 100)
```
你可以用任何自己喜欢的文本编辑器建立这样的文件语句。按照惯例，**Python文件是以`.py`结尾的。从技
术上来讲，这种命名方案在被“导入”时才是必须的**。

当你将这些语句输入到文本文件后，你必须告诉Python去执行这个文件。也就是说，从头至尾按照顺序一个接
一个地运行文件中的语句。你可以通过命令行，从IDE中点击其图标或者其他标准技术来运行Python程序。如
果顺利的话，当执行文件时，将会看到这两个打印语句的结果显示在屏幕的某处，一般默认是显示在运行程序的
那个窗口。
```
hello world
1267650600228229401496703205376
```

## 2.Python的视角
当Python运行脚本时，在代码开始进行处理之前，Python还会执行一些步骤。确切地说，第一步是编译成所
谓的“**字节码**”，之后将其转发到所谓的”**虚拟机**”中。

### 2.1.字节码编译
**当程序执行时，Python内部会先将源代码编译成所谓字节码的形式**。编译是一个简单的翻译步骤，而且字
节码是源代码底层的、与平台无关的表现形式。概括地说，Python通过把每一条源语句分解为单一步骤来将这
些源语句翻译成一组字节码指令。**这些字节码可以提高执行速度，比起文本文件中原始的源代码语句，字节码
的运行速度要快得多**。

你会注意到，前面一段所提到的这个过程对于你来说完全是隐藏起来的。**如果Python进程在机器上拥有写入
权限，那么它将把程序的字节码保存为一个以`.pyc`为扩展名的文件（`.pyc`就是编译过的`.py`源代码）**。
当程序运行之后，你会在那些源代码的附近（也就是说 **同一个目录下**）看到这些文件。

**Python这样保存字节码是作为一种启动速度的优化。下一次运行程序时，如果你在上次保存字节码之后没有
修改过源代码的话，Python将会加载`.pyc`文件并跳过编译这个步骤。当Python必须重编译时，它会自动检
查源文件和字节码文件的时间戳。如果你又保存了源代码，下次程序运行时，字节码将自动重新创建**。

**如果Python无法在机器上写入字节码，程序仍然可以工作，字节码将会在内存中生成并在程序结束时简单地
丢弃。尽管这样，由于`.pyc`文件能够加速启动，你最好保证在大型程序中可以写入。字节码文件同样是分发
Python程序的方法之一。如果Python找到的都是`.pyc`文件，它也很乐意运行这个程序，尽管这里没有原始
的`.py`源代码文件**。

### 2.2.Python虚拟机（PVM）
一旦程序编译成字节码，之后的字节码发送到通常称为 **Python虚拟机（`Python Virtual Machine`**，
简写为`PVM`）上来执行。实际上，它不是一个独立的程序，不需要安装。事实上，`PVM`就是迭代运行字节码
指令的一个大循环，一个接一个地完成操作。`PVM`是Python的运行引擎，它时常表现为Python系统的一部分，
并且它是实际运行脚本的组件。从技术上讲，它才是所谓"Python解释器"的最后一步。

### 2.3.性能的含义
在Python的工作中通常没有“build”或“make”的步骤，代码在写好之后立即运行。另外一个就是，Python
字节码不是机器的二进制代码（例如，Intel芯片的指令）。字节码是特定于Python的一种表现形式。这就是
Python代码无法运行得像C或C++代码一样快的原因。

### 2.4.开发的含义
Python执行模块的另一个情况是 **其开发和执行的环境实际上并没有区别**。也就是说，**编译和执行源代
码的系统是同一个系统**。这使开发周期大大缩短。在程序开始执行之前不需要预编译和连接，只需要简单地输
入并运行代码即可。**这同样使Python具有更多的动态语言特性：在运行时，Python程序去构建并执行另一
个Python程序是有可能的，而且往往非常方便的**。例如，`eval`和`exec`内置模块，能够接受并运行包含
Python程序代码的字符串。这种结构是Python能够实现产品定制的原因。因为Python代码可以动态地修改，
用户可以改进系统内部的Python部分，而不需要拥有或编译整个系统的代码。
