包导入基础
================================================================================
到目前为止，我们已经导入过模块，加载了文件。这是一般性模块用法，可能也是你早期Python职业生涯中多
数导入会使用的技巧。

**除了模块名之外，导入也可以指定目录路径。Python代码的目录就称为包，因此，这类导入就称为包导入。
事实上，包导入是把计算机上的目录变成另一个Python命名空间，而属性则对应于目录中所包含的子目录和模
块文件**。

这是有点高级的特性，**但是它所提供的层次，对于组织大型系统内的文件会很方便，而且可以简化模块搜索
路径的设置**。我们将知道，**当多个相同名称的程序文件安装在某一机器上时，包导入也可以偶尔用来解决
导入的不确定性**。

那么，包导入是如何运作的呢？**在`import`语句中列举简单文件名的地方，可以改成列出路径的名称，彼此
以点号相隔**：
```python
import dir1.dir2.mod
```
**`from`语句也是一样的**：
```python
from dir1.dir2.mod import x
```
**这些语句中的“点号”路径是对应于机器上目录层次的路径**，通过这个路径可以获得到文件`mod.py`（或
类似文件，扩展名可能会有变化）。此外，**这些导入意味着，`dir1`位于某个容器目录`dir0`中，这个目
录可以在Python模块搜索路径中找到**。换句话说，这两个`import`语句代表了这样的目录结构（以DOS反
斜线分隔字符显示）。
```
dir0\dir1\dir2\mod.py
```
**容器目录`dir0`需要添加在模块搜索路径中**（除非这是顶层文件的主目录），就好像`dir1`是模块文件
那样。一般地，**包导入路径中最左边的部分仍然是相对于我们在第21章所介绍的`sys.path`模块搜索路径
列表中的一个目录**。从此以后，脚本内的`import`语句明确指出找到模块的目录路径。

## 1.包和搜索路径设置
如果使用这个特性，要记住，**`import`语句中的目录路径只能是以点号间隔的变量**。你不能在`import`
语句中使用任何平台特定的路径语法。例如，`C:\dir1`、`My Documents.dir2`或`../dir1`这些从语
法上讲是行不通的。你所需要做的就是，**在模块搜索路径设置中使用平台特定的语法，来定义容器的目录**。

例如，上一个例子中，**`dir0`（加在模块搜索路径中的目录名）可以是任意长度而且是与平台相关的目录
路径，在其下能够找到`dir1`。增加`C:\mycode`在`PYTHONPATH`系统变量中或是`.pth`文件中，并且
这样描述**：
```python
import dir1.dir2.mod
```
实际上， **模块搜索路径上的项目提供了平台特定的目录路径前缀，之后再在`import`的那些路径左边添加
了这些路径。`import`语句以与平台无关的方式，提供了目录路径写法**。

## 2.`__init__.py`包文件
**如果选择使用包导入，就必须多遵循一条约束，包导入语句的路径中的每个目录内都必须有`__init__.py`
这个文件，否则导入包会失败。也就是说，在我们所采用的例子中，`dir1`和`dir2`内都必须包含`__init__.py`
这个文件。容器目录`dir0`不需要这类文件，因为其本身没列在`import`语句之中**。

更正式说法是，像这样的目录结构：
```
dir0\dir1\dir2\mod.py
```
以及这种形式的`import`语句：
```python
import dir1.dir2.mod
```
必须遵循下列规则：
+ **`dir1`和`dir2`中必须都含有一个`__init__.py`文件**。
+ **`dir0`是容器，不需要`__init__.py`文件，如果有的话，这个文件也会被忽略**。
+ **`dir0`（而非`dir0\dir1`）必须列在模块搜索路径上（也就是此目录必须是主目录，或者列在`PYTHONPATH`之中）**。

**`__init__.py`可以包含Python程序代码，就像普通模块文件。这类文件从某种程序上讲就像是Python
的一种声明，尽管如此，也可以完全是空的。作为声明，这些文件可以防止有相同名称的目录不小心隐藏在模
块搜索路径中，而之后才出现真正所需要的模块。没有这层保护，Python可能会挑选出和程序代码无关的目录，
只是因为有一个同名的目录则好出现在搜索路径上位置较前的目录内**。

更通常的情况下，**`__init__.py`文件扮演了包初始化的钩子、替目录产生模块命名空间以及使用目录导
入时实现`from *`（也就是`from ... import *`）行为的角色**。

### 2.1.包的初始化
**Python首次导入某个目录时，会自动执行该目录下`__init__.py`文件中的所有程序代码。因此，这类文
件自然就是放置包内文件所需要初始化的代码的场所。例如，包可以使用其初始化文件，来创建所需要的数据文
件、连接数据库等。一般而言，如果直接执行，`__init__.py`文件没什么用，当包首次读取时，就会自动
运行**。

### 2.2.模块命名空间的初始化
**在包导入的模型中，脚本内的目录路径，在导入后会变成真实的嵌套对象路径**。例如，上一个例子中，
导入后，表达式`dir1.dir2`会运行，并返回一个模块对象，而此对象的命名空间包含了`dir2`的`__init__.py`
文件所赋值的所有变量名。**这类文件为目录（没有实际相配的模块文件）所创建的模块对象提供了命名空间**。

### 2.3.from*语句的行为
**作为一个高级功能，你可以在`__init__.py`文件内使用`__all__`列表来定义目录以`from*`语句形式
导入时，需要导出什么。在`__init__.py`文件中，`__all__`列表是指当包（目录）名称使用`from*`的
时候，应该导入的子模块的名称清单。如果没有设定`__all__`，`from*`语句不会自动加载嵌套于该目录内
的子模块。取而代之的是，只加载该目录的`__init__.py`文件中赋值语句定义的变量名，包括该文件中程序
代码明确导入的任何子模块。例如，某目录中`__init__.py`内的语句`from submodule import X`，会
让变量名`X`可在该目录的命名空间内使用**。

**如果你用不着这类文件，也可以让这类文件保持空白。不过，为了让目录导入完全运作，这类文件就得存在**。
