联合起来：交换器和绑定
============================================================================
**当你想要将消息投递到队列时，你通过把消息发送给交换器来完成**。然后，根据 **确定的规则**，RabbitMQ将会决定
消息该投递到哪个队列。这些规则被称作 **路由键（routing key）**。**队列通过路由键绑定到交换器**。
当你把消息发送到代理服务器时，**消息将拥有一个路由键——————即便是空的——————RabbitMQ也会将其和绑定使用的路由键进行匹配**。
如果相匹配的话，那么消息将会投递到该队列。**如果路由的消息不匹配任何绑定模式的话，消息将进入“黑洞”**。

服务器会根据路由键将消息从交换器路由到队列，但它是如何处理投递到多个队列的情况的呢？协议中定义的 **不同类型
交换器** 发挥了作用。一共有四种类型：**direct**、**fanout**、**topic** 和 **headers**。
每一种类型实现了不同的路由算法。除了headers交换器外的其他三种，都是非常常用的。**headers交换器允许你
匹配AMQP消息的header而非路由键。除此之外，headers交换器和direct交换器完全一致，但性能会差很多。
因此它并不太实用，而且几乎再也用不到了**。

### direct交换器
direct交换器非常简单：**如果路由键匹配的话，消息就被投递到对应的队列。服务器必须实现direct类型交换器，**
**包含一个空白字符串名称的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键**。
示例：
```python
$channel -> basic_publish($msg, '','queue-name')
```
第一个参数：**消息内容**；第二个参数：空字符串，代表 **默认交换器**；第三个参数：**路由键**；

当默认的direct交换器无法满足应用程序的需求时，你可以声明你自己的交换器；只需要发送
**exchange.declare命令** 并设置合适的参数就行了。

### fanout交换器
这种类型的交换器会将收到的消息广播到绑定的队列上。消息通信模式很简单：**当你发送一条消息到fanout交换器时，**
**它会把消息投递给所有附加在此交换器上的队列**。

### topic交换器
这类交换器允许你实现有趣的消息通信场景：**它使得来自不同源头的消息能够到达同一个队列**。
让我们用Web应用程序日志系统作为示例。你拥有多个不同的日志级别，例：error、info和warning。与此同时，
你的应用程序分为以下几个模块：user-profile、image-gallery、msg-inbox等。如果在发送消息的动作失败时，
你想要 **报告一个error** 的话，则可以编写以下代码：
```py
$channel -> basic_publish($msg, 'logs-exchange', 'error.msg-inbox');
```
然后，假设你声明了一个msg-inbox-errors队列，你可以将其 **绑定到交换器上来接收消息**，如下所示：
```py
$channel -> queue_bind('msg-inbox-errors', 'logs-exchange', 'error.msg-inbox');
```
这看起来和使用direct交换器很像，**你为队列绑定操作和消息发布路由键指定了相同的error.msg-inbox字符串**
**作为绑定规则**。那样就能确保你的消息会路由到msg-inbox-errors队列，这没有什么特别的。但是如果你想要一个
队列监听msg-inbox模块的所有error、info和warning级别日志的话，你该怎么做呢？你可以在 **队列绑定到交换器上的时候使用通配符**，
示例：
```py
$channel -> queue_bind('msg-inbox-logs', 'logs-exchange', '*.msg-inbox');
```
msg-inbox-logs队列将会接收从msg-inbox模块发来的所有error、warning和info日志信息。
**单个“.”把路由键分为了几部分，“*”匹配特定位置的任意文本**。

**为了实现匹配所有规则，你可以使用“#”字符**，示例：
```py
$channel -> queue_bind('all-logs', 'logs-exchange', '#');
```
通过这样的绑定方式，all-logs队列将会接收所有从Web应用程序发布的日志。当然，要使得之前的示例能够运行，
你必须在绑定之前对队列进行声明。**“*“操作符将”.“视为分隔符；与之不同的是，“#“操作符没有分块的概念，它将任意“.“**
**字符均视为关键字的匹配部分**。
