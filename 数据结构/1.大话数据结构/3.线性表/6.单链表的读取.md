单链表的读取
=========================================================
在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的。**但在单链表中，由于第i个元素到底在哪？
没办法一开始就知道，必须得从头开始找**。因此，对干 **单链表** 实现获取第`i`个元素的数据的操作`GetElem`，
在算法上，相对要麻烦一些。

获得链表第`i`个数据的算法思路：
1. 声明一个结点`p`指向链表第一个结点,初始化`j`从1开始；
2. 当`j`<`i`时，就遍历链表，让`p`的指针向后移动，不断指向下一结点，`j`累加1；
3. 若到链表末尾`p`为空,则说明第`i`个元素不存在；
4. 否则查找成功，返回结点`p`的数据；

实现代码算法如下 :
```c
//初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
//操作结果：用e返回L中第i个数据元素的值
Status GetElem(LinkList L,int i,ElemType *e)
{
    int j;
    LinkList p;         //声明结点p
    p = L -> next;      //让p指向链表L的第一个结点
    j = 1;              //j为计数器
    while (p && j<i)    //p不为空或者计数器j还没有等于i时，循环继续
    {
        p = p -> next;  //让p指向下一个结点
        ++j;
    }
    if(!p || j>i)       //第i个元素不存在
        return ERROR;
    *e = p -> data;     //取第i个元素的数据
    return OK;
}
```
说白了，就是从头开始找，直到第`i`个元素为止。由于这个算法的时间复杂度取决于`i`的位置，
当`i=1`时，则不需遍历，第一个就取出数据了，而当`i=n`时则遍历`n-1`次才可以。因此 **最坏情况的时间复杂度是O(n)**。

由于单链袤的结构中没有定义表长，所以不能事先知道要循环多少次，因此也就不方便使用`for`来控制循环。
其主要核心思想就是 **工作指针后移**，这其实也是很多算法的常用技术。
