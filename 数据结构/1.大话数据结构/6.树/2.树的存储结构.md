树的存储结构
============================================================
前面章节讲过的 **顺序存储** 和 **链式存储** 两种结构。先来看看顺序存储结构，用一段地址连续的存储单元依次存储线性表的数据元素。
这对于性性表来说是很自然的，对于树这样一多对的结构呢？树中某个结点的孩子可以有多个，这就意味着，
无论按何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系，你想想看，数据元素挨个的存储，
谁是谁的双亲，谁是谁的孩子呢？简单的顺序存储结构是不能满足树的实现要求的。不过充分利用顺序存储和链式存储结构的特点，
完全可以实现对树的存储结构的表示。我们这里要介绍三种不同的表示法: **双亲表示法**、**孩子表示法**、**孩子兄弟表示法**。

### 双亲表示法
除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。

我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点的位置。也就是说，
每个结点除了知道自己是谁以外，还知道它的双亲在哪里。图示：

![6-4-1](../img/6-4-1.png)

其中`data`是数据域，存储结点的数据信息。而`parent`是指针域，存储该结点的双亲在数组中的下标。
以下是我们的双亲表示法的结点结构定义代码：
```c
//树的双亲表示法结点结构定义
# define MAX_TREE_SIZE 100
typedef int TElemType;    //树结点的数据类型，目前暂定为整型
typedef struct PTNode     //结点结构
{
    TElemType data;       //结点数据
    int parent;           //双亲位置
} PTNode;
typedef struct            //树结构
{
    PTNode nodes[MAX_TREE_SIZE];          //结点数组
    int r,n;                              //根的位置和结点数
} PTree;
```
有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的，所以我们约定根结点的位置域设置为`-1`，
这也就意味着，我们所有的结点都存有它双亲的位置。如下图中的树结构和表中的树双亲表示所示。

![图6-4-1](../img/图6-4-1.png)

![表6-4-2](../img/表6-4-2.png)

这样的存储结构，我们可以根据结点的`parent`指针很容易找到它的双亲结点，所用的时间复杂度为`O(1)`，
直到`parent`为`-1`时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。

这真是麻烦，能不能改进一下呢？

当然可以。我们 **增加一个结点最左边孩子的域**，不妨叫它 **长子域**，这样就可以很容易得到结点的孩子。
如果没有孩子的结点，这个长子域就设置为`-1`，如下表所示：

![表6-4-3](../img/表6-4-3.png)

**注：A根节点的`firstchild`写成了`-1`，可以是错了，应该是`1`**。

对于有`0`个或`1`个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有`2`个孩子，
知道了长子是谁，另一个当然就是次子了。

另外一个问题场景，我们很 **关注各兄弟之间的关系**，双亲表示法无法体现这样的关系，那我们怎么办？嗯，
可以增加一个 **右兄弟域** 来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。
同样的，如果右兄弟不存在，则赋值为`-1`，如下表所示。

![表6-4-4](../img/表6-4-4.png)

但如果结点的孩子很多，超过了`2`个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，
那么我们还 **可以把此结构扩展为有双亲域、长子域、再有右兄弟域**。存储结构的设计是一个非常灵活的过程。
一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，
有需要时再设计相应的结构。

### 孩子表示法
 
