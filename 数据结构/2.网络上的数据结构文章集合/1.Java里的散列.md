Java里的散列
==================================================================
**散列** 一般也叫 **哈希**。**散列表** 也叫 **哈希表**。本文将介绍散列表的基本知识、一致性哈希、哈希碰撞攻击及Java里的哈希实现。

### 介绍
**散列表是普通数组概念的推广**，在最坏情况下查找一个元素需要 **O(n)**，在一些合理假设下，查找一个元素的期望时间为 **O(1)**。
在散列表中，不是直接把 **关键字** 用作 **数组下标**，而是根据关键字计算出下标。
+ **散列函数**：作用就是根据关键字计算出数组下标。
+ **碰撞（collision）**：多个关键字映射到同一个数组下标位置。
+ **槽**：一般把散列表的数组的一个存储单元（元素）叫做槽。
+ **简单一致性散列**：（Simple uniform hashing）假设任何元素散列到`m`个槽中的每一个的可能性是相同的，
且与其他元素已被散列到什么位置上独立无关，这个假设称为简单一致性散列。

### 散列函数
**一个好的散列函数应（近似地）满足简单一致性散列的假设**。一种好的做法是以独立于数据中可能存在的任何模式的方式导出散列值。

#### 除法散列法
通过取关键字`k`除以`m`的余数，来将关键字`k`映射到`m`个槽的某一个去。散列函数为：`h(k) = k mod m`。
`m`一般取与2的整数幂不太接近的质数。

#### 乘法散列法
用关键字`k`乘上常数`A`（0<A<1），并抽取出`kA`的小数部分，用`m`乘以这个值，再取结果的底(floor)。
散列函数为： `h(k) = floor(m * (k*A mod 1))`。

#### 全域散列
universal hashing：**随机地选择散列函数，使之独立于要存储的关键字**。
全域散列的基本思想是在执行开始时，就从一族仔细设计的函数中，随机地选择一个作为散列函数。

### Java里的散列
`java.util.HashMap`类是JDK里的 **散列表** 实现，它的实现方式是 **槽 + 链表**，也就是 **用链接法解决碰撞**。
**它的散列算法是除法散列的思想**，与大多数教科书里讲的不同是，它的槽的长度是 **2的整数次幂**，而不是一个质数，
**且用按位与运算代替除法**：
```java
//计算给定哈希值h所对应的槽下标
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h & (length-1);
}
```
`h`是对象的哈希值，`length`是槽的长度。这样做主要是出于性能的考虑。

**对于哈希碰撞，`java.util.HashMap`类从JDK1.8开始会在链表的长度达到某个阀值时，将散列表的实现转换为一个定制的红黑树**。
