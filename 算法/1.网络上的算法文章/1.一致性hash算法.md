一致性Hash算法
================================================================
一致性hash算法（consistent hashing）早在1997年，就在论文「Consistent hashing and random trees」中被提出，
**目前在cache系统中应用越来越广泛**；

### 基本场景
比如你有`N`个`cache`服务器（后面简称`cache`），那么如何将一个对象`object`映射到`N`个`cache`上呢，
你很可能会采用类似下面的通用方法计算`object`的`hash`值，然后均匀的映射到到`N`个`cache`；

**hash ( object ) % N**

一切都运行正常，再考虑如下的两种情况；
1. 一个`cache`服务器`m`宕掉了（在实际应用中必须要考虑这种情况），这样所有映射到`cache`为`m`的对象都会失效，
怎么办，需要把`cache``m`从`cache`中移除，这时候`cache`是`N-1`台，映射公式变成了：`hash(object)%(N-1)`；
2. 由于访问加重，需要添加`cache`，这时候`cache`是`N+1`台，映射公式变成了：`hash(object)%(N+1)`；

`1`和`2`意味着什么？这意味着突然之间几乎所有的`cache`都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；
再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的`hash`算法也做不到。
有什么方法可以改变这个状况呢，这就是 **一致性Hash算法（consistent hashing）**。

 
