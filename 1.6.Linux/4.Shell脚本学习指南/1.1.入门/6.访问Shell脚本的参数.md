访问Shell脚本的参数
===================================================================================
所谓的 **位置参数**（`positional parameters`）指的也就是 **Shell脚本的命令行参数**。在Shell函数里，
它们同时也可以是 **函数的参数**。各参数都由 **整数** 来命名。基于历史的原因，**当它超过9，就应该用大
括号把数字框起来**：
```shell
echo first arg is $1
echo tenth arg is ${10}
```
此外，通过 **特殊变量**，我们还可以取得 **参数的总数**，以及 **一次取得所有参数**。

假设你想知道某个用户正使用的终端是什么，你当然可以直接使用 **`who`命令**，然后在输出中自己慢慢找。
这么做很麻烦又容易出错——特别是当系统的用户很多的时候。你想做的只不过是在`who`的输出中找到那位用
户，这个时候你可以用 **`grep`命令** 来进行查找操作，它会列出与第一个参数（所指定的模式）匹配的每一
行。假设你要找的是用户`fuhd`：
```shell
$ who | grep fuhd
fuhd     :0           2020-02-16 19:48 (:0)
```
知道如何寻找特定的用户后，我们可以将命令放进脚本里，这段脚本的第一个参数就是我们要找的用户名称：
```shell
$ cat > finduser                #建立新文件

#! /bin/sh
#finduser --- 察看第一个参数所指定的用户是否登录
who | grep $1

^D                  #出End-of-file结尾
```
```shell
$ chmod +x finduser     #设置执行权限

$ ./finduser fuhd             #测试：寻找fuhd
fuhd     :0           2020-02-16 19:48 (:0)

$ mv finduser $HOME/bin             #将这个文件存进自己的bin目录
```
以`#finduser ...`开头的这一行是一个注释。Shell会忽略由`#`开头的每一行。（相信你也已经发现：当Shell读
取脚本时，前面所提及的`#!`行也同样扮演注释的角色。）为你的程序加上注释绝对不会错。这样可以帮助其他
人或是自己在一年以后还能够了解你在做什么以及为什么要这么做。等到我们觉得程序能够运行无误时，就可以
把它移到个人的`bin`目录。

这个程序还没有达到完美。要是我们没有给任何参数，会发生什么事？
```shell
$ ./finduser

用法: grep [选项]... PATTERN [FILE]...
试用'grep --help' 来获得更多信息。
```
我们将在6.2.4节看到，**如何测试命令行参数数目，以及在参数数目不符时，如何采取适当的操作**。

