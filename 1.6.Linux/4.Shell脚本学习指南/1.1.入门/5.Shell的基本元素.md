Shell的基本元素
===================================================================================
本节要介绍的是，适用于所有Shell脚本的基本元素。通过以交互的方式使用Shell。

## 1. 命令与参数
**Shell** 最基本的工作就是 **执行命令**。以互动的方式来使用Shell很容易了解这一点，每键入一道命令，
Shell就会执行。像这样：
```shell
$ cd work; ls -l whizprog.c
```
以上的例子展现了UNIX命令行的原理。首先，格式很简单，**以空白（Space键或Tab键）隔开命令行中各个组
成部分**。

其次，**命令名称** 是命令行的第一个项目。通常后面会跟着 **选项**，任何额外的 **参数** 都会放在选项之
后。

第三，**选项的开头是一个破折号（或减号），后面接着一个字母。选项是可有可无的，有可能需要加上参数**
（例如`cc -o whizprog whizprog.c`）。**不需要参数的选项可以合并**：例如，`ls -lt whizprog.c`比
`ls -l -t whizprog.c`更方便（后者当然也可以，只是得多些录入）。

**长选项** 的使用越来越普遍，特别是标准工具的GNU版本，以及在`X Window System`（X11）下使用的程
序。例如：
```shell
$ cd whizprog-1.1 
$ patch --verbose --backup -pl < /tmp/whizprog-1.1-1.2-patch 
```
**长选项的开头是一个破折号还是两个视程序而定**（`< /tmp/whizprog-1.1-1.2-patch`是一个 **`I/O`重定
向）。它会使得patch从`/tmp/whizprog-1.1-1.2-patch`文件而不是从键盘读取输入**。`I/O`重定向也是重要
的基本概念之一，本章稍后会谈到。

**以两个破折号（`--`）来表示选项结尾的用法**，源自`System V`，不过 **已被纳入POSIX标准**。自此之
后命令行上看起来像选项的任何项目，都将一视同仁地当成 **参数** 处理（例如，视为文件名）。

最后要说的是，**分号（`;`）可用来分隔同一行里的多条命令**。Shell会依次执行这些命令。**如果你使用的
是`&`符号而不是分号，则Shell将在后台执行其前面的命令**，这意味着，Shell不用等到该命令完成，就可以
继续执行下一个命令。

Shell识别三种基本命令，**内建命令、Shell函数以及外部命令**：
+ **内建命令** 就是 **由Shell本身所执行的命令**。有些命令是由于其必要性才内建的，例如cd用来改变目录，
read会将来自用户（或文件）的输入数据传给Shell变量。另一种内建命令的存在则是为了效率，其中最典型的就
是test命令，编写脚本时会经常用到它。另外还有I/O命令，例如echo与printf。
+ **Shell函数** 是 **功能健全的一系列程序代码，以Shell语言写成，它们可以像命令那样引用**。稍后会在
6.5节讨论这个部分。此处，我们只需要知道，它们可以引用，就像一般的命令那样。
+ **外部命令** 就是 **由Shell的副本（新的进程）所执行的命令**，基本的过程如下：
    - 建立一个新的进程。此进程即为Shell的一个副本。
    - 在新的进程里，在PATH变量内所列出的目录中，寻找特定的命令。`/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin`
    为PATH变量典型的默认值。**当命令名称含有斜杠（`/`）符号时，将略过路径查找步骤**。
    - 在新的进程里，以所找到的新程序取代执行中的Shell程序并执行。
    - 程序完成后，最初的Shell会接着从终端读取的下一条命令，或执行脚本里的下一条命令。
    ![shell程序执行](img/1.jpeg)

以上只是基本程序。当然，Shell可以做的事很多，例如变量与通配字符的展开、命令与算术的替换等。

## 2. 变量
变量就是为某个信息片断所起的名字，例如：first_name或driver_lic_no。所有程序语言都会有变量，Shell也
不例外。每个变量都有一个值，这是由你分配给变量的内容或信息。**在Shell的世界里，变量值可以是（而且通
常是）空值。也就是不含任何字符。这是合理的，也是常见的、好用的特性。空值就是null**。

**Shell变量名称的开头是一个字母或下划线符号，后面可以接着任意长度的字母、数字或下划线符号。变量名称
的字符长度并无限制。Shell变量可用来保存字符串值，所能保存的字符数同样没有限制**。例如：
```shell
#分配变量值
$ myvar=this_is_a_long_string_that_does_not_mean_much
#打印变量值
$ echo $myvar
this_is_a_long_string_that_does_not_mean_much
```
**变量赋值的方式为：先写变量名称，紧接着`=`字符，最后是新值，中间完全没有任何空格。当你想取出Shell
变量的值时，需于变量名称前面加上`$`字符。当所赋予的值内含空格时，请加上引号**：
```shell
#单行可进行多次赋值
$ first=isaac middle=bashevis last=singer
#值中包含空格时使用引号
$ fullname="isaac bashevis singer"
#此处不需要引号
$ oldname=$fullname
```
如上例所示，**当变量作为第二个变量的新值时，不需要使用双引号，但是使用双引号也没有关系。不过，当你
将几个变量连接起来时，就需要使用引号**：
```shell
#这里需要双引号
$ fullname="$first $middle $last"
```

## 3. 简单的echo输出
这里要看的是echo命令如何显示myvar变量的值，这是很可能会在命令行里使用到的情况。**echo的任务就是产
生输出，可用来提示用户，或是用来产生数据供进一步处理**。

**原始的echo命令只会将参数打印到标准输出，参数之间以一个空格隔开，并以换行符号（newline）结尾**。
```shell
$ echo Now is the time for all good men
Now is the time for all good men

$ echo to come to the aid of their country.
to come to the aid of their country.
```
不过，随着时间的流逝，有各种版本的echo开发出来。**BSD版本的echo** 看到第一个参数为 **`-n`** 时，
**会省略结尾的换行符号**。例如（下划线符号表示终端画面的光标）：
```shell
$ echo -n "Enter your name: "
```
**System V版本的echo会解释参数里特殊的转义序列**。由于 **很多系统默认以BSD的行为模式来执行echo**，
所以本书只会使用它的最简单形式。比较复杂的输出，我们会使用printf。
```
echo

语法：
        echo [string ......]
用途：
        产生Shell脚本的输出。
主要选项：
        无
行为模式：
        echo将各个参数打印到标准输出，参数之间以一个空格隔开，并以换行符号结束。它会解释每个字符串里的转义序列。转义序列
        可用来表示特殊字符，以及控制其行为模式。
警告：
        UNIX各版本间互不相同的行为模式使得echo的可移植性变得很困难，不过它仍是最简单的一种输出方式。
        许多版本都支持-n选项。如果有支持，echo的输出会省略最后的换行符号。这适合用来打印提示字符串。不过，目前echo符合
        POSIX标准的版本并未包含此选项。
```

## 4. 华丽的printf输出
**由于echo有版本上的差异，所以导致UNIX版本间可移植性的头疼问题**。在POSIX标准化的首次讨论中，与
会成员无法在如何标准化echo上达到共识。

事实上，只要是使用最简单的形式，其echo的可移植性不会有问题。相对来看，Ninth Edition Research UNIX系
统上所采用的 **printlf命令，比echo更灵活，却也更复杂**。

printf命令模仿C程序库里的`printf()`库程序。它几乎复制了该函数所有的功能，如果你曾使用C、C++、awk、
Perl、Python或Tcl写过程序，对它的基本概念应该不陌生。当然，它在Shell层级的版本上，会有些差异。

**如同echo命令，printf命令可以输出简单的字符串**：
```shell
printf "Hello, world\n"
```
你应该可以马上发现，**最大的不同在于：printf不像echo那样会自动提供一个换行符号**。你必须显式地将换
行符号指定成`\n`。**printf命令的完整语法分为两部分**：
```
printf format-string [arguments ...]
```
**第一部分是一个字符串**，用来描述输出的排列方式，**最好为此字符串加上引号**。此字符串包含了按字面
显式的 **字符** 以及 **格式声明**，后者是 **特殊的占位符**，用来描述如何显示相应的参数。

**第二部分是与格式声明相对应的参数列表**，例如一系列的字符串或变量值。（如果参数的个数比格式声明还
多，则printf会循环且依次地使用格式字符串里的格式声明，直到处理完参数）。**格式声明分成两部分：百分比
符号（`%`）和指示符。最常用的格式指示符有两个，`%s`用于字符串，而`%d`用于十进制整数**。

**格式字符串中，一般字符会按字面显示。转义序列则像echo那样，解释后再输出成相应的字符。格式声明以
`%`符号开头，并以定义的字母集中 一个来结束，用来控制相应参数的输出**。例中，`%s`用于字符串的输出：
```shell
$ printf "The first program always prints '%s, %s'\n" Hello world
```

## 5. 基本的I/O重定向
**标准输入/输出**（`standard I/O`）可能是软件设计原则里最重要的概念了。这个概念就是，程序应该有数据
的来源端、数据的目的端以及报告问题的地方，它们分别被称为 **标准输入**（`standard input`）、**标准输
出**（`standard output`）以及 **标准错误输出**（`standard error`）。

许多UNIX程序都遵循这一设计原则。**默认的情况下，它们会读取标准输入、写入标准输出，并将错误信息传递
到标准错误输出。这类程序常叫做过滤器（`filter`），你马上就会知道这么叫的原因。默认的标准输入、标准输
出。以及标准错误输出都是终端**，这点可通过cat程序得知。
```shell
$ cat                                   #未指定任何参数，读取标准输入，写入标准输出
now is the time             #由用户键入
now is the time             #由cat返回
for all good men
for all good men
to come to the aid of their country
to come to the aid of their country

^D                                        # Ctrl + D，文件结尾
```
你可能想要知道，是谁替执行中的程序初始化标准输入、输出及错误输出的呢？毕竟，总应该有人来替执行中的
程序打开这些文件，甚至是让用户在登录后能够看到交互的Shell界面。

**答案就是在你登录时，UNIX便将默认的标准输入、输出及错误输出安排成你的终端。I/O重定向就是你通过与终
端交互，或是在Shell脚本里设置，重新安排从哪里输入或输出到哪里**。

### 5.1.重定向与管道
**Shell提供了数种语法标记，可用来改变默认I/O的来源端与目的端**。此处会先介绍基本用法，稍后再提供完
整的说明。让我们由浅入深地依次介绍如下：

#### 5.1.1. 以`<`改变标准输入
`program < file`可将`program`的标准输入修改为`file`：
```shell
tr -d '\r' < dos-file.txt 
```

#### 5.1.2. 以`>`改变标准输出
`program > file`可将`program`的标准输出修改为`file`：
```shell
tr -d '\r' < dos-file.txt > UNIX-file.txt
```
这条命令会先以`tr`将`dos-file.txt`里的ASCII carriage-return（回车）删除，再将转换完成的数据输出到
`UNIX-file.txt`。`dos-file.txt`里的原始数据不会有变化。**`>`重定向符（`redirector`）在目的文件不存在
里，会新建一个。然而，如果目的文件已存在，它就会覆盖掉；原本的数据都会丢失**。

#### 5.1.3. 以`>>`附加到文件
**`program >> file`可将`program`的标准输出附加到`file`的结尾处。如同`>`，如果目的文件不存在，`>>`
重定向符便会新建一个。然而，如果目的文件存在，它不会直接覆盖掉文件，而是将程序所产生的数据附加到文
件结尾处**：
```shell
for f in dos-file*.txt
do
        tr -d '\r' < $f >> big-UNIX-file.txt
done
```

#### 5.1.4. 以`|`建立管道
`program1 | program2`可将`program1`的标准输出修改为`program2`的标准输入。虽然`<`与`>`可将输入
与输出连接到文件，**不过管道（`pipeline`）可以把两个以上执行中的程序衔接在一起。第一个程序的标准输
出可以变成第二个程序的标准输入**。这么做的好处是，**管道可以使得执行速度比使用临时文件的程序快上十
倍**。例如：
```shell
tr -d '\r' < dos-file.txt | sort > UNIX-file.txt
```
这条管道会先删除输入文件内的回车字符，在完成数据的排序之后，将结果输出到目的文件。

使用UNIX工具程序时，不妨将数据想象成水管里的水。未经处理的水，将流向净水厂，经过各类滤器的处理，最
后产生适合人类饮用的水。

同样，编写脚本时，你通常已有某种输入格式定义下的原始数据，而需要处理这些数据后产生结果。（处理一词 
表示很多意思，例如排序、加和与平均、格式化以便于打印，等等。）从最原始的数据开始，然后构造一条管道
，一步一步地，管道中的每个阶段都会让数据更接近要的结果。

如果你是UNIX新手，可以把`<`与`>`想象成数据的漏斗——数据会从大的一端进入，由小的一端出来。
```
注意

构造管道时，应该试着让每个阶段的数据量变得更少。换句话说，如果你有两个要完成的步骤与先后次序无关，你可以把会让数据量变少
的那一个步骤放在管道的前面。这么做可以提升脚本的整体性能，因为UNIX只需要在两人个程序间称动少的数据量，每个程序要做的事也
比较少。

例如，使用sort排序之前，先以grep找出相关的行，这样可以让sort少做些事。
```
```
tr

语法：
        tr  [ options ]  source-char-list  replace-char-list 

用途：
        转换字符。例如，将大写字符转换成小写。选项可让你指定所要删除的字符，以及将一串重复出现的字符浓缩成一个。

常用选项：
        -c： 取source-char-list的反义。tr要转换的字符，变成未列在source-char-list中的字符。此选项通常与-d或-s配合使用。

        -C：与-c相似，但所处理的是字符（可能是包含多个字节的宽字符），而非二进制的字节值。参考“警告”说明。

        -d：自标准输入删除source-char-list里所列的字符，而不是转换它们。

        -s：浓缩重复的字符。如果标准输入中连续重复出现source-char-list里所列的字符，则将其浓缩成一个。

行为模式：
        如同过滤器：自标准输入读取字符，再将结果写到标准输出。任何输入字符只要出现在source-char-list中，就会置换成
        replace-char-list里相应的字符。POSIX风格的字符与等效的字符集也适用，而且tr还支持replace-char-list中重复字符的
        标记法。

警告：
        根据POSIX标准的定义，-c处理的是二进制字节值，而-C处理的是现行locale所定义的字符。直到2005年初，仍有许多系
        统不支持-C选项。
```

### 5.2. 特殊文件：/dev/null与/dev/tty
**UNIX系统提供了两个对Shell编程特别有用的特殊文件。第一个文件`/dev/null`，就是大家所熟知的位桶
（`bit buchet`）。传送到此文件的数据都会被系统丢掉。也就是说，当程序将数据写到此文件时，会认为它已
成功完成写入数据的操作，但实际上什么事都没做**。如果你需要的是命令的退出状态，而非它的输出，此功能
会很有用。例如，测试一个文件是否包含某个模式（`pattern`）:
```shell
if grep pattern myfile > /dev/null
then
        ...... #找到模式时
else
        ...... #找不到模式时
fi
```
相对地，**读取`/dev/null`则会立即返回文件结束符号（`end-of-file`）。读取`/dev/null`的操作很少会出现
在Shell程序里**，不过了解这个文件的行为模式还是非常重要的。

**另一个特殊文件为`/dev/tty`。当程序打开此文件时，UNIX会自动将它重定向到一个终端**「一个实体的控
制台（`console`或串行端口（`serial port`），也可能是一个通过网络与窗口登录的伪终端（`pseudoterminal`
）」**再与程序结合。这在程序必须读取人工输入时（例如密码）特别有用**。此外，用它来产生错误信息也很
方便，只是比较少人这么做：
```shell
printf "Enter new password: "           #提示输入
stty -echo                                                    #关闭自动打印输入字符的功能
read pass < /dev/tty                                #读取密码
printf "Enter again: "                              #提示再输入一次
read pass2 < /dev/tty                              #再读取一次以确认
stty echo                                                       #别忘了打开自动打印输入字符的功能
......
```
**`stty`（`set tty`）命令用来控制终端（或窗口）的各种设置。`-echo`选项用来关闭自动打印每个输入字符
的功能，`stty echo`用来恢复该功能**。

## 6. 基本命令查找


