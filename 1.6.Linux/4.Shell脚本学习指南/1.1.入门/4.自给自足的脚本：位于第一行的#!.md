自给自足的脚本：位于第一行的#!
================================================================================
**当Shell执行一个程序时，会要求UNIX内核启动一个新的进程（process），以便在该进程里执行所指定的
程序**。内核知道如何为编译型程序做这件事。我们的nusers Shell脚本 **并非编译型程序**，当Shell要
求内核执行它时，内核将无法做这件事，**并回应“not executable format file”（不是可执行的格式文
件）错误信息**。Shell收到此错误信息时，就会说“啊哈，这不是编译型程序，那么一定是Shell脚本”，接着
**会启动一个新的/bin/sh（标准Shell）副本来执行该程序**。

**现行的UNIX系统都会拥有好几个Shell，因此需要通过一种方式，告知UNIX内核应该以哪个Shell来执行所指
定的Shell脚本**。事实上，这么做有助于 **执行机制的通用化** ，让用户得以 **直接引用任何的程序语言
解释器，而非只是一个命令Shell**。方法是，通过脚本文件中特殊的第一行来设置，在第一行的开头处使用
**#!** 这两个字符。

当一个文件中开头的两个字符是 **#!** 时，**内核会扫描该行其余的部分，看是否存在可用来执行程序的解释
器的完整路径**。（中间如果出现任何空白符号都会略过。）此外，**内核还会扫描是否有一个选项要传递给解释器**。
内核会以被指定的选项来引用解释器，**再搭配命令行的其他部分**。举例来说，假设有一个csh脚本，名为
/usr/ucb/whizprog，它的第一行如下所示：
```
#! /bin/awk -f
```
```
注明：

/bin/csh是C Shell的命令解释器，由加州大学伯克利分校所开发。本书不讨论C Shell程序设计的原因很多，其中最重要的一点是：
就脚本的编写来说，大多数人认为它不是个好用的Shell，另一个原因则是它并未被POSIX标准化。
```
再者，如果Shell的查找路径（后面会介绍）里有`/usr/ucb`，当用户键入`whizprog -q /dev/tty01` 这条命令，
内核解释 #! 这行后，便会以如下的方式来引用csh：
```shell
/bin/csh -f /usr/ucb/whizprog -q /dev/tty01 
```










































dd
