索引的类型
================================================================================
**索引有很多种类型**，可以为不同的场景提供更好的性能。**在MySQL中，索引是在存储引擎层** 而不是
服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储
引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

## B-Tree索引
**当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引**，它使用 **B-Tree数据结
构** 来存储数据。大多数MySQL引擎都支持这种索引。**Archive引擎是一个例外**：5.1之前Archive不支
持任何索引，直到５.1才开始支持单个自增列（AUTO INCREMENT）的索引。

我们使用术语“**B-Tree**”，是因为MySQL在`CREATE TABLE`和其他语句中也使用该关键字。不过，**底
层的存储引擎也可能使用不同的存储结构**，例如，`NDB`集群存储引擎内部实际上使用了`T-Tree`结构存储
这种索引，即使其名字是`BTREE`，**InnoDB则使用的是B+Tree**。

存储引擎以不同的方式使用`B-Tree`索引，性能也各有不同，各有优劣。例如，**MyISAM** 使用 **前缀压
缩技术** 使得索引更小，但 **InnoDB则按照原数据格式进行存储**。再如`MyISAM`索引通过数据的物理位
置引用被索引的行，而 **InnoDB则根据主键引用被索引的行**。

**B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同**。

![建立在B-Tree结构上的索引](img/1.jpeg)

**上图大致反映了InnoDB索引是如何工作的**。MyISAM使用的结构有所不同，但基本思想是类似的。

`B-Tree`索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是
**从索引的根节点（图中并未画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些
指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了
子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。叶子节点比较特别，它们
的指针指向的是被索引的数据，而不是其他的节点页（不同引擎的“指针”类型不同）**。上图中仅绘制了一个节点
和其对应的叶子节点，**其实在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关**。

**B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据**。例如，在一个基于文本域的索引树上，按字
母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以`I`到`K`开头的名字”这样的查找效率会非常高。

假如有如下数据表：
```sql
CREATE TABLE Perple (
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum('m', 'f') not null,
    key(last_name, first_name, dob)
);
```
对于表中的每一行数据，索引中包含了last_name、first_name和dob列的值，下图显示了该索引是如何组织
数据的存储的：

![B-Tree索引树中的部分条目示例](img/2.jpeg)

请注意，**索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序**。看一下最后两个条目，
两个人的姓和名都一样，则根据他们的出生日期来排列顺序。

**可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找**。其中 **键前缀查找**
只适用于根据 **最左前缀** 的查找。

**前面所述的索引对如下类型的查询有效**。

### 全值匹配
**全值匹配指的是和索引中的所有列进行匹配**，例如前面提到的索引可用于查找姓名为`Cuba Allen`、出生
于`1960-01-01`的人。

### 匹配最左前缀
前面提到的索引可用于查找所有 **姓** 为`Allen`的人，**即只使用索引的第一列（last_name）**。

### 匹配列前缀
也可以 **只匹配某一列的值的开头部分**。例如前面提到的索引可用于查找所有以J开头的 **姓** 的人。
**这里也只使用了索引的第一列**。

### 匹配范围值
例如前面提到的索引可用于查找 **姓** 在Allen和Barrymore **之间** 的人。**这里也只使用了索引的
第一列**。

### 精确匹配某一列并范围匹配另外一列
前面提到的索引也可用于查找所有 **姓** 为Allen，并且 **名字** 是字母K **开头**（比如Kim、Karl等）
的人。**即第一列last_name全匹配，第二列first_name范围匹配**。

### 只访问索引的查询
**B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行**。后面我们将单独
讨论这种“**覆盖索引**”的优化。

**因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）**。
一般来说，**如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序**。所以，**如果
ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求**。



















































dd
