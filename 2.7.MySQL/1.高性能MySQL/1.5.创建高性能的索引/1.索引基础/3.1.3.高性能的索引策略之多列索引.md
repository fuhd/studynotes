高性能的索引策略之多列索引
================================================================================
很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多
列索引。

我们会在下一节中单独讨论索引列的顺序问题。先来看第一个问题，为每个列创建独立的索引，从`SHOW CREATE
TABLE`中很容易看到这种情况：
```sql
CREATE TABLE t (
    c1 INT,
    c2 INT,
    c3 INT,
    KEY(c1),
    KEY(c2),
    KEY(c3)
);
```
**这种索引策略，一般是由于人们听到一些专家诸如“把WHERE条件里面的列都建上索引”这样模糊的建议导致的。
实际上这个建议是非常错误的。这样一来最好的情况下也只能是“一星”索引，其性能比起真正最优的索引可能差
几个数量级。有时如果无法设计一个”三星“索引，那么不如忽略掉WHERE子句，集中精力优化索引列的顺序，或
者创建一个全覆盖索引**。

**在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种
叫“索引合并”（index merge）的策略，一定程序上可以使用表上的多个单列索引来定位指定的行**。更早版本
的MySQL只能使用其中某一个单列索引，然而这种情况下没有哪一个独立的单列索引是非常有效的。例如，表
`film_actor`在字段`film_id`和`actor_id`上各有一个单列索引。但对于下面这个查询`WHERE`条件，这
两个单列索引都不是好的选择：
```sql
mysql> SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1;
```








































rrr
