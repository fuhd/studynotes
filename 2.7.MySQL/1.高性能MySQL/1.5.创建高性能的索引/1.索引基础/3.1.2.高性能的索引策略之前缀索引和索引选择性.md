高性能的索引策略之前缀索引和索引选择性
================================================================================
**有时候需要索引很长字符列，这会让索引变得大且慢**。一个策略是前面提到过的 **模拟哈希索引。但有时
候这样做还不够**，还可以做些什么呢？

**通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择
性**。索引的选择性是指，**不重复的索引值（也称为基数，cardinality）和数据表的记录总数（＃T)的比
值，范围从1/#T到1之间。索引的选择性越高则查询效率越高**，因为选择性高的索引可以让MySQL在查找时过
滤掉更多的行。**唯一索引的选择性是１，这是最好的索引选择性，性能也是最好的**。

**一般情况下某个列的前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR
类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度**。

**诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）**。前缀应该足够长，
以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”应该接近于完整的”基数“。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。示例：
```sql
CREATE TABLE sakila.city_demo (city VARCHAR(50) NOT NULL);
INSERT INTO sakila.city_demo (city) SELECT city FROM sakila.city;
-- Repeat the next statement five times:
INSERT INTO sakila.city_demo (city) SELECT city FROM sakila.city_demo;
-- Now randomize the distribution (inefficiently but conveniently):
UPDATE sakila.city_demo SET city = (SELECT city FROM sakila.city ORDER BY RAND() limit 1);
```
现在我们有了示例数据集。数据分布当然不是真实的分布：因为我们使用了RAND()，所以你的结果会与些不同，
但对这个练习来说这并不重要。首先，**我们找到最常见的城市列表**：
```sql
mysql> SELECT COUNT(*) AS cnt, city FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;
```
```
+-----+----------------+
| cnt | city           |
+-----+----------------+
| 65  | London         |
| 49  | Hiroshima      |
| 48  | Teboksary      |
| 48  | Pak Kret       |
| 48  | Yaound         |
| 47  | Tel Aviv-Jaffa |
| 47  | Shimoga        |
| 45  | Cabuyao        |
| 45  | Callao         |
| 45  | Bislig         |
+-----+----------------+
```







































ddd
