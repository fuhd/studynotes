选择合适的索引列顺序
================================================================================
我们遇到的最容易引起困惑的问题就是 **索引列的顺序**。**正确的顺序依赖于使用该索引的查询**，并且同
时需要考虑如何更好地满足 **排序** 和 **分组** 的需要（顺便说明，**本节内容适用于B-Tree索引**，
哈希或者其他类型的索引并不会像B-Tree索引一样按顺序存储数据）。

在一个 **多列B-Tree索引** 中，索引列的顺序意味着 **索引首先按照最左列进行排序，其次是第二列，等
等**。所以，索引可以按照 **升序** 或者 **降序** 进行扫描，以满足 **精确符合列顺序的ORDER BY、
GROUP BY和DISTINCT等子句的查询需求**。

所以 **多列索引的列顺序至关重要**。在Lahdenmaki和Leach的 **“三星索引”系统中，列顺序也决定了一
个索引是否能够成为一个真正的”三星索引”**。

对于如何选择索引的列顺序有一个经验法则：**将选择性最高的列放到索引最前列**。这个建议有用吗？**在
某些场景可能有帮助，但通常不如避免随机IO和排序那么重要**，考虑问题需要更全面（场景不同则选择不同，
**没有一个放之四海皆准的法则**。这里只是说明，这个经验法则可能没有你想象的重要）。

**当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE
条件的查找**。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在WHERE子句中只使用了索
引部分前缀列的查询来说选择性也更高。然而，**性能不只是依赖于所有索引列的选择性（整体基数），也和查询
条件的具体值有关**，也就是和值的分布有关。这和前面介绍的选择前缀的长度需要考虑的地方一样。**可能需要
根据那些运行频率最高的查询来调整索引列的顺序**，让这种情况下索引的选择性最高。

以下面的查询为例：
```sql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
```
**是应该创建一个(staff_id, customer_id)索引还是应该颠倒一下顺序？可以跑一些查询来确定在这个表中
值的分布情况，并确定哪个列的选择性更高**。先用下面的查询预测一下，看看各个WHERE条件的分支对应的数据
基数有多大：
```
备注：

某些优化极客将这称为“sarg”，这是“可搜索的参数（searchable argument）”的缩写，好吧，学会了这个词你也是一个极客了！
```
```sql
mysql> SELECT SUM(staff_id = 2), SUM(customer_id = 584) FROM payment\G
```
```
*************************** 1.row ***************************
        SUM(staff_id = 2): 7992
   SUM(customer_id = 584): 30
```
**根据前面的经验法则，应该将索引列customer_id放到前面，因为对应条件值的customer_id数量更小**，
我们再来看看对于这个`customer_id`的条件值，对应的`staff_id`列的 **选择性** 如何：
```sql
mysql> SELECT SUM(staff_id = 2) FROM payment WHERE customer_id = 584\G
```
```
*************************** 1.row ****************************
      SUM(staff_id = 2): 17
```
这样做有一个地方需要注意，**查询的结果非常依赖于选定的具体值**。如果按上述办法优化，**可能对其他
一些条件值的查询不公平**，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

如果是从诸如 **pt-query-digest** 这样的 **工具** 的报告中提取“**最差**”查询，那么 **再按上
述办法选定的索引顺序** 往往是非常高效的。**如果没有类似的具体查询来运行，那么最好还是按经验法则来
做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询**：
```sql
mysql> SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
       COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
       COUNT(*)
       FROM payment\G
```
```
*************************** 1.row ***************************
        staff_id_selectivity: 0.0001
     customer_id_selectivity: 0.0373
                    COUNT(*): 16049
```
**customer_id的选择性更高，所以答案是将其作为索引列的第一列**：
```sql
mysql> ALTER TABLE payment ADD KEY(customer_id, staff_id);
```
**当使用前缀索引的时候，在某些条件值的基数比正常值高的时候，问题就来了**。例如，在某些应用程序中，
对于没有登录的用户，都将其用户名记录为“guest”，在记录用户行为的会话（session）表和其他记录用户
活动的表中"guest"就成为了一个特殊用户ID。一旦查询涉及这个用户，那么和对于正常用户的查询就大不同
了，因为通常有很多会话都是没有登录的。系统帐号也会导致类似的问题。一个应用通常都有一个特殊的管理员
帐号，和普通帐号不同，它并不是一个具体的用户，系统中所有的其他用户都是这个用户的好友，所以系统往往
通过它向网站的所有用户发送状态通知和其他消息。这个帐号的巨大的好友列表很容易导致网站出现服务器性能
问题。

**这实际上是一个非常典型的问题**。任何的异常用户，不仅仅是那些用于管理应用的设计糟糕的帐号会有同
样的问题，那些拥有大量好友、图片、状态、收藏的用户，也会有前面提到的系统帐号同样的问题。

下面是一个我们遇到过的 **真实案例**，在一个用户分享购买商品和购买经验的论坛上，这个特殊表上的查询
运行得 **非常慢**：
```sql
mysql> SELECT COUNT(DISTINCT threadId) AS COUNT_VALUE
       FROM Message
       WHERE (groupId = 10137) AND (userId = 1288826) AND (anonymous = 0)
       ORDER BY priority DESC, modifiedDate DESC
```
这个查询 **看似没有建立合适的索引**，所以客户咨询我们是否可以优化。**EXPLAIN** 的结果如下：
```
            id: 1
   select_type: SIMPLE
         table: Message
          type: ref
           key: ix_groupId_userId
       key_len: 18
           ref: const,const
          rows: 1251162
         Extra: Using where
```
**MySQL为这个查询选择了索引(groupId, userId)，如果不考虑列的基数，这看起来是一个非常合理的选
择**，但如果考虑一下user ID和group ID条件匹配的行数，可有就会 **有不同的想法** 了：
```sql
mysql> SELECT COUNT(*), SUM(groupId = 10137),SUM(userId = 1288826),SUM(anonymous = 0)
       FROM Message\G
```
```
*************************** 1.row ***************************
            count(*): 4142217
sum(groupId = 10137): 4092654
 sum(userId 1288826): 1288496
  sum(anonymous = 0): 4141934
```
从上面的结果来看符合组(groupId)条件几乎满足表中的所有行，符合用户(userId)条件的有130万条记录——
**也就是说索引基本上没什么用**。因为这些 **数据是从其他应用中迁移过来的，迁移的时候把所有的消息都
赋予了管理员组的用户**。这个案例的解决办法是 **修改应用程序代码，区分这类特殊用户和组，禁止针对这
类用户和组执行这个查询**。

从这个小案例可以看到 **经验法则和推论在多数情况是有用的，但要注意不要假设平均情况下的性能也能代表特
殊情况下的性能**，特殊情况可能会摧毁整个应用的性能。

最后，尽管关于选择性和基数的经验法则值得去研究和分析，**但一定要记住别忘了WHERE子句中的排序，分组和
范围条件等** 其他因素，这些因素可能对查询的性能造成非常大的影响。
