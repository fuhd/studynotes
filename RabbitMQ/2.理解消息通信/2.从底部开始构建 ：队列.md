从底部开始构建 ：队列
=====================================================================
从概念上来讲：**AMQP消息路由必须有三部分：交换器、队列和绑定**。生产者把消息发布到交换器上；
消息最终到达队列，并被消费者接收；**绑定决定了消息如何从交换器路由到特定的队列**。在研究交换器和绑定之前，
需要先理解队列的概念和工作原理。

### 消费者通过两种方式从特定的队列中接收消息
+ 通过AMQP的 **basic.consume** 命令订阅。这样做 **会将信道置为接收模式**，直到取消对队列的订阅为止。
订阅了消息后，消费者在消费（或者拒绝）最近接收的那条消息后，**就能从队列中（可用的）自动接收下一条消息**。
如果消费者处理队列消息，并且/或者需要 **在消息一到达队列时就自动接收的话，你应该使用basic.consume**。
+ 某些时候，**你只想从队列获得单条消息而不是持续订阅**。向队列请求单条消息是通过AMQP的 **basic.get** 命令实现的。
这样做可以让消费者接收队列中的下一条消息。如果要获得更多消息的话，需要再次发送basic.get命令。
**你不应该将basic.get放在一个循环里来替代basic.consume。因为这样做会影响Rabbit的性能。大致上讲，
basic.get命令会订阅消息，获得单条消息，然后取消订阅。消费者理应始终使用basic.consume来实现高吞吐量**。

### 队列无消费者订阅或者多消费者订阅
如果至少有一个消费者订阅了队列的话，**消息会立即发送给这些订阅的消费者**。**但是如果消息到达了无人订阅的队列呢？
在这种情况下，消息会在队列中等待**。一旦有消费者订阅到该队列，那么队列上的消息就会发送给消费者。

**当有多个消费者订阅到同一队列上时，消息是如何分发的？当Rabbit队列拥有多个消费者时，队列收到的消息将以循环
（round-robin）的方式发送给消费者。每条消息只会发送给一个订阅的消费者**。

### 消息确认
**消费者接收到的每一条消息都必须进行确认。消费者必须通过AMQP的basic.ack命令显式地向RabbitMQ发送一个确认，
或者在订阅到队列的时候就将auto_ack参数设置为true。当设置了auto_ack时，一旦消费者接收消息，RabbitMQ会自动
视其确认了消息**。需要记住的是，**消费者对消息的确认和告诉生产者消息已经被接收了这两件事毫不相关**。
因此，**消费者通过确认命令告诉RabbitMQ它已经正确地接收了消息，同时RabbitMQ才能安全地把消息从队列中删除**。

**如果消费者收到一条消息，然后确认之前从Rabbit断开连接（或者从队列上取消订阅），RabbitMQ会认为这条消息没有分发，
然后重新分发给下一个订阅的消费者**。如果你的应用程序崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理。

另一方面，**如果应用程序有bug而忘记确认消息的话，Rabbit将不会给该消费者发送更多消息了。这是因为在上一条消息
被确认之前，Rabbit会认为这个消费者并没有准备好接收下一条消息**。你可以好好利用这一点。如果处理消息内容非常耗时，
则你的应用程序可以延迟确认该消息，直到消息处理完成。这样可以防止Rabbit持续不断的消息涌向你的应用而导致过载。

### 消息拒绝
**在收到消息后，如果你想要明确拒绝而不是确认收到该消息的话，该如何呢**？举例来说，假设在处理消息的时候你遇到
了不可恢复的错误，但是由于硬件问题，只影响到当前的消费者。只要消息未确认，则你有以下两个选择：
+ **把消费者从RabbitMQ服务器断开连接。这会导致RabbitMQ自动重新把消息入队并发送给另一个消息者**。
这样做的好处是所有的RabbitMQ版本都支持。缺点是，**这样连接/断开连接的方式会额外增加RabbitMQ的负担**。
+ **如果你正使用RabbitMQ2.0.0或者更新的版本，那就使用AMQP的basic.reject命令**。顾名思义：**basic.reject允许
消费者拒绝RabbitMQ发送的消息。如果把reject命令的requeue参数设置成true的话，RabbitMQ立即会把消息从队列中
移除，而不会把它发送给新的消费者**。你也可以通过对消息确认的方式来简单地忽略该消息（这种忽略消息的方式的优势在于
所有版本的RabbitMQ都支持）。如果你检测到一条格式错误的消息而任何一个消费者都无法处理的时候，这样做就十分有用。
