我的消息去哪儿了呢？持久化和你的策略
======================================================================
### 消息持久化的要点
关于在Rabbit里创建 **队列和交换器** 有个不可告人的秘密：**默认情况下它们无法幸免于服务器重启**。
没错，**重启RabbitMQ服务器后，那些队列和交换器就都消失了（随同里面的消息）**。原因在于每个 **队列和交换器
的durable属性。该属性默认情况为false，它决定了RabbitMQ是否需要在崩溃或者重启之后重新创建队列（或者
交换器）。将它设置true，这样你就不需要在服务器断电后重新创建队列和交换器了**。你也许会认为把队列和交换器
的durable属性设置为true就足够可以让消息幸免于重启，但是你错了。队列和交换器当然必须被设置成true，
但光这样做还不够。

**能从AMQP服务器崩溃中恢复的消息，我们称之为持久化消息**。在消息发布前，通过把它的 **“投递模式”（delivery mode）
选项设置为2来把消息标记成持久化**。到目前为止，消息还只是被表示为持久化的，但是它还必须被发布到持久化的
交换器中并到达持久化的队列中才行。如果不是这样的话，则包含持久化消息的队列（或者交换器）会在Rabbit崩溃
重启后不复存在，从而导致消息成为孤儿。因此，如果消息想要从Rabbit崩溃中恢复，那么消息必须：
+ **把它的投递模式选项设置为2（持久）**；
+ **发送到持久化的交换器**；
+ **到达持久化的队列**；

做到以上三点，你就不用和你的关键消息玩“躲猫猫”了。

RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，**将它们写入磁盘上的一个持久化日志文件**。
当发布一条 **持久性消息** 到 **持久交换器** 上时，**Rabbit会在消息提交到日志文件后才发送响应**。记住，
**之后这条消息如果路由到了非持久队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复**。
如果你使用持久性消息的话，则确保之前提到的持久性消息的那三点都必须做到位。

一旦你 **从持久化队列中消费了一条持久性消息的话（并且确认了它）**，RabbitMQ会在持久化日志中 **把这条消息标记为
等待垃圾收集**。在你消费持久性消息前，如果RabbitMQ重启的话，服务器会自动重建交换器和队列（以及绑定），
重播持久性日志文件中的消息到合适的队列或者交换器上（取决于Rabbit服务器宕机的时候，消息处在路由过程的哪个环节）。

### 消息持久化的代价
你可能认为自己应该为所有的消息都启用持久化消息通信。你可以这样做，但同时你也要为此付出代价：**性能**。
写入磁盘要比存入内存中慢不止一点点，而且会 **极大地减少RabbitMQ服务器每秒可处理的消息总数**。使用持久化机制而导致
消息 **吞吐量降低至少10倍的情况并不少见**。另外还有一点就是，**持久性消息在RabbitMQ内键集群环境下工作得并不好**。
这个主题后面再讲！！

### 什么情况下应该使用持久化？
什么情况下你应该使用持久性/持久化消息通信呢？首先，**你需分析性能需求**。**你是否需要单台Rabbit服务器每秒
处理100000条消息呢？** 如果是这样的话，你应该 **寻找其他方式来保证消息投递**（或者使用更快的存储系统）。
举例来说，生产者可以 **在单独的信道上监听应答队列**。每次发送消息的时候，都包含应答队列的名称。这样消费者就可以
回发应答以确认接收到了。**如果消息应答未在合理时间范围内到达，生产者就重新发送消息**。也就是说，要保证消息
的投递这一关键本质决定了相对于其他类型的消息（例如日志消息）会有更低的吞吐量。因此 **如果持久化消息通信能够满足
性能需求的话，那么用这种机制确保消息投递是极佳的方式。我们更多的是为关键消息使用持久化机制**。
请记住Rabbit能帮助确保投递，但 **并不是万无一失** 的。**硬盘崩溃、充满bug的消费者或者其他极端事件都能导致持久化
消息丢失。最终确保消息安全到达都将取决于你的策略**。持久化消息通信是一个很好的工具，可以帮助你完成这一点。

### AMQP事务
到目前为止，我们讨论的是将消息、队列和交换器设置为持久化。这一切都工作得很好，并且RabbitMQ也负责保证消息的安全。
但是 **由于发布操作不返回任何信息给生产者，那你怎么知道服务器是否已经持久化了持久消息到硬盘呢**？服务器可能会在
把消息写入磁盘前就宕机了，消息因此而丢失，而你却不知道。**这就是事务发挥作用的地方**。

**不要把AMQP事务和大多数数据库的事务概念搞混了**。在AMQP中，在把 **信道设置成事务模式** 后，你通过信道发送
那些想要确认的消息，之后还有多个其他AMQP命令。**这些命令是执行还是忽略，取决于第一条消息发送是否成功**。
一旦你发送完所有命令，就可以提交事务了。**如果事务中的首次发布成功了，那么信道会在事务中完成其他AMQP命令。
如果发送失败的话，其他AMQP命令将不会执行**。事务填补了生产者发布消息以及RabbitMQ将它们提交到磁盘上这两者之间
“最后一英里”的差距。

### 发送方确认模式（confirm模式）
虽然 **事务** 是正式AMQP0-9-1规范的一部分，但是它们有阿喀琉斯之踵：**几乎吸干了Rabbit的性能**。
使用事务不但会降低大约2～10倍的消息吞吐量，而且会使生产者应用程序产生同步。而你使用消息通信就是想要避免同步。
知晓了所有这一切之后，RabbitMQ团队决定拿出更好的方案来保证消息投递：**发送方确认模式**（这是 **RabbitMQ独有的
针对AMQP的扩展**「尽管其他服务器也可以自由地将其添加到AMQP实现中去」。**该模式仅在RabbitMQ2.3.1或更高版本中可用**）。

和事务相仿，你需要告诉Rabbit **将信道设置成confirm模式**，而且你 **只能通过重新创建信道来关闭该设置**。
**一旦信道进入confirm模式，所有在信道上发布的消息都会被指派一个唯一的ID号（从1开始）。一旦消息被投递给所有匹配
的队列后，信道会发送一个发送方确认模式给生产者应有和程序（包含消息的唯一ID）。这使得生产者知晓消息已经安全到达
目的队列了。如果消息和队列是可持久化的，那么确认消息只会在队列将消息写入磁盘后才会发出**。

**发送方确认模式的最大好处是它们是异步的**。当确认消息最终收到的时候，**生产者应用的回调方法就会被触发来处理该确认消息**。
如果Rabbit发生了内部错误从而导致了消息的丢失，Rabbit会发送一条 **nack（not acknowledged,未确认）消息**。
就像发送方确认消息那样，只不过这次说明的是消息已经丢失了。同时，由于 **没有消息回滚的概念**（同事务相比），
因此发送方确认模式更加轻量级，同时对Rabbit代理服务器的性能影响几乎可以忽略不计。
