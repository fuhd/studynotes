我的消息去哪儿了呢？持久化和你的策略
======================================================================
### 消息持久化的要点
关于在Rabbit里创建 **队列和交换器** 有个不可告人的秘密：**默认情况下它们无法幸免于服务器重启**。
没错，**重启RabbitMQ服务器后，那些队列和交换器就都消失了（随同里面的消息）**。原因在于每个 **队列和交换器
的durable属性。该属性默认情况为false，它决定了RabbitMQ是否需要在崩溃或者重启之后重新创建队列（或者
交换器）。将它设置true，这样你就不需要在服务器断电后重新创建队列和交换器了**。你也许会认为把队列和交换器
的durable属性设置为true就足够可以让消息幸免于重启，但是你错了。队列和交换器当然必须被设置成true，
但光这样做还不够。

**能从AMQP服务器崩溃中恢复的消息，我们称之为持久化消息**。在消息发布前，通过把它的 **“投递模式”（delivery mode）
选项设置为2来把消息标记成持久化**。到目前为止，消息还只是被表示为持久化的，但是它还必须被发布到持久化的
交换器中并到达持久化的队列中才行。如果不是这样的话，则包含持久化消息的队列（或者交换器）会在Rabbit崩溃
重启后不复存在，从而导致消息成为孤儿。因此，如果消息想要从Rabbit崩溃中恢复，那么消息必须：
+ **把它的投递模式选项设置为2（持久）**；
+ **发送到持久化的交换器**；
+ **到达持久化的队列**；

做到以上三点，你就不用和你的关键消息玩“躲猫猫”了。

RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，**将它们写入磁盘上的一个持久化日志文件**。
当发布一条 **持久性消息** 到 **持久交换器** 上时，**Rabbit会在消息提交到日志文件后才发送响应**。记住，
**之后这条消息如果路由到了非持久队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复**。
如果你使用持久性消息的话，则确保之前提到的持久性消息的那三点都必须做到位。

一旦你 **从持久化队列中消费了一条持久性消息的话（并且确认了它）**，RabbitMQ会在持久化日志中 **把这条消息标记为
等待垃圾收集**。在你消费持久性消息前，如果RabbitMQ重启的话，服务器会自动重建交换器和队列（以及绑定），
重播持久性日志文件中的消息到合适的队列或者交换器上（取决于Rabbit服务器宕机的时候，消息处在路由过程的哪个环节）。

### 消息持久化的代价
你可能认为自己应该为所有的消息都启用持久化消息通信。你可以这样做，但同时你也要为此付出代价：**性能**。
写入磁盘要比存入内存中慢不止一点点，而且会 **极大地减少RabbitMQ服务器每秒可处理的消息总数**。使用持久化机制而导致
消息 **吞吐量降低至少10倍的情况并不少见**。另外还有一点就是，**持久性消息在RabbitMQ内键集群环境下工作得并不好**。
这个主题后面再讲！！

### 什么情况下应该使用持久化？
什么情况下你应该使用持久性/持久化消息通信呢？首先，**你需分析性能需求**。**你是否需要单台Rabbit服务器每秒
处理100000条消息呢？** 如果是这样的话，你应该 **寻找其他方式来保证消息投递**（或者使用更快的存储系统）。
举例来说，生产者可以 **在单独的信道上监听应答队列**。每次发送消息的时候，都包含应答队列的名称。这样消费者就可以
回发应答以确认接收到了。**如果消息应答未在合理时间范围内到达，生产者就重新发送消息**。也就是说，要保证消息
的投递这一关键本质决定了相对于其他类型的消息（例如日志消息）会有更低的吞吐量。因此如果持久化消息通信能够满足
性能需求的话，那么用这种机制确保消息投递是极佳的方式。
