并发
====================================================================
**`Scala`有许多诱人之处，能够使用`Akka API`通过直观的`actor`模式构建健壮的并发应用便是其中之一**。

将`Scala`与一套直观的并发`API`相结合，便能以如此简洁优雅的方式实现并发软件。你之前研究`Scala`的一个原因
可能是寻求更好的并发之道，**以便更好地利用多核`CPU`和集群中的服务器来实现并发。使用`actor`并发模型便是其中的一种方法**。

**在`actor`并发模型中，`actor`是独立的软件实体，它们之间并不共享任何可变状态信息。`actor`之间无须共享信息，
通过交换消息的方式便可进行通信。通过消除同步访问那些共享可变状态，编写健壮的并发应用程序变得非常简单。尽管这些`actor`
也许需要修改状态，但是假如这些可变状态对外不可访问，并且`actor`框架确保`actor`相关代码调用是线程安全的，
开发者就无須再费力编写枯燥而又容易出错的同步原语了**。

在这个简单示例中， 我们会将表示几何图形的一组类的实例发送给一个`actor`，该`actor`再将这组实例绘制到显示器上。
你可以想象这样一个场景：渲染工厂（`rendering farm`）在为动画生成场景。一旦场景渲染完毕，构成场景的几何图形便会
被发送给某一`actor`进行展示。

首先，我们将定义`Shape`类：
```scala
//src/main/scala/progscala2/introscala/shapes/Shapes.scala
package progscala2.introscala.shapes

case class Point(x: Double = 0.0, y: Double = 0.0)                                      //1

abstract class Shape() {                                                                //2
    /*
    * draw方法接受一个函数参数。每个图形对象都会将自己的字符格式传给函数f,
    * 由函数f执行绘制工作。
    */
    def draw(f: String => Unit): Unit = f(s"draw: ${this.toString}")                    //3
}

case class Circle(center: Point, radius: Double) extends Shape                          //4
case class Rectangle(lowerLeft: Point, height: Double, width: Double) extends Shape     //5
case class Triangle(point1: Point, point2: Point, point3: Point) extends Shape          //6
```
+ 注1：此处声明了一个表示二维点的类。
+ 注2：此处声明了一个表示几何形状的抽象类。
+ 注3：此处实现了一个“绘制”形状的`draw`方法，该方法中仅输出了一个格式化的字符串。
+ 注4：`Circle`类由圆心和半径组成。
+ 注5：位于左下角的点、高度和宽度这三个属性构成了矩形。为了简化问题，我们规定矩形的各条边分别与横坐标或纵坐标平行。
+ 注6：三角形由三个点所构成。

`Point`类名后列出的参数列表就是 **类构造函数参数列表**。**在`Scala`中，整个类主体便是这个类的构造函数，因此你能在类名之后、
类主体之前列出主构造函数的参数**。在本示例中，`Point`类并没有类主体。**由于我们在`Point`类声明的前面输入了`case`关键字，
因此每一个构造函数参数都自动转化为`Point`实例的某一只读（不可变）字段**。也就是说，假如要实例化一个名为`Point`的`point`
实例，你可以使用`point.x`和`point.y`读取`point`的字段，但无法修改它们的值。

你也 **可以设置参数默认值**。每个参数定义后出现`=0.0`会把`0.0`设置为该参数的默认值。**因此用户无须明确给出参数值，
`Scala`便会推导出参数值。不过这些参数值会按照从左到右的顺序进行推导**。下面我们运用`SBT`项目去进一步探索参数默认值：
```shell
$ sbt console
[info] Loading project definition from /home/fuhd/work/github/prog-scala-2nd-ed-code-examples/project
[info] Set current project to Programming Scala, Second Edition - Code examples (in build file:/home/fuhd/work/github/prog-scala-2nd-ed-code-examples/)
[info] Starting scala interpreter...
[info] 
Welcome to Scala version 2.11.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_144).
Type in expressions to have them evaluated.
Type :help for more information.

scala> import progscala2.introscala.shapes._
import progscala2.introscala.shapes._

scala> val p00 = new Point
p00: progscala2.introscala.shapes.Point = Point(0.0,0.0)

scala> val p20 = new Point(2.0)
p20: progscala2.introscala.shapes.Point = Point(2.0,0.0)

scala> val p20b = new Point(2.0)
p20b: progscala2.introscala.shapes.Point = Point(2.0,0.0)

scala> val p02 = new Point(y = 2.0)
p02: progscala2.introscala.shapes.Point = Point(0.0,2.0)

scala> p00 == p20
res0: Boolean = false

scala> p20 == p20b
res1: Boolean = true
```
因此，**当我们不指定任何参数时，`Scala`会使用`0.0`作为参数值。当我们只设定了一个参数值时，`Scala`会把这个值
赋予最左边的参数`x`，而剩下来的参数则使用默认值。我们还可以通过名字指定参数。对于`p02`对象，当我们想使用`x`
的默认值却为`y`赋值时，可以使用`Point(y = 2.0)`的语句**。

由于`Point`类并没有类主体，**`case`关键字的另一个特征便是让编译器自动为我们生成许多方法，其中包括了类似于`Java`
语言中`String`、`equals`和`hashCode`方法**。每个点显示的输出信息，如`Point(2.0,0.0)`，其实是`toString`方法的输出。
大多数开发者很难正确地实现`equals`方法和`hashCode`方法，因此自动生成这些方法具有实际的意义。

**`Scala`调用生成的`equals`方法，以判断`p00 == p20`和`p20 == p20b`是否成立。这与`Java`的做法不同，
`Java`通过比较引用是否相同来判断`==`是否成立**。

现在我们要谈论`case`类的最后一个特性，**编译器同时会生成一个伴生对象（`companion object`），伴生对象是一个与`case`类
同名的单例对象**。
```
你可以自己定义伴生对象。任何时候只要对象名和类名相同并且定义在同一个文件中，这些对象就能称作伴生对象。
```
随后可以看到，**我们可以在伴生对象中添加方法。不过伴生对象中已经自动添加了不少方法，`apply`方法便是其中之一。
该方法接受的参数列表与构造函数接受的参数列表一致**。

任何时候只要你 **在输入对象后紧接着输入一个参数列表，`Scala`就会查找并调用该对象的`apply`方法**，这也意味着下面
两行代码是等价的：
```scala
val p1 = Point.apply(1.0, 2.0)
val p2 = Point(1.0, 2.0)
```
如果对象中未定义`apply`方法，系统将抛出编译错误。

**`Point.apply`方法实际上是构建`Point`对象的工厂方法**，它的行为很简单：调用该方法就好像是不通过`new`关键字
调用`Point`的构造函数一样。**伴生对象其实与下列代码生成的对象无异**：
```scala
object Point {
    def apply(x: Double = 0.0, y: Double = 0.0) = new Point(x, y)
    ...
}
```
不过，伴生对象`apply`方法也可以用于决定相对复杂的类继承结构。
```
紧挨着对象名输入参数列表时，Scala会查找并调用匹配该参数列表的apply方法。换句话说，Scala会猜想该对象定义了apply
方法。
在伴生对象中安置apply方法是Scala为相关类定义工厂方法的一个便利写法。在类中定义而不是在对象中定义的apply方法适用
于该类的实例。
```
`Shape`是一个抽象类。**在`Scala`中我们无法实例化一个抽象类，即使该抽象类中没有抽象成员**。该类定义了`Shape.draw`方法，
不过我们只希望能够实例化具体的形状：圆形、矩阵或三角形。

请注意传给`draw`方法的参数，**该参数是一个类型为`String => Unit`的函数**。也就是说，函数`f`接受字符串参数输入并返回
`Unit`类型。**`Unit`是一个实际存在的类型，它的表现却与`Java`中的`void`类型相似**。在函数式编程中，大家将`void`类型称
为`Unit`类型。
```
假如某函数返回Unit对象，那么该函数肯定是有副作用的。Unit对象没有任何作用，因此该函数只能对某些状态产生副作用。副作用可能
会造成全局范围的影响，比如执行一次输入或输出操作（I/O），也可能只会影响某些局部对象。
```
**通常在函数式编程中，人们更青睐于那些没有任何副作用的纯函数，这些纯函数的返回值便是它们的工作成果。纯函数容易阐述、易于测试，
也很方便重用**，而副作用往往是错误之源。不过最起码现实中的程序离不开I/O。

**函数也是第一等级的值，和其它值一样，我们可以将函数赋给变量，将函数作为参数传递给其他函数，就好像`draw`方法一样。
函数还能作为其他函数的返回值**。

**假如某函数接受其他函数参数并返回函数，我们称之为高阶函数（`higher-order function`，`HOF`）**。

示例中，`draw`方法会调用`f`函数，而`f`函数通过 **`Scala2.10`引入的新特性：插值字符串（`interpolated string`）** 
构建了最终的字符串。






