并发
====================================================================
**`Scala`有许多诱人之处，能够使用`Akka API`通过直观的`actor`模式构建健壮的并发应用便是其中之一**。

将`Scala`与一套直观的并发`API`相结合，便能以如此简洁优雅的方式实现并发软件。你之前研究`Scala`的一个原因
可能是寻求更好的并发之道，**以便更好地利用多核`CPU`和集群中的服务器来实现并发。使用`actor`并发模型便是其中的一种方法**。

**在`actor`并发模型中，`actor`是独立的软件实体，它们之间并不共享任何可变状态信息。`actor`之间无须共享信息，
通过交换消息的方式便可进行通信。通过消除同步访问那些共享可变状态，编写健壮的并发应用程序变得非常简单。尽管这些`actor`
也许需要修改状态，但是假如这些可变状态对外不可访问，并且`actor`框架确保`actor`相关代码调用是线程安全的，
开发者就无須再费力编写枯燥而又容易出错的同步原语了**。

在这个简单示例中， 我们会将表示几何图形的一组类的实例发送给一个`actor`，该`actor`再将这组实例绘制到显示器上。
你可以想象这样一个场景：渲染工厂（`rendering farm`）在为动画生成场景。一旦场景渲染完毕，构成场景的几何图形便会
被发送给某一`actor`进行展示。

首先，我们将定义`Shape`类：
```scala
//src/main/scala/progscala2/introscala/shapes/Shapes.scala
package progscala2.introscala.shapes

case class Point(x: Double = 0.0, y: Double = 0.0)                                      //1

abstract class Shape() {                                                                //2
    /*
    * draw方法接受一个函数参数。每个图形对象都会将自己的字符格式传给函数f,
    * 由函数f执行绘制工作。
    */
    def draw(f: String => Unit): Unit = f(s"draw: ${this.toString}")                    //3
}

case class Circle(center: Point, radius: Double) extends Shape                          //4
case class Rectangle(lowerLeft: Point, height: Double, width: Double) extends Shape     //5
case class Triangle(point1: Point, point2: Point, point3: Point) extends Shape          //6
```
+ 注1：此处声明了一个表示二维点的类。
+ 注2：此处声明了一个表示几何形状的抽象类。
+ 注3：此处实现了一个“绘制”形状的`draw`方法，该方法中仅输出了一个格式化的字符串。
+ 注4：`Circle`类由圆心和半径组成。
+ 注5：位于左下角的点、高度和宽度这三个属性构成了矩形。为了简化问题，我们规定矩形的各条边分别与横坐标或纵坐标平行。
+ 注6：三角形由三个点所构成。



