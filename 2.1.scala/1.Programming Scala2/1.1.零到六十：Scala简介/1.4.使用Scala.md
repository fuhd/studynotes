使用Scala
============================================================
本书多数情况下会使用`Scala REPL`，因此我们在这儿再温习一遍 **运行`REPL`的三种方式**。
你可以 **不指定脚本或`main`参数直接输入`scala`命令**，也可以 **使用`SBT console`命令**，
还可以 **在那些流行的`IDE`中使用`worksheet`特性**。

在`scala>`提示符中输入下列两行：
```shell
scala> val book = "Programming Scala"
book: java.lang.String = Programming Scala

scala> println(book)
Programming Scala
```
第一行代码中的`val`关键字用于声明不变变量`book`。可变数据是错误之源，因此我推荐使用不变值。

请注意，解释器返回值列出了`book`变量的类型和数值。`Scala`从字面量"Programming Scala"中
推导出`book`属于`java.lang.String`类型。

**显示类型信息或在声明中显示指明类型信息时，这些类型标注紧随冒号，出现在相关项之后**。为什么`Scala`不遵循
`Java`的习惯呢？**`Scala`常常能推导出类型信息，因此，我们在代码中总是看不到显式的类型标注**。

仅使用`REPL`来编辑或提交大型的示例代码会比较枯燥，而使用文本编辑器或IDE来编写`Scala`脚本则会方便得多。
编写完成之后，你可以执行脚本，也可以复制粘贴大段代码再执行。我们再回顾一下之前编写的`upper1.sc`文件：
```scala
//src/main/scala/progscala2/introscala/upper1.sc
class Upper {
    def upper(Strings: String*): Seq[String] = {
        strings.map((s: String) => s.toUpperCase())
    }
}
val up = new Upper
println(up.upper("Hello", "World!"))
```
`Scala`遵循`Java`、`C#`、`C`等语言的注释规则，`// comment`只能作用到本行行尾，而`/* comment */`则可以跨行。

**依照命名规范，脚本文件的扩展名为`.sc`，而编译后的文件的扩展名为`.scala`，这一命名规范仅适用于本书。通常，
脚本文件往往也使用`.scala`扩展名。 不过如果使用`SBT`构建项目，`SBT`会尝试编译这些以`scala`命名的文件，
而这些脚本文件却无法编译（我们稍后会讲到这些）**。

我们首先运行该脚本，**启动`sbt`并执行`console`命令以开启`Scala`环境**。然后 **使用`:load`命令加载（编译并运行）文件**：
```shell
scala> :load src/main/scala/progscala2/introscala/upper1.sc
Loading src/main/scala/progscala2/introscala/upper1.sc...
defined class Upper
up: Upper = Upper@4fa6af05
ArrayBuffer(HELLO, WORLD!)
```
上述脚本中，只有最后一行才是`println`命令的输出，其他行则是`REPL`提供的一些反馈信息。

**那么这些脚本为什么无法编译呢？脚本设计的初衷是为了简化代码，无须将声明（变量和函数）封装在对象中便是一种简化**。
而将`Java`和`Scala`代码编译后，声明必须封装在对象中（这是`JVM`字节码的需求）。`scala`命令通过一个聪明的技巧解决了冲突：
**将脚本封装在一个你看不到的匿名对象中**。

**假如你的确希望能将脚本文件编译为`JVM`的字节码（一组`.class`文件），可以在`scalac`命令中传入`-Xscript <object>`参数，
`<object>`表示你所选中的`main`类，它是生成的`Java`应用程序的入口点**：
```shell
$ scalac -Xscript Upper1 src/main/scala/progscala2/introscala/upper1.sc
$ scala Upper1
ArrayBuffer(HELLO, WORLD!)
```
执行完毕后检查当前文件夹，**你会发现一些命名方式有趣的`.class`文件。（提示：一些匿名函数也被转换成了对象！）**
我们稍后会再讨论这些名字，`Upper1.class`文件中包含了主程序，我们将使用 **`javap`** 和 **`Scala`对应工具`scalap`**，
对该文件实施 **逆向工程**！
```shell
$ javap -cp . Upper1
```
```scala
Compiled from "upper1.sc"
public final class Upper1 {
  public static void main(java.lang.String[]);
}
```
```shell
$ scalap -cp . Upper1
```
```scala
object Upper1 extends scala.AnyRef {
  def this() = { /* compiled code */ }
  def main(args: scala.Array[scala.Predef.String]): scala.Unit = { /* compiled code */ }
}
```
`Upper`类中的`upper`方法将输入字符串转换成大写字符串，并返回一个包含这些字符串的`Seq`（`Seq`表示“序列”）对象。
最后两行代码创建了`Upper`对象的一个实例，并调用这一实例将字符串“Hello“和“World!”转换为大写字符串，
并最终打印出产生的`Seq`对象。

在`Scala`中定义类时需要输入 **`class`关键字**，整个类定义体包含在最外层的一对大括号中（**{...}**）。事实上，
**这个类定义体同样也是这个类的主构造函数。假如需要将参数传递给这个构造函数，就要在类名`Upper`之后输入参数列表**。

下面这小段代码声明了一个方法：
```scala
def upper(Strings: String*): Seq[String] = ...
```
**定义方法时需要先输入`def`关键字，之后输入方法名称以及可选的参数列表。再输入可选的返回类型（有时候，`Scala`能够推导
出返回类型），返回类型由冒号加类型表示。最后使用等于号（`=`）将方法签名和方法体分隔开**。

实际上，**圆括号中的参数列表代表了变长的`String`类型参数列表，修饰`strings`参数的`String`类型后面的`*`号指明了这一点**。
也就是说，你可以传递任意多的字符串（也可以传递空列表），而这些字符串由逗号分隔。在这个方法中，`strings`参数的类型
实际上是 **`WrappedArray`**，该类型对`Java`数组进行了封装。

参数列表后列出了该方法的返回类型`Seq[String]`，**`Seq`（代表`Sequence`）是集合的一种抽象，你可以依照固定的顺序**
（不同于遍历`Set`和`Map`对象那样的随机顺序和未定义顺序，遍历那类容器无法保证遍历顺序）遍历这类集合抽象。实际上，
该方法返回的类型是`scala.collection.mutable.ArrayBuffer`。

值得一提的是，**`Seq`是一个参数化类型，就好象`Java`中的泛型类型**。`Seq`代表着“某类事物的序列”，上面代码中的`Seq`表示
的是一个字符串序列。请注意，**`Scala`使用方括号（`{......}`）表示参数类型，而`Java`使用角括号（`<......>`）**。
```
注意：
Scala的标识符，如方法名和变量名中，允许出现尖括号，例如定义“小于”方法时，该方法常常被命名为<，这在scala语言中是允许的，
而java则不允许标识符中出现这样的字符。因此，为了避免出现岐义，Scala使用方括号而不是尖括号表示参数化类型，并且不允许标识
符中使用方括号。
```











