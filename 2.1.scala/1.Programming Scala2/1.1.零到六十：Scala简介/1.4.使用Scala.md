使用Scala
============================================================
本书多数情况下会使用`Scala REPL`，因此我们在这儿再温习一遍 **运行`REPL`的三种方式**。
你可以 **不指定脚本或`main`参数直接输入`scala`命令**，也可以 **使用`SBT console`命令**，
还可以 **在那些流行的`IDE`中使用`worksheet`特性**。

在`scala>`提示符中输入下列两行：
```shell
scala> val book = "Programming Scala"
book: java.lang.String = Programming Scala

scala> println(book)
Programming Scala
```
第一行代码中的`val`关键字用于声明不变变量`book`。可变数据是错误之源，因此我推荐使用不变值。

请注意，解释器返回值列出了`book`变量的类型和数值。`Scala`从字面量"Programming Scala"中
推导出`book`属于`java.lang.String`类型。

**显示类型信息或在声明中显示指明类型信息时，这些类型标注紧随冒号，出现在相关项之后**。为什么`Scala`不遵循
`Java`的习惯呢？**`Scala`常常能推导出类型信息，因此，我们在代码中总是看不到显式的类型标注**。

仅使用`REPL`来编辑或提交大型的示例代码会比较枯燥，而使用文本编辑器或IDE来编写`Scala`脚本则会方便得多。
编写完成之后，你可以执行脚本，也可以复制粘贴大段代码再执行。我们再回顾一下之前编写的`upper1.sc`文件：
```scala
//src/main/scala/progscala2/introscala/upper1.sc
class Upper {
    def upper(Strings: String*): Seq[String] = {
        strings.map((s: String) => s.toUpperCase())
    }
}
val up = new Upper
println(up.upper("Hello", "World!"))
```
`Scala`遵循`Java`、`C#`、`C`等语言的注释规则，`// comment`只能作用到本行行尾，而`/* comment */`则可以跨行。

**依照命名规范，脚本文件的扩展名为`.sc`，而编译后的文件的扩展名为`.scala`，这一命名规范仅适用于本书。通常，
脚本文件往往也使用`.scala`扩展名。 不过如果使用`SBT`构建项目，`SBT`会尝试编译这些以`scala`命名的文件，
而这些脚本文件却无法编译（我们稍后会讲到这些）**。

我们首先运行该脚本，**启动`sbt`并执行`console`命令以开启`Scala`环境**。然后 **使用`:load`命令加载（编译并运行）文件**：
```shell
scala> :load src/main/scala/progscala2/introscala/upper1.sc
Loading src/main/scala/progscala2/introscala/upper1.sc...
defined class Upper
up: Upper = Upper@4fa6af05
ArrayBuffer(HELLO, WORLD!)
```
上述脚本中，只有最后一行才是`println`命令的输出，其他行则是`REPL`提供的一些反馈信息。

**那么这些脚本为什么无法编译呢？脚本设计的初衷是为了简化代码，无须将声明（变量和函数）封装在对象中便是一种简化**。
而将`Java`和`Scala`代码编译后，声明必须封装在对象中（这是`JVM`字节码的需求）。`scala`命令通过一个聪明的技巧解决了冲突：
**将脚本封装在一个你看不到的匿名对象中**。





