偏函数
==============================================================
偏函数之所以“偏”，原因在于 **它们并不处理所有可能的输入，而只处理那些能与至少一个`case`语句匹配的输入**。

**在偏函数中只能使用`case`语句，而整个函数必须用花括号包围**。这与普通的函数字面量不同，普通函数字面量可以用
花括号，也可以用圆括号包围。

如果偏函数被调用，而函数的输入却与所有语句都不匹配，系统就会抛出一个 **`MatchError`运行时错误**。

我们 **可以用`isDefineAt`方法测试特定输入是否与偏函数匹配**，这样偏函数就可以避免抛出`MatchError`错误了。

**偏函数可以如此“链式”连接：pf1 orElse pf2 orElse pf3 ...**。如果`pf1`不匹配，就会尝试`pf2`，接着是`pf3`，
以此类推。如果以上偏函数都不匹配，才会抛出`MatchError`。

以下实例可以展示上述规则：
```scala
//src/main/scala/progscala2/typelessdomore/partial-functions.sc

val pf1: PartialFunction[Any, String] = {case s: String => "YES" }                   //1
val pf2: PartialFunction[Any, String] = {case d: Double => "YES" }                   //2

val pf = pf1 orElse pf2                                                              //3

def tryPF(x: Any, f: PartialFunction[Any, String]): String =                         //4
    try{f(x).toString } catch {case _: MatchError => "ERROR!"}
```
