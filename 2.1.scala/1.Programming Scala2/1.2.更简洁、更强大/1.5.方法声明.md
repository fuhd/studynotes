方法声明
===============================================================
本节我们会用到前文使用的`Shape`类的继承树来探讨方法的声明。

### 方法默认值和命名参数列表
以下是修改后的`Point` `case`类：
```scala
//src/main/scala/progscala2/typelessdomore/shapes/Shapes.scala
package progscala2.typelessdomore.shapes

case class Point(x: Double = 0.0, y: Double = 0.0) {                                            //1
    def shift(deltax: Double = 0.0, deltay: Double = 0.0) = copy(x + deltax, y + deltay )       //2
}
```
+ 1处：如同前文，定义`Point`类，并提供默认的初始化值。
+ 2处：新的`shift`方法，用于从现有的`Point`对象中对“点”进行平移，从而创建一个新的`Point`对象。它使用了`copy`方法，
**`copy`方法也是`case`类自动创建的**。

**`copy`方法允许你在创建`case`类的新实例时，只给出与原对象不同部分的参数，这一点对于大一些的`case`类非常有用**：
```scala
//显式使用命名参数列表
scala> val p1 = new Point(x = 3.3, y = 4.4)
p1: Point = Point(3.3,4.4)
//指定新的y值，创建新实例
scala> val p2 = p1.copy(y = 6.6)
p2: Point = Point(3.3,6.6)
```
**命名参数列表让客户端代码更具可读性。当参数列表很长，且有若干参数是同一类型时，`bug`容易避免，因为在这种情况下
很容易搞错参数传入的顺序**。当然，更好的做法是一开始就避免出现过长的参数列表。

### 方法具有多个参数列表
接下来，我们对`Shape`类进行修改，特别是其中的`draw`方法：
```scala
case class Point(x: Double = 0.0, y: Double = 0.0)

abstract class Shape() {
    def draw(offset: Point = Point(0.0, 0.0))(f: String => Unit): Unit =
        f(s"draw(offset = $offset), ${this.toString}")
}

case class Circle(center: Point, radius: Double) extends Shape

case class Rectangle(lowerLeft: Point, Height: Double, width: Double) extends Shape
```
没错，**这里的`draw`方法有两个参数列表，每个参数列表都有一个参数，而不是拥有一个具有两个参数的参数列**。
第一个参数列表允许你指定`Point`对象的偏移量，供绘制使用。默认值`Point(0.0, 0.0)`，表示没有偏移。
第二个参数列表与之前的`draw`函数相同，其中的参数是用来绘制所用的函数。

**你可以任意指定参数列表的个数，但实际上很少有人使用两个以上的参数列表**。

那么，**为什么要允许多个参数列表呢？当最后一个参数列表只包含一个表示函数的参数时，多个参数列表的形式拥有整齐
的块结构语法**。以下是我们调用新的`draw`方法的表达方式：
```scala
s.draw(Point(1.0, 2.0))(str => println(s"ShapesDrawingActor: $str"))
```
**`Scala`允许我们把参数列表两边的圆括号替换为花括号**，因此，这一行代码还可以写为：
```scala
s.draw(Point(1.0, 3.0)){str => println(s"ShapesDrawingActor: $str")}
```
**如果函数字面量不能在一行内完成，我们可以重写为以下方式**：
```scala
s.draw(Point(1.0, 3.0)){str =>
    println(s"ShapesDrawingActor: $str")
}
```
**或写为等价形式**：
```scala
s.draw(Point(1.0, 4.0)) {
    str => println(s"ShapesDrawingActor: $str")
}
```
**当函数字面量很长时，这种用`{...}`代替`(...)`的“语法糖”使得代码看起来美观多了。此时的代码更像我们所熟悉和喜爱的块结构语法**。

**如果我们使用缺省的偏移量，第一个圆括号也不能省略**：
```scala
s.draw() { str =>
    println(s"ShapesDrawingActor: $str")
}
```
如同`Java`方法一样，**`draw`方法也可以只使用一个带两个参数值的参数列表**。如果那样，客户端代码就会这样写：
```scala
//方法定义
def draw1(offset: Point = Point(0.0, 0.0), f: String => Unit): Unit =
    f(s"draw(offset = $offset), ${this.toString}")
//方法调用
s.draw1(Point(2.0, 3.0), str => println(s"ShapesDrawingActor: $str"))
```
**这份代码并没那么清晰和优雅。使用默认值开启`offset`也没那么便捷，因此我们不得不对参数进行命名**：
```scala
s.draw1(f = str => println(s"ShapesDrawingActor: $str"))
```
方法具有多参数列表的第二个优势是 **在之后的参数列表中进行类型推断**。如以下例子：
```scala
scala> def m1[A](a: A, f: A => String) = f(a)
m1: [A](a: A, f: A => String)String

scala> def m2[A](a: A)(f: A => String) = f(a)
m2: [A](a: A)(f: A => String)String

scala> m1(100, i => s"$i + $i")
<console>:13: error: missing parameter type
       m1(100, i => s"$i + $i")
               ^

scala> m2(100)(i => s"$i + $i")
res1: String = 100 + 100
```