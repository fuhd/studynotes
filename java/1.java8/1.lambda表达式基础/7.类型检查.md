类型检查
==========================
### 何为函数类型
**函数式接口的函数类型** 就是其 **唯一一个抽象方法的类型**，也就是其 **类型参数** ，再加上 **参数类型**，
**返回类型** 与 **抛出异常类型** 。

### 匹配函数类型
针对目标类型提供的函数式接口类型对lambda进行 **类型检查要求lambda表达式兼容于接口的函数类型** 。示例：
```java
UnaryOperator<Integer> b = x -> x.intValue();
```
可以编译通过，因为lambda表达式兼容于`UnaryOperator<Integer>`的函数类型。下面列出了保证兼容性的条件：
#### 参数数量
lambda与函数类型要有相同数量的参数。
#### 参数类型
如果lambda表达式的类型是 **显式** 定义的，那么其类型就要与函数类型的参数相匹配；如果lambda的类型
是 **隐式** 定义的，那么对于返回类型检查来说，其参数类型会被认为与函数类型的相同。
#### 返回类型
**如果函数类型返回`void`**，那么lambda体必须是一个 **语句表达式** （也就是说，表达式可以用作语句，就像方法调用或赋值一样），例如：
```java
(int i) -> i++;
```
注意这里语句表达式的值被丢弃了；此外，还可以使用没有返回值语句的块体。例如：
```java
(Thread t) -> {t.start();}
```
**如果函数类型具有`非void`的返回值**，那么lambda体就必须返回一个与赋值兼容的值。例如，下面这个lambda体返回
一个`int`值，它会被赋给`UnaryOperator`的函数类型的Integer结果。
```java
UnaryOperator<Integer> b = x -> x.intValue();
```
#### 抛出类型
lambda表达式可以抛出 **检查的异常**，前提是函数类型声明抛出了 **该异常或是其父类型异常** 。

这个条件可能会导致问题。例如，假设我们想要声明一个方法来集中处理File的无参数方法所实现的各种不同的I/O操作所造成的IOException。
首先要声明：
```java
<U> U executeFileOp(File f,Function<File,U> fileOp){........}
```
不过`Function`的函数类型并没有声明任何异常，因此下面这种调用：
```java
executeFileOp(f,File::delete);
```
无法编译通过。相反，我们需要一个自定义的函数式接口：
```java
@FunctionalInterface
interface IOFunction<T,R> {
  R apply(T t) throws IOException;
}
```
这样，我们就可以根据意愿声明`executeFileOp`了：
```java
<U> U executeFileOp(File f, IOFunction<File,U> fileOp) {
  try {
    return fileOp.apply(f);
  } catch (IOException e) {
    //centralized exception handling
  }
}
```
由于 **库函数式接口都没有声明任何异常** ，因此如果实现了用户定义的函数式接口，那么lambda只会将异常传递给
调用者，就像示例中演示的那样。与之相反，在后面 **流处理** 中，我们需要在lambda中采用迂回的方式处理检查的异常，
因为流处理操作的参数都是库函数式接口。简而言之，**在Java8 lambda中，检查异常的处理是一个问题** 。
