lambda与变量捕获
========================
示例：
```java
DoubleUnaryOnerator sqrt = x -> Math.sqrt(x);
```
像这种只通过 **参数** 和 **返回值** 与环境进行交互的lambda称为 **无状态或非捕获lambda**。与之相反，
**捕获lambda** 会访问 **外围对象的状态** 。**捕获** 是个技术术语，指的是保留住lambda对其环境的引用。
java中，捕获所提供的访问能力是有限制的；这种限制的中心原则就是 **捕获变量的值不能修改**（这点跟其它语言的闭包不一样！！）。
因此，虽然传统叫法是“**变量捕获**”，不过事实上称为“**值捕获**”更准确一些。

传统上，一般对于局部类，特别是匿名内部类来说，要想在内部类中访问外部方法中的 **局部变量** ，这些 **局部变量**
需要声明为 **final** 。

### 防止lambda修改局部变量的理由

+ **正确性**：在Java中，到目前为止 **局部变量** 都不会产生 **竞态条件** 与 **可见性** 问题，这是因为它们只能由
执行局部变量所在方法的线程访问到。不过我们可以 **将lambda从创建它的线程传递给其他线程** ，这样如果 **第2个线程中的lambda
可以修改局部变量，那么方才提到的竞态条件与可见性问题就会出现** 。此外，无论涉及多少个线程，**lambda的生命周期可能会大于对计算
它的方法的调用**。如果捕获的局部变量是可变的，那么其生命周期就得比创建它们的方法调用长。抛开其他后果不谈，
这种改变会引入 **与局部变量相关的内存泄漏问题** 。
+ **性能**：如果对变量的访问是同步保护的，那么允许多线程访问可变变量的程序的正确性就可以保证。不过这么做的代价
却不符合引入lambda的一个主要目标————将对不同参数的函数的计算分发到不同线程上这一策略。甚至从不同线程中读取可变
的局部变量的值都得引入同步或是使用`volatile`，从而避免读取到旧数据。

其实对`final`的限制很容易就能规避。例如，如果局部变量是个数组引用，变量是`final`的，不过数组内容还是可变的。
不过在 **并行执行** 时，你很可能无意间就造成了竞态条件。可以通过同步来防止竞态条件的出现，不过这么做会导致
竞争加剧并降低性能。总之，不要这么做！！！！！

### lambda对捕获字段的限制
看起来对字段名的捕获没有诸如`final`的限制（也就是说，可以不用声明为`final`），但其实际上与局部变量是一样的。
以`foo`字段为例，对字段`foo`的引用实际上是对`this.foo`的简写，其中的伪变量`this`担负着 **不可变的局部变量** 的角色。
