lambda与变量捕获
========================
示例：
```java
DoubleUnaryOnerator sqrt = x -> Math.sqrt(x);
```
像这种只通过 **参数** 和 **返回值** 与环境进行交互的lambda称为 **无状态或非捕获lambda**。与之相反，
**捕获lambda** 会访问 **外围对象的状态** 。**捕获** 是个技术术语，指的是保留住lambda对其环境的引用。
java中，捕获所提供的访问能力是有限制的；这种限制的中心原则就是 **捕获变量的值不能修改**（这点跟其它语言的闭包不一样！！）。
因此，虽然传统叫法是“**变量捕获**”，不过事实上称为“**值捕获**”更准确一些。

传统上，一般对于局部类，特别是匿名内部类来说，要想在内部类中访问外部方法中的 **局部变量** ，这些 **局部变量**
需要声明为 **final** 。

### 防止lambda修改局部变量的理由

+ 正确性：在Java中，到目前为止 **局部变量** 都不会产生 **竞态条件** 与 **可见性** 问题，这是因为它们只能由
执行局部变量所在方法的线程访问到。不过我们可以 **将lambda从创建它的线程传递给其他线程** ，这样如果 **第2个线程中的lambda
可以修改局部变量，那么方才提到的竞态条件与可见性问题就会出现** 。
