函数式接口
==========================
lambda表达式必须实现一个函数式接口。`java.util.function`包下的接口是官方提供的函数式接口。

### 函数式接口与函数类型
示例：
```java
//函数接口
public interface UnaryOperator<T> { T apply(T t); }
```
描述了如下函数：
```java
//函数类型，第1个T是参数，第2个T是返回类型，f是引用
f: T -> T
```
`f: T -> T`就是 **函数类型** 。函数类型是`lambda`必须匹配的，这包括通过装箱或拆箱，增大或缩小范围等手段实现的类型适配。

### java.util.function包
`java.util.function`包中有 **4种** 基本的函数式接口类型，总共衍生了 **40多** 种函数式接口类型。
这40多种类型都是通过 **3种不同路由的各种组合** 由这4个类型演化而来的。4种基本的函数式接口类型，如下表：

接口|参数类型|返回类型|示例
---|-------|-------|----
Consumer<T>|T|void|s -> System.out.print(s)
Predicate<T>|T|boolean|s -> s.isEmpty()
Supplier<T>|无|T|() -> new String()
Function<T,U>|T|U|s -> new Integer(s)

**注**：关于泛型叁数。`T`表示`type`，代表类型；`E`表示`element`，代表集合中的元素；`K`表示`key`，代表Map中的key；
`V`表示`value`，代表Map中的value；`T`不够用时，还会用到`U`或`S`，表示任意类型。`R`表示`Return`，代表返回类型。
#### 原生特化
这些接口使用原生类型替换掉类型参数。代码示例：
```java
interface LongFunction<R>{R apply(long value);}
interface ToIntFunction<T>{int applyAsInt(T value);}
interface LongToIntFunction{int applyAsInt(long value);}
```
#### Consumer，Predicate与Function的函数类型都接收单个参数，也有接收两个参数的相应接口
示例：
```java
interface BiConsumer<T,U>{void accept(T t,U u);}
interface BiFunction<T,U,R>{R apply(T t,U u);}
interface ToIntBiFunction<T,U>{int apply(T t,U u);}
```
#### Function的常见用法要求其参数与结果拥有相同的类型
示例：
```java
interface UnaryOperator<T> extends Function<T,T> {..................}
interface BinaryOperator<T> extends BiFunction<T,T,T> {.............}
interface IntBinaryOperator {int applyAsInt(int left,int right);}
```

### 自定义函数式接口
如果你的用例没有被`java.util.function`包下的函数式接口涵盖，那么你可以很轻松地声明自己的函数式接口，
不过最佳实践则是在可能的情况下使用库中的函数式接口。

自定义函数式接口，要使用`@FunctionalInterface`来注解自定义的函数式接口。这样编译器就可以 **检查接口只会声明
一个抽象方法** ，同时相应的`Javadoc`也会自动添加说明部分。
