方法与构造器引用
==========================
一般来说，**任何lambda表达式** 都可以看作 **声明在函数式接口中的单个抽象方法的实现**。不过，**当lambda
表达式只是调用现有类中的具名方法** 时，编写lambda的更好方式则是使用已有的名字。示例：
```java
//普通方式
pointList.forEach(s -> System.out.print(s));
//更好的方式
pointList.forEach(System.out::print)
```
这两个表示相同的含义，这种对现有类的具体方法的操作写法称为 **方法引用** 。

### 方法引用类型

名字|语法|相应的lambda表达式
----|---|-----------------
静态|RefType::staticMethod|(args) -> RefType.staticMethod(args)
绑定实例|expr::instMethod|(args) -> expr.instMethod(args)
未绑定实例|RefType::instMethod|(arg0,rest) -> arg0.instMethod(rest)
构造器|ClsName::new|(args) -> new ClsName(args)

#### 静态方法引用
静态方法引用的语法只需要 **类** 与 **静态方法名**，中间通过 **两个冒号** 分隔。
```java
//例
String::valueOf
//实例
Arrays.sort(integerArray,Integer::compareUnsigned)；
```

#### 实例方法引用（绑定或未绑定）
有 **两种** 方式可以引用 **实例方法** 。

+ 绑定实例方法引用

  ```java
  pointList.forEach(System.out::print);
  ```
  注意：`System.out`是一个对象。
+ 未绑定实例方法引用
  之所以起这个名字，是因为接收者是不确定的，方法引用的第一个参数被用作接收者。

  ```java
  Comparator personComp = Comparator.comparing(Person::getLastName);
  ```
  未绑定方法引用可以通过其语法识别出来：与静态方法引用一样，我们也使用格式`ReferenceType::Identifier`，
  不过这里的`Identifier`指的是实例方法而非静态方法。

#### 构造器引用
构造器引用的创建语法类似于方法引用，只不过使用 **关键字new** 替换方法名。
```java
//例1
ArrayList::new;
//例2
File::new;
```
与方法引用一样，对于 **重载构造器** 的选择是通过 **上下文** 的目标类型实现的。例如，在如下代码中，
`map`参数的目标类型是类型为`String -> File`的函数：为了与之匹配，编译器会选择带有单个`String`参数的File构造器：
```java
Stream<String> stringStream = Stream.of("a.txt","b.txt","c.txt");
Stream<File> fileStream = stringStream.map(File::new);
```
