使用lambda表达式
============================
**上下文提供了恰当的目标类型，就可以使用lambda表达式**。也就是说，上下文明确需要一个函数式接口类型。
例如，如下声明的目标类型：
```java
IntPredicate ip = i -> i > 0;
```
是`IntPredicate`，这是一个函数式接口，其函数类型兼容于lambda表达式`i -> i > 0`。

### 使用lambda表达式的六种情况
有6种上下文可以提供恰当的目标类型：
+ **方法或构建器参数**：在这种情况下，目标类型就是恰当的参数类型。
  ```java
  Comparator<Point> byDistance = comparing(p -> p.distance(0,0));
  ```
+ **变量声明与赋值**：在这种情况下，目标类型就是被赋值的类型。

  ```java
  Comparator<String> cc = (String s1,String s2) -> s1.compareToIgnoreCase(s2);
  ```
  数组初始化器与之类似，只不过其目标类型是数组组件的类型，示例：
  ```java
  IntBinaryOperator[] calculatorOps = new IntBinaryOperator[]{
    (x,y) -> x + y, (x,y) -> x - y, (x,y) -> x * y, (x,y) -> x / y
  };
  ```
  lambda数组应用范围有限。另外，**由于大多数函数式接口都是泛型的，因此泛型数组的创建是不允许的。**
+ **返回语句**：在这种情况下，目标类型是方法的返回类型。
  ```java
  Runnable returnDatePrinter(){
    return () -> System.out.print(new Date());
  }
  ```
+ **lambda表达式体**：在这种情况下，目标类型是lambda表达式体所期望的类型，它由外层目标类型推导而来。
  ```java
  Callable<Runnable> c = () -> () -> System.out.println("hi");
  ```
  这里的外层目标类型是`Callable<Runnable>`，其函数类型就是如下方法的类型：
  ```java
  Runnable call() throws Exception;
  ```
  因此，lambda体的目标类型就是`Runnable`的函数类型。
+ **三元条件表达式**：在这种情况下，两边的目标类型都由上下文提供。
  ```java
  Callable<Integer> c = flag ? (() -> 23) : (() -> 42);
  ```
+ **类型转换表达式**：它会显式提供目标类型。
  ```java
  Object s = (Supplier) () -> "hi";
  Object c = (Callable) () -> "hi";
  ```
  该例还表明字面上相同的lambda可能会有不同的类型；像下面这样尝试通过不同的类型重用lambda：
  ```java
  Callable c1 = (Callable) s;
  ```
