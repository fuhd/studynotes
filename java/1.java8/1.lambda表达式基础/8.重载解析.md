重载解析
============================
### lambda表达式的重载
我们先来看看在简单直接的情况下其工作方式是怎样的。示例：
```java
//A，定义
public static <T,U extends Comparable<U>> Comparator<T> comparing(Function<T,U> keyExtractor);
```
```java
//B，使用
Comparator<String> cs = Comparator.comparing(s -> s.length());
```
现在，lambda表达式可以与`Function<T,U>`的函数类型相匹配了：
```java
public U apply(T t);
```
既然传递给lambda的参数类型`T`已经确定为`String`，那么`String.length`的返回类型`int`（会被装箱为`Integer`）
就可以替代`U`了。

到目前为止一切都好。但是假设`Comparator`声明了`comparing`的另一个重载：
```java
//C，定义
public static <T> Comparator<T> comparing(ToIntFunction<T> keyExtractor);
```
lambda接受一个参数并返回一个值，并且 **与两个候选的函数式接口的函数类型相匹配** 。这样，整个流程就卡住了，编译器会报错，
给出的消息是“reference to comparing is ambiguous”。

**那么我们该如何避免这种情况发生呢？** 如果lambda的参数类型是已知的，那么编译器就可以根据该信息来检查两个候选的函数类型。
由于参数类型是`String`，因此编译会发现它们都与lambda兼容。接下来，编译器根据哪一个会返回最具体的结果来从这两个候选者当
中进行选择：`ToIntFunction`返回一个`int`，`Function<String,Integer>`返回一个`Integer`，前者与`String.length`的返回类型
更为接近。因此，下面的调用：
```java
Comparator<String> cs = Comparator.comparing((String s) -> s.length());
```
可以编译通过，并被解析为 **C处** 的定义。

**Java8的设计者们不希望强迫用户像这样提供显式的lambda类型，因此它们使用新方法`comparingInt`，
`comparingLong`，`comparingDouble`来替换接受`ToIntFunction`，`ToLongFunction`，
`ToDoubleFunction`为参数的`comparing`的重载方法。**

### 方法引用的重载
举一个不精确的构造器引用的示例，`Exception::new`可以指向如下两个`Exception`构造器：
```java
//例1
public Excetpion()
//例2
public Exception(String message)
```
第1个匹配`Supplier<Exception>`的函数类型，第2个匹配`Function<String,Exception>`的函数类型。
如果声明如下方法重载：
```java
//例1
<T> void foo(Supplier<T> factory)
//例2
<T,U> void foo(Function<T,U> transformer)
```
那么调用：
```java
foo(Exception::new)
```
将会出现编译错误，错误消息是“reference to foo is smbiguous”。不过，虽然我们无法像显式指定lambda类型
那样让构造器引用更加精确，但还是有解决办法的：由于foo是泛型的，因此我们可以提供 **类型见证者** 来指定想要实例化的类型。
该语法要求显式指定接收者：
```java
this.<Exception>foo(Exception::new);
this.<String,Exception>foo(Exception::new);
```
当然，这么做只能解决具有不同数量的类型参数的泛型方法。假设我们想要调用如下两个重载方法之一：
```java
//例1
void bar(IntFunction<String> f);
//例2
void bar(DoubleFunction<String> f);
```
这样的情况，我们只需要 **进行强制类型转换** 即可解决问题：
```java
//例1
bar((IntFunction<String>) String::valueOf);
//例2
bar((DoubleFunction<String>) String::valueOf);
```
虽然这种情况可能会出现，但并不常见。如果真的出现了，那么请记住你总是可以使用相应的lambda表达式：
```java
//例1
bar((double i) -> String.valueOf(i));
//例2
bar((int i) -> String.valueOf(i));
```
