重载解析
============================
### lambda表达式的重载
我们先来看看在简单直接的情况下其工作方式是怎样的。示例：
```java
//A，定义
public static <T,U extends Comparable<U>> Comparator<T> comparing(Function<T,U> keyExtractor);
```
```java
//B，使用
Comparator<String> cs = Comparator.comparing(s -> s.length());
```
现在，lambda表达式可以与`Function<T,U>`的函数类型相匹配了：
```java
public U apply(T t);
```
既然传递给lambda的参数类型`T`已经确定为`String`，那么`String.length`的返回类型`int`（会被装箱为`Integer`）
就可以替代`U`了。

到目前为止一切都好。但是假设`Comparator`声明了`comparing`的另一个重载：
```java
//C，定义
public static <T> Comparator<T> comparing(ToIntFunction<T> keyExtractor);
```
lambda接受一个参数并返回一个值，并且 **与两个候选的函数式接口的函数类型相匹配** 。这样，整个流程就卡住了，编译器会报错，
给出的消息是“reference to comparing is ambiguous”。
