重载解析
============================
### lambda表达式的重载
我们先来看看在简单直接的情况下其工作方式是怎样的。示例：
```java
//A，定义
public static <T,U extends Comparable<U>> Comparator<T> comparing(Function<T,U> keyExtractor);
```
```java
//B，使用
Comparator<String> cs = Comparator.comparing(s -> s.length());
```
现在，lambda表达式可以与`Function<T,U>`的函数类型相匹配了：
```java
public U apply(T t);
```
既然传递给lambda的参数类型`T`已经确定为`String`，那么`String.length`的返回类型`int`（会被装箱为`Integer`）
就可以替代`U`了。

到目前为止一切都好。但是假设`Comparator`声明了`comparing`的另一个重载：
```java
//C，定义
public static <T> Comparator<T> comparing(ToIntFunction<T> keyExtractor);
```
lambda接受一个参数并返回一个值，并且 **与两个候选的函数式接口的函数类型相匹配** 。这样，整个流程就卡住了，编译器会报错，
给出的消息是“reference to comparing is ambiguous”。

**那么我们该如何避免这种情况发生呢？** 如果lambda的参数类型是已知的，那么编译器就可以根据该信息来检查两个候选的函数类型。
由于参数类型是`String`，因此编译会发现它们都与lambda兼容。接下来，编译器根据哪一个会返回最具体的结果来从这两个候选者当
中进行选择：`ToIntFunction`返回一个`int`，`Function<String,Integer>`返回一个`Integer`，前者与`String.length`的返回类型
更为接近。因此，下面的调用：
```java
Comparator<String> cs = Comparator.comparing((String s) -> s.length());
```
可以编译通过，并被解析为 **C处** 的定义。

**Java8的设计者们不希望强迫用户像这样提供显式的lambda类型，因此它们使用新方法`comparingInt`，'comparingLong'，
‘comparingDouble’来替换接受`ToIntFunction`，`ToLongFunction`，`ToDoubleFunction`为参数的`comparing`的重载方法。**
