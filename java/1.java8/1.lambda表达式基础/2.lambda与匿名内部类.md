lambda与匿名内部类
=========================
事实上，lambda表达式有时被错误地称为匿名内部类的“语法糖”。实际上，两者之间存在一些显著差异：

+ 内部类创建表达式会确保创建一个拥有唯一标识的新对象，而lambda表达式可能有，也可能没有唯一标识。
+ 内部类的声明会创建出一个新的命名作用域，在这个作用域中，`this`和`super`指的是内部类本身的当前实例；
相反，lambda表达式并不会引入任何新的命名环境，也就是说不会有新的命名作用域。

### lambda的作用域规则
就像大多数内部类一样，匿名内部类的作用域规则非常复杂，这是因为它可以引用从父类型继承下来的名字，
以及声明在外部类中的名字。lambda表达式则要简单很多，因为它们并不会从父类型中继承名字。**除了参数以外，
用在lambda表达式体中的名字的含义与体外面是一样的**，下面的示例是非法的：
```java
//错误，在foo方法体内，重复声明了两次局部变量i
void foo(){
  final int i = 2;
  Runnable r = () -> {int i = 3;}
}
```
