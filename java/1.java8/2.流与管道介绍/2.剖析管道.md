剖析管道
================================
### 开始管道
**流的真正威力** 是通过 **创建并组合起来的管道** 得以实现的。管道的几个阶段是：**它源自流的源，随后通过中间
操作进行一系列的转换，最后在终止操作中停止** 。

到目前为止，我们给出的流处理示例中的数据都来自于集合。事实上，**流处理模型可以应用于各种数据块**，基于这一优势，
平台库中的很多能够生成数据块的类现在都可以创建提供数据的流。目前，我们重点是 **关注流的工作方式** ，后面会详细介绍平台
库中完整的流创建方法的列表。这里我们只需要使用 **`Collection`的流方法** 以及 **流接口中的工厂方法** ：

+ `java.util.Collection<T>`： 该接口中的默认方法也许是最常使用的生成流的方式。
```java
Stream<T> stream()
Stream<T> parallelStream()
```
`parallelStream`表示其返回的是一个 **“可能的并行Stream”** （注：并非每个集合都会提供这个功能）。

+ `java.util.stream.Stream<T>`：该接口公开了大量的静态工厂方法，并且带有默认实现。这里我们只举例几个。
```java
Stream<T> empty()
Stream<T> of(T)
Stream<T> of(T...)
```
这些方法足以让我们能够开始探索流与管道的特性了。

### 转换管道
流创建后，管道的下一阶段包含了大量的中间操作（也可能什么操作都没有）。**中间操作是延迟进行的：它们只会在终止
管道操作出现时才计算其所需要的值** 。

转换管道的讲解从下面这个示例开始，以`Book`为对象建模一个图书馆，借此来探索`Stream API`：
```java
//------------------流处理的示例-------------------
//只包含计算过的图书的流，libray就是List<Book>
Stream<Book> computingBooks = library.stream().filter(b -> b.getTopic() == COMPUTING);
//图书标题的流
Stream<String> bookTitles = library.stream().map(Book::getTitle);
//Book的流，根据标题排序
Stream<Book> booksSortedByTitle = library.stream().sorted(Comparator.comparing(Book::getTitle));
//使用这个排序流创建一个作者流，根据图书标题排序，并且去除重复的
Stream<String> authorsInBookTitleOrder = library.stream()
  .sorted(Comparator.comparing(Book::getTitle))
  .flatMap(book -> book.getAuthors().stream())
  .distinct();
//以标题的字母顺序生成前100个图书的流
Stream<Book> readingList = library.stream().sorted(Comparator.comparing(Book::getTitle)).limit(100);
//除去前100个图片的流
Stream<Book> remainderList = library.stream().sorted(Comparator.comparing(Book::getTitle)).skip(100);
//图书馆中最早出版的图书
Optional<Book> oldest = library.stream().min(Comparator.comparing(Book::getPubDate));
//图书馆中图书的标题集合
Set<String> titles = libray.stream().map(Book::getTitle).collect(Collectors.toSet());
```
#### 过滤
方法`filter`可以有选择地处理流元素：
```java
Stream<T> filter(Predicate<T>)
```
其输出是输入流中 **满足** 提供的`Predicate`的那些元素。如：
```java
Stream<Book> computingBooks = library.stream().filter(b -> b.getTopic() == COMPUTING);
```
#### 映射
方法`map`会通过提供的`Function<T,R>` **转换每个流元素** ：
```java
Stream<R> map(Function<T,R>)
```
其输出是一个流，包含了对输入流中每个元素应用了`Function`后的结果。示例，可以通过它创建出版日期的Stream：
```java
Stream<Year> bookTitles = library.stream().map(Book::getPubDate);
```
方法`mapToInt`，`mapToLong`与`mapToDouble`对应于`map`。它们会通过`ToIntFunction<T>`，`ToLongFunction<T>`与
`ToDoubleFunction<T>`的实例 **将引用类型流转换为原生流**，每个转换都会接收一个T并返回一个原生值。
```java
IntStream mapToInt(ToIntFunction<T>)
LongStream mapToLong(ToLongFunction<T>)
DoubleStream mapToDouble(ToDoubleFunction<T>)
```
我们之前曾看到过这些方法可用于拆箱一系列包装值。

另一个例子，我们可以计算出图书馆中所有图书的作者总数：
```java
int totalAuthorships = libray.stream().mapToInt(b -> b.getAuthors().size()).sum();
```
按照这种方式转换为原生流可以 **充分利用其更好的性能** 以及专门的 **数学终止操作** ，例如：`sum`。
