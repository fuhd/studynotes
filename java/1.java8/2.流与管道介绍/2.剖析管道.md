剖析管道
================================
### 开始管道
**流的真正威力** 是通过 **创建并组合起来的管道** 得以实现的。管道的几个阶段是：**它源自流的源，随后通过中间
操作进行一系列的转换，最后在终止操作中停止** 。

到目前为止，我们给出的流处理示例中的数据都来自于集合。事实上，**流处理模型可以应用于各种数据块**，基于这一优势，
平台库中的很多能够生成数据块的类现在都可以创建提供数据的流。目前，我们重点是 **关注流的工作方式** ，后面会详细介绍平台
库中完整的流创建方法的列表。这里我们只需要使用 **`Collection`的流方法** 以及 **流接口中的工厂方法** ：

+ `java.util.Collection<T>`： 该接口中的默认方法也许是最常使用的生成流的方式。
```java
Stream<T> stream()
Stream<T> parallelStream()
```
`parallelStream`表示其返回的是一个 **“可能的并行Stream”** （注：并非每个集合都会提供这个功能）。

+ `java.util.stream.Stream<T>`：该接口公开了大量的静态工厂方法，并且带有默认实现。这里我们只举例几个。
```java
Stream<T> empty()
Stream<T> of(T)
Stream<T> of(T...)
```
这些方法足以让我们能够开始探索流与管道的特性了。

### 转换管道
流创建后，管道的下一阶段包含了大量的中间操作（也可能什么操作都没有）。**中间操作是延迟进行的：它们只会在终止
管道操作出现时才计算其所需要的值** 。

转换管道的讲解从下面这个示例开始，以`Book`为对象建模一个图书馆，借此来探索`Stream API`：
```java
//------------------流处理的示例-------------------
//只包含计算过的图书的流，libray就是List<Book>
Stream<Book> computingBooks = library.stream().filter(b -> b.getTopic() == COMPUTING);
//图书标题的流
Stream<String> bookTitles = library.stream().map(Book::getTitle);
//Book的流，根据标题排序
Stream<Book> booksSortedByTitle = library.stream().sorted(Comparator.comparing(Book::getTitle));
//使用这个排序流创建一个作者流，根据图书标题排序，并且去除重复的
Stream<String> authorsInBookTitleOrder = library.stream()
  .sorted(Comparator.comparing(Book::getTitle))
  .flatMap(book -> book.getAuthors().stream())
  .distinct();
//以标题的字母顺序生成前100个图书的流
Stream<Book> readingList = library.stream().sorted(Comparator.comparing(Book::getTitle)).limit(100);
//除去前100个图片的流
Stream<Book> remainderList = library.stream().sorted(Comparator.comparing(Book::getTitle)).skip(100);
//图书馆中最早出版的图书
Optional<Book> oldest = library.stream().min(Comparator.comparing(Book::getPubDate));
//图书馆中图书的标题集合
Set<String> titles = libray.stream().map(Book::getTitle).collect(Collectors.toSet());
```
#### 过滤
方法`filter`可以有选择地处理流元素：
```java
Stream<T> filter(Predicate<T>)
```
其输出是输入流中 **满足** 提供的`Predicate`的那些元素。如：
```java
Stream<Book> computingBooks = library.stream().filter(b -> b.getTopic() == COMPUTING);
```
#### 映射
方法`map`会通过提供的`Function<T,R>` **转换每个流元素** ：
```java
Stream<R> map(Function<T,R>)
```
其输出是一个流，包含了对输入流中每个元素应用了`Function`后的结果。示例，可以通过它创建出版日期的Stream：
```java
Stream<Year> bookTitles = library.stream().map(Book::getPubDate);
```
方法`mapToInt`，`mapToLong`与`mapToDouble`对应于`map`。它们会通过`ToIntFunction<T>`，`ToLongFunction<T>`与
`ToDoubleFunction<T>`的实例 **将引用类型流转换为原生流**，每个转换都会接收一个T并返回一个原生值。
```java
IntStream mapToInt(ToIntFunction<T>)
LongStream mapToLong(ToLongFunction<T>)
DoubleStream mapToDouble(ToDoubleFunction<T>)
```
我们之前曾看到过这些方法可用于拆箱一系列包装值。

另一个例子，我们可以计算出图书馆中所有图书的作者总数：
```java
int totalAuthorships = libray.stream().mapToInt(b -> b.getAuthors().size()).sum();
```
按照这种方式转换为原生流可以 **充分利用其更好的性能** 以及专门的 **数学终止操作** ，例如：`sum`。

Stream API支持这 **4种** Stream类型之间的 **相互转换** 。这样，除了这里介绍的Stream方法外，每个原生流都有3个转换`map`
操作，用于转换为其他3种类型。例如，除了`map`之外，`IntStream`还有转换操作`mapToLong`，`mapToDouble`以及
`mapToObj`。
#### 一对多映射
要获取图书馆中所有图书的所有作者，注意每本书都可能有好几个作者，那我们应该如何做到呢？该问题需要将单个Book转换为输出流
中的几个作者（Author）元素。我们需要操作会将 **每个Book映射为一个Author的流** ，即：`book.getAuthors().stream()`，
然后 **将生成的一系列流压平为针对所有图书的单个Author的流** ，这就是操作 **flatMap** ：
```java
Stream<R> flatMap(Function<T,Stream<R>>)
```
示例代码：
```java
Stream<String> authorStream = library.stream().flatMap(b -> b.getAuthors().stream());
```
类似于与`map`对应的用于转换为原生流的方法，`flatMap`也存在着原生转换方法：`flatMapToInt`，`flatMapToLong`，
`flatMapToDouble`。例如，我们可以获得所有图书的总页数，方式是通过`IntStream.of`为每个Book创建一个单独的`IntStream`，
然后通过`flatMapToInt`将它们连接起来：
```java
int totalPageCount = library.stream().flatMapToInt(b -> IntStream.of(b.getPageCounts())).sum();
```
**原生流类型只有`flatMap`，它们并没有用于类型转换的压平操作** 。
#### 调试
调用管道的终止操作会导致其中间操作得到执行。这样，通常的 **单步调试技术** 就不适用于流了。Stream API提供的另外一个操作`peek`
与其他中间操作不同，**其输出流会包含相同的元素，并且与输入流的顺序相同** 。`peek`的目的旨在 **对处于管道中间位置的流元素执行处理** 。
例如，我们打印每本书的标题：
```java
List<Book> multipleAuthoredHistories = library.stream()
  .filter(b -> b.getTopic() == Book.Topic.HISTORY)
  .peek(b -> System.out.println(b.getTitle()))
  .filter(b -> b.getAuthors().size() > 1)
  .collect(toList());
```
`peek`方法可以接收任何类型适当的`Consumer`作为参数，该方法用于 **对调试提供支持**，由于其有 **副作用**，
因此 **不应该用于其他任何目的** 。
#### 排序与去重复
```java
Stream<T> sorted()
Stream<T> sorted(Comparator<T>)
Stream<T> distinct()
```
第1个`sorted`重载方法会使用 **自然顺序** 对对象进行排序。例如，我们可以使用它创建一个Book标题的流，并且按照字母顺序排序：
```java
Stream<String> sortedTitles = library.stream().map(Book::getTitle).sorted();
```
第2个重载的`sorted`会接受一个`Comparator`。例如，静态方法`Comparator.comparing`会根据一个键抽取器创建一个`Comparator`：
```java
Stream<Book> booksSortedByTitle = library.stream().sorted(Comparator.comparing(Book::getTitle));
```
通过从一个键创建一个`Comparator`，它提供了一种另外的排序方式。重载的`Comparator.comparing`接受一个针对抽取键的
`Comparator`，这样就可以对其使用不同的排序规则了。另一个示例，为了根据作者数量对图书进行排序，可以写成下面这样：
```java
Stream<Book> booksSortedByAuthorCount = library.stream()
  .sorted(Comparator.comparing(Book::getAuthors,Comparator.comparing(List::size)));
```
