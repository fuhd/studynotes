剖析管道
================================
### 开始管道
**流的真正威力** 是通过 **创建并组合起来的管道** 得以实现的。管道的几个阶段是：**它源自流的源，随后通过中间
操作进行一系列的转换，最后在终止操作中停止** 。

到目前为止，我们给出的流处理示例中的数据都来自于集合。事实上，**流处理模型可以应用于各种数据块**，基于这一优势，
平台库中的很多能够生成数据块的类现在都可以创建提供数据的流。目前，我们重点是 **关注流的工作方式** ，后面会详细介绍平台
库中完整的流创建方法的列表。这里我们只需要使用 **`Collection`的流方法** 以及 **流接口中的工厂方法** ：

+ `java.util.Collection<T>`： 该接口中的默认方法也许是最常使用的生成流的方式。
```java
Stream<T> stream()
Stream<T> parallelStream()
```
`parallelStream`表示其返回的是一个 **“可能的并行Stream”** （注：并非每个集合都会提供这个功能）。

+ `java.util.stream.Stream<T>`：该接口公开了大量的静态工厂方法，并且带有默认实现。这里我们只举例几个。
```java
Stream<T> empty()
Stream<T> of(T)
Stream<T> of(T...)
```
这些方法足以让我们能够开始探索流与管道的特性了。

### 转换管道
流创建后，管道的下一阶段包含了大量的中间操作（也可能什么操作都没有）。**中间操作是延迟进行的：它们只会在终止
管道操作出现时才计算其所需要的值** 。

转换管道的讲解从下面这个示例开始，以`Book`为对象建模一个图书馆，借此来探索`Stream API`：
```java
//------------------流处理的示例-------------------
//只包含计算过的图书的流，libray就是List<Book>
Stream<Book> computingBooks = library.stream().filter(b -> b.getTopic() == COMPUTING);
```
