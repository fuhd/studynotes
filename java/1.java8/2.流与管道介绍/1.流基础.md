流基础
=====================
因为 **流不存储值：流的目的是处理值**。例如，考虑一个将集合作为源的流：创建流并不会导致数据流动，
当终止操作需要值时，流会从集合中获取值将其提供；最后，当所有集合值都被流提供后，流就被耗尽了，并且无法再
次使用。**流背后的中心思想是延迟计算：直到需要时才计算值** 。

从概念上来说，**流** 与 **迭代器** 非常类似，不过流具有一些重要的改进：

+ 流以一种对客户端更加友好的方式处理 **无元素** 的情况。
+ 迭代器总是以确定的顺序来处理值，与之不同，**流可以是无序的** 。
+ 流具有方法（中间操作），这些方法会接受行为性参数（对流的转换），然后返回转换后的流。这样就可以将流链接
到管道中。这不仅可以提供流式编程，还能在极大程度上提升性能。
+ 流会保留关于源的属性的信息，例如源值是否是有序的，总数是否是已知的，这样就可以对值处理进行优化，而迭代
器则是做不到这一点的，除了值本身外，迭代器并不保留任何其他信息。

延迟计算的一个重要优势可以通过`Stream`的“搜索”方法一探究竟：`findFirst`，`findAny`，`anyMatch`，
`allMatch`与`noneMatch`。它们都称为 **短路** 操作符，因为使用了这些方法就没必要处理流中的所有元素了。
例如，`anyMatch`需要找到一个满足其谓词（boolean值函数），让流处理完成的单个流元素，`allMatch`则需要
找到一个不满足其谓词的流元素。这无须生成和处理不必要的元素，能够极大地降低工作量，对于无限流来说，我们只需
要将 **延迟计算** 与 **短路操作符** 组合起来就可以完成流的处理。

延迟计算还提供了另外一个好处：可以 **将多个逻辑运算合并到一起并统一应用到数据上** 。示例：
```java
OptionalDouble maxDistance = IntList.parallelStream()
  .map(i -> new Point(i % 3, i / 3))
  .mapToDouble(p -> p.distance(0,0))
  .max();
```
这种流式风格自然又易读，不过要想理解它则需要考虑到 **隐匿的延迟计算** 。出于演示的目的，如果将管道拆分为
**流声明** 与 **终止操作调用** ，那就更容易看清楚这一点了：
```java
//流声明
DoubleStream ds = IntList.parallelStream()
  .map(i -> new Point(i % 3, i / 3))
  .mapToDouble(p -> p.distance(0,0));
//终止操作调用
OptionalDouble maxDistance = ds.max();
```

### 面向并行的代码
java中，虽然 **顺序处理** 依然是个非常重要的计算模型，不过它不再是唯一一个参考模型（java8提供了 **并行处理** ）。
无论是串行还是并行，代码的运行结果与如何执行没有关系，那么我们就需要重新思考计算模型了（尝试用并行处理）。

一般来说，一个操作在两种模式下并不一定会产生出完全相同的结果：例如，`forEach`就可以在不确定的顺序下执行。**`forEach`
与其他非确定性操作在串行与并行模式下的顺序都是不确定的** 。与之相反，在这两种模式下顺序确定的操作则会保证以确定的顺序执行。
之所以会提供`forEach`之类的非确定性操作，**原因在于不必要的确定性是有着很高的性能代价的** 。如果选择相应的确定性版本
（例如：`forEachOrdered`），那就要清楚地认识到顺序是问题之所需，而非仅仅是随意的选择。

**关键是思维上的转变，我们再来整理一下：** 迭代的程序包含了两类信息，**要做什么**，以及 **如何做**。
将这两个概念解耦就得到一种开发模型，我们编写面向 **并行** 的代码，只需要指定 **函数式行为** 即可，然后再单独指定其 **执行模式** 。
在理想的情况下，会将执行的实现委托给库来做。
