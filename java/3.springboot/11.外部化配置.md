外部化配置
=====================
Spring Boot允许外部化你的配置，这样你能够在不同的环境下使用相同的代码。你可以使用 **properties** 文件，
**YAML** 文件，**环境变量** 和 **命令行参数** 来外部化配置。使用 `@Value`注解，可以直接将属性值注入
到你的beans中。

Spring Boot使用一个非常特别的`PropertySource`次序来允许对值进行合理的覆盖，需要以下面的次序考虑属性：

1. 命令行参数
2. 来自于`java:comp/env`的JNDI属性
3. Java系统属性（`System.getProperties`）
4. 操作系统环境变量
5. 只有在`random.*`里包含的属性会产生一个`RandomValuePropertySource`
6. 在打包的jar外的应用程序配置文件（`application.properties`，包含YAML和profile变量）
7. 在打包的jar内的应用程序配置文件（`application.properties`，包含YAML和profile变量）
8. 在`@Configuration`类上的`@PropertySource`注解。
9. 默认属性（使用`SpringApplication.setDefaultProperties`指定）

示例：
```java
import org.springframework.stereotype.*
import org.springframework.beans.factory.annotation.*

@Component
public class MyBean {
  @Value("${name}")
  private String name;
    //...
}
```
你可以将一个`application.properties`文件捆绑到jar内，用来提供一个合理的默认name属性值。
当运行在生产环境时，可以在jar外提供一个`application.properties`文件来覆盖name属性。

### 访问命令行属性
默认情况下，`SpringApplication`将任何可选的命令行参数（以'--'开头，比如，`--server.port=9000`）
转化为property，并将其添加到Spring Environment中。**命令行属性总是优先于其他属性源** 。

### application属性文件
`SpringApplication`将从以下位置加载`application.properties`文件，并把它们添加到Spring Environment中：

1. 当前目录下的一个`/config`子目录。
2. 当前目录。
3. 一个`classpath`下的`/config`包。
4. `classpath`根路径（root）。

这个列表是按 **优先级** 排序的（列表中位置靠前的将覆盖位置靠后的）。注：你可以使用YAML（.yml）文件
替代`properties`。

### 使用YAML代替properties
YAML是JSON的一个超集，也是一种方便的定义层次配置数据的格式。无论你何时将`SnakeYAML`库放到`classpath`下，
SpringApplication类都会自动支持YAML作为properties的替换。**注：** 使用`spring-boot-starter`会自动
提供`SnakeYAML`。
#### 加载YAML
Spring框架提供两个便利的类用于加载YAML文档，`YamlPropertiesFactoryBean`会将YAML作为properties来加载，
`YamlMapFactoryBean`会将YAML作为Map来加载。示例：
```yml
environments:
  dev:
    url: http://dev.bar.com
    name: Developer	Setup
  prod:
    url: http://foo.bar.com
    name: My Cool App
```
上面的YAML文档会被转化到下面的属性中：
```
environments.dev.url=http://dev.bar.com
environments.dev.name=Developer Setup
environments.prod.url=http://foo.bar.com
environments.prod.name=My Cool App
```
YAML列表被表示成使用`[index]`间接引用作为属性keys的形式，例如下面的YAML：
```yml
my:
  servers:
    - dev.bar.com
    - foo.bar.com
```
将会转化到下面的属性中：
```
my.servers[0]=dev.bar.com
my.servers[1]=foo.bar.com
```
使用Spring DataBinder工具绑定上面那样的属性（这是`@ConfigurationProperties`做的事）。
你需要确定目标bean中有个`java.util.List`或`java.util.Set`类型的属性，并且需要提供一个setter或
使用可变的值初始化它。示例如下：
```java
@ConfigurationProperties(prefix="my")
public class Config{
  private List<String> servers = new ArrayList<String>();
  public List<String> getServers() {
    return this.servers;
  }
}
```
#### 在Spring环境中使用YAML暴露属性
`YamlPropertySourceLoader`类能够用于将YAML作为一个`PropertySource`导出到Spring Environment。
这允许你使用熟悉的 **`@Value`注解** 和 **占位符语法** 访问YAML属性。
#### Multi-profile YAML文档
你可以在单个文件中定义多个特定配置的YAML文档，并通过一个`spring.profiles key`标示应用的文档。示例：
```yml
server:
  address: 192.168.1.100
---
spring:
  profiles: development
server:
  address: 127.0.0.1
---
spring:
  profiles: production
server:
  address: 192.168.1.120
```
上面的例子中，如果`development`配置被激活，那`server.address`属性将是127.0.0.1。如果`development`和
`production`配置（profiles）没有启用，则该属性值将是192.168.1.100。
