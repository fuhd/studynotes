错误处理
======================
Spring Boot默认提供一个`/error`映射用来以合适的方式处理所有的错误，并且它在servlet容器中注册了一个全局的错误页面。
对于机器客户端（相对于浏览器而言），它会产生一个具有详细错误，HTTP状态，异常信息的JSON响应。对于浏览器客户端，
它会产生一个白色标签样式（whitelabel）的错误视图， 该视图将以HTML格式显示同样的数据。为了完全替换默认的行为， 你可以实现`ErrorController`，并注册一个该类型的bean定义，或简单地添加一个`ErrorAttributes`类型的bean以使用现存的机制， 只是替换显示的内容。

### ErrorController
实现`ErrorController`的示例：
```java
@Controller
public class ErrorHandleController implements ErrorController{
  @Override
  public String getErrorPath() {
    return "/screen/error";
  }
  @RequestMapping
  public String errorHandle(){
    return getErrorPath();
  }
}
```
### 多错误页面处理
如果在某些条件下需要比较多的错误页面，内嵌的servlet容器提供了一个统一的Java DSL（领域特定语言）来自定义错误处理。
示例：
```java
@Bean
public EmbeddedServletContainerCustomizer containerCustomizer(){
  return new MyCustomizer();
}
// ...
private static class MyCustomizer implements EmbeddedServletContainerCustomizer {
  @Override
  public void customize(ConfigurableEmbeddedServletContainer container) {
    container.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
  }
}
```
### @ExceptionHandler
返回JSON错误数据的示例：
```java
@Controller
public class AccessController {
  @ExceptionHandler(RuntimeException.class) //参数不是必須的，我们是不是可以根据异常类型来确定返回view还是json???
  @ResponseBody
  public Map<String,Object> runtimeExceptionHandler(RuntimeException runtimeException) {
    logger.error(runtimeException.getLocalizedMessage());
    Map model = new TreeMap();
    model.put("status", false);
    return model;
  }
}
```
### @ControllerAdvice
