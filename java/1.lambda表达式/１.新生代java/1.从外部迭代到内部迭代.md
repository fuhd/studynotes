从外部迭代到内部迭代
=========================
### 外部迭代
示例：
```java
List<Point> pointList = Arrays.asList(new Point(1,2),new Point(2,3));
for(Interator pointItr = pointList.iterator();pointItr.hasNext();){
  ((Point)pointItr.next()).translate(1,1)
}
```
上述代码中，pointList会创建一个Iterator对象，通过该对象依次访问pointList中的元素。这个版本的代码
还是非常有意义的，因为时至至今这正是Java编译器生成的用于实现`for-each`循环的代码。其关键在于访问pointList
中元素的顺序是由Iterator控制的————我们无法改变这一点。比如，针对ArrayList的Iterator会按照先后顺序
返回列表中的元素。

这么做为什么会有问题呢？**任务只能在单核上进行** 。毕竟，Java Collections Framework是在1998年设计的，
而个人电脑中首个双核处理器出现在2005年。在java8发布之时（2014年３月）,四核处理器已经成为主流，八核处理器也
已经出现在硬件市场上，而专业服务器早就在每个处理器中放置了几十个核。趋势很明显，不适应这种状况的任何编译模型
都会在与适应这种状况的模型竟争中败下阵来。**适应意味着向开发者提供一种可访问的方式，使之能够将多个任务分发到多个
核上并行执行，从而利用多核的处理能力。另一方面，不适应意味着默认情况下Java程序会被绑定到单核，相对于那些能够
帮助用户并行运行代码的语言来说，这会极大地降低程序的运行速度**。

### 内部迭代
外部迭代导致集合只能连续并且按照固定顺序处理元素的做法实在太低效。我们应该告诉集合应该对它们所包含的每一个
元素采取什么动作，而不是像外部迭代那样指定怎么做。我们可以像下面一样，替换上面外部迭代的示例代码：
```java
pointList.forEach(/*translate the point by (1,1)*/);
```
**注**：在Java8之前，这个建议看起来会很奇怪。

从外部迭代到内部迭代的变化看起来很小。不过，其结果却并不是那么简单。我们所需要的 **并行工作** 现在可以定义在
集合类中，不必重复写在每一个要迭代集合的客户端方法中。 此外，实现上可以自由使用其他技术，比如说延迟加载,
乱序执行或是其他方法，从而更快地 获得结果。
