从外部迭代到内部迭代
=========================
### 外部迭代
示例：
```java
List<Point> pointList = Arrays.asList(new Point(1,2),new Point(2,3));
for(Interator pointItr = pointList.iterator();pointItr.hasNext();){
  ((Point)pointItr.next()).translate(1,1)
}
```
上述代码中，pointList会创建一个Iterator对象，通过该对象依次访问pointList中的元素。这个版本的代码
还是非常有意义的，因为时至至今这正是Java编译器生成的用于实现`for-each`循环的代码。其关键在于访问pointList
中元素的顺序是由Iterator控制的————我们无法改变这一点。比如，针对ArrayList的Iterator会按照先后顺序
返回列表中的元素。

这么做为什么会有问题呢？**任务只能在单核上进行** 。毕竟，Java Collections Framework是在1998年设计的，
而个人电脑中首个双核处理器出现在2005年。在java8发布之时（2014年３月）,四核处理器已经成为主流，八核处理器也
已经出现在硬件市场上，而专业服务器早就在每个处理器中放置了几十个核。趋势很明显，不适应这种状况的任何编译模型
都会在与适应这种状况的模型竟争中败下阵来。**适应意味着向开发者提供一种可访问的方式，使之能够将多个任务分发到多个
核上并行执行，从而利用多核的处理能力。另一方面，不适应意味着默认情况下Java程序会被绑定到单核，相对于那些能够
帮助用户并行运行代码的语言来说，这会极大地降低程序的运行速度**。
