Kubernetes是什么
================================================================================
Kubernetes是什么？它是 **一个全新的基于容器技术的分布式架构领先方案**。这个方案虽然还很新，但
**它是谷歌十几年以来大规模应用容器技术的经验积累和升华的一个重要成果**。确切地说，Kubernetes是
谷歌严格保密十几年的秘密武器————**Borg的一个开源版本**。Borg是谷歌的一个久负盛名的内部使用的
**大规模集群管理系统，它基于容器技术，目的是实现资源管理的自动化，以及跨多个数据中心的资源利用率
的最大化**。

**2015年4月**，传闻许久的Borg论文伴随Kubernetes的高调宣传被谷歌首次公开，大家才得以了解它的
更多内幕。正是由于站在Borg这个前辈的肩膀上，吸取了Borg过去十年间的经验与教训，所以Kubernetes
一经开源就一鸣惊人，并迅速称霸了容器技术领域。

其次，**如果我们的系统设计遵循了Kubernetes的设计思想，那么传统系统架构中那些和业务没有多大关系
的底层代码或功能模块，都可以立刻从我们的视线中消失，我们不必再费心于负载均衡器的选型和部署实施问
题，不必再考虑引入或自己开发一个复杂的服务治理框架，不必再头疼于服务监控和故障处理模块的开发。总
之，使用Kubernetes提供的解决方案，我们不仅节省了不少于30%的开发成本，同时可以将精力更加集中于
业务本身，而且由于Kubernetes提供了强大的自动化机制，所以系统后期的运维难度和运维成本大幅度降低**。

Kubernetes是一个开放的开发平台。它不局限于任何一种语言，没有限定任何编程接口，所以 **不论是用
java、Go、C++还是用Python编写的服务，都可以毫无困难地映射为Kubernetes的Service，并通过标准
的TCP通信协议进行交互**。此外，由于Kubernetes平台对现有的编程语言、编程框架、中间件没有任何侵
入性，因此现有的系统也很容易改造升级并迁移到Kubernetes平台上。

最后，**Kubernetes是一个完备的分布式系统支撑平台。Kubernetes具有完备的集群管理能力，包括多层
次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建智能负载匀衡器、强
大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资
源配额管理能力。同时，Kubernetes提供了完善的管理工具，这些工具涵盖了包括开发、部署测试、运维监
控在内的各个环节。因此，Kubernetes是一个全新的基于容器技术的分布式架构解决方案，并且是一个一站
式的完备的分布式系统开发和支撑平台**。

在正式开始`Hello World`之旅前，我们首先要学习`Kubernetes`的一些基本知识，这样我们才能理解
`Kubernetes`提供的解决方案。

在`Kubernetes`中，**`Service`（服务）是分布集群架构的核心**，一个`Service`对象拥有如下关键
特征：
+ **拥有一个唯一指定的名字（比如`mysql-server`）**。
+ **拥有一个虚拟IP（`Cluster IP`、`Service IP`或`VIP`）和端口号**。
+ **能够提供某种远程服务能力**。
+ **被映射到了提供这种服务能力的一组容器应用上**。

**Service的服务进程目前都基于Socket通信方法对外提供服务**，比如：Redis、Memcache、MySQL、
Web Server，或者是实现了某个具体业务的一个特定的TCP Server进程。**虽然一个Service通常由多个
相关的服务进程来提供服务，每个服务进程都有一个独立的`Endpoint`（IP+Port）访问点，但Kubernetes
能够让我们通过Service（虚拟ClusterIP + Service Port）连接到指定的Service上**。有了Kubernetes
**内建的透明负载均衡和故障恢复机制**，不管后端有多少服务进程，也不管某个服务进程是否会由于发生故
障而重新部署到其他机器，都不会影响到我们对服务的正常调用。**更重要的是这个Service本身一旦创建就
不再变化，这意味着在Kubernetes集群中，我们再也不用为了服务的IP地址变来变去的问题而头疼了**。

**容器提供了强大的隔离功能，所以有必要把为Service提供服务的这组进程放入容器中进行隔离。为此，
Kubernetes设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器（Container）。
为了建立Service和Pod间的关联关系，Kubernetes首先给每个Pod贴上一个标签（Label）**，给运行MySQL
的Pod贴上`name=mysql`标签，给运行PHP的Pod贴上`name=php`标签，**然后给相应的Service定义标
签选择器（`Label Selector`）**，比如MySQL Service的标签选择器的选择条件为`name=mysql`，意
为该Service要作用于所有包含`name=msql` Label的Pod上。这样一来，就巧妙地解决了Service与Pod
的关联问题。

说到Pod，我们这里先简单介绍其概念。首先，**Pod运行在一个我们称之为节点（`Node`）的环境中，这个
节点既可以是物理机，也可以是私有云或者公有云中的一个虚拟机，通常在一个节点上运行几百个Pod**；其
次，**每个Pod里运行着一个特殊的被称之为`Pause`的容器，其他容器则为业务容器，这些业务容器共享
`Pause`容器的网络栈和`Volume`挂载卷，因此它们之间的通信和数据交换更为高效，在设计时我们可以充
分利用这一特性将一组密切相关的服务进程放入同一个Pod中**；最后，需要注意的是，**并不是每个Pod和
它里面运行的容器都能“映射”到一个Service上，只有那些提供服务（无论是对内还是对外）的一组Pod才会
被“映射”成一个服务**。

在集群管理方面，**Kubernetes将集群中的机器划分为一个Master节点和一群工作节点（Node）**。其中，
在 **Master节点** 上运行着集群管理相关的一组进程：**kube-apiserver、kube-controller-mannager
和kube-scheduler**，这些进程实现了整个集群的 **资源管理、Pod调度、弹性伸缩、安全控制、系统监
控和纠错等管理功能，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的应用程序，在Node上
Kubernetes管理的最小运行单元是Pod。Node上运行着Kubernetes的kubelet、kube-proxy服务进程，
这些服务进程负责Pod的创建、启动、监控、重启、销毁，以及实现软件模式的负载均衡器**。

在Kubernetes集群中，**你只需为需要扩容的Service关联的Pod创建一个RC（Replication Controller），
则该Service的扩容以至于后来的Service升级等头疼问题都迎刃而解**。在一个 **RC定义文件** 中包括
以下3个关键信息：
+ **目标Pod的定义**；
+ **目标Pod需要运行的副本数量（Replicas）**；
+ **要监控的目标Pod的标签（Label）**；

在创建好RC（系统将自动创建好Pod）后，**Kubernetes会通过RC中定义的Label筛选出对应的Pod实例并
实时监控其状态和数量，如果实例数量少于定义的副本数量（Replicas），则会根据RC中定义的Pod模板来创
建一个新的Pod，然后将此Pod调度到合适的Node上启动运行，直到Pod实例的数量达到预定目标**。这个过
程完全是自动化的，无须人工干预。**有了RC，服务的扩容就变成了一个纯粹的简单数字游戏了，只要修改RC
中的副本数量即可**。后续的Service升级也将通过修改RC来自动完成。
