从一个简单的例子开始
================================================================================
这是一个Java web应用，运行在Tomcat里的Web App。JSP页面通过JDBC直接访问MySQL数据库并展示数
据。为了演示和简化的目的，只要程序正确连接到了数据库上，它就会自动完成对应的Table的创建与初始化
数据的准备工作。

此应用需要启动 **两个容器**：Web App容器和MySQL容器，并且Web App容器需要访问MySQL容器。在
Docker时代，假设我们在一个宿主机上启动了这两个容器，则我们 **需要把MySQL容器的IP地址通过环境变
量的方式注入Web App容器里**；同时，需要 **将Web App容器的8080端口映射到宿主机的8080端口**，
以便能在外部访问。

## 1.环境准备
首先，我们开始准备Kubernetes的安装和相关镜像下载，本书建议采用VirtualBox或者 **VMware Workstation**
在本机虚拟一个 **64位的CentOS7.X** 作为学习环境，虚拟机采用NAT的网络模式以便能够连接外网，然
后按照以下步骤快速安装Kubernetes。
```
注：下面都使用root帐号
```

### 1.1.关闭CentOS自带的防火墙服务
```shell
systemctl disable firewalld
systemctl stop firewalld
```

### 1.2.安装etcd和Kubernetes软件（会自动安装Docker软件）
```shell
yum install -y etcd kubernetes
```

### 1.3.编辑/etc/kubernetes/apiserver
编辑下面这一行：
```
KUBE_ADMISSION_CONTROL="--admission-control=NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota"
```
删除 **ServiceAccount**。

### 1.4.可能需要执行的命令（首次安装时不要操作）
这个示例中，我们首先安装的是MySQL。如果没有这一步操作，安装并拉取MySQL镜像时可能会出现这种情况：
```shell
kubectl get pods
```
```
NAME          READY     STATUS              RESTARTS   AGE
mysql-r38h8   0/1       ContainerCreating   0          44s
```
```shell
kubectl describe pod mysql-r38h8
```
```
Name:		mysql-r38h8
Namespace:	default
Node:		127.0.0.1/127.0.0.1
Start Time:	Mon, 18 Feb 2019 15:21:45 +0800
Labels:		app=mysql
Status:		Pending
IP:		
Controllers:	ReplicationController/mysql
Containers:
  mysql:
    Container ID:
    Image:		mysql
    Image ID:		
    Port:		3306/TCP
    State:		Waiting
      Reason:		ContainerCreating
    Ready:		False
    Restart Count:	0
    Volume Mounts:	<none>
    Environment Variables:
      MYSQL_ROOT_PASSWORD:	123456
Conditions:
  Type		Status
  Initialized 	True
  Ready 	False
  PodScheduled 	True
No volumes.
QoS Class:	BestEffort
Tolerations:	<none>
Events:
  FirstSeen	LastSeen	Count	From			SubObjectPath	Type		Reason		Message
  ---------	--------	-----	----			-------------	--------	------		-------
  1m		1m		1	{default-scheduler }			Normal		Scheduled	Successfully assigned mysql-r38h8 to 127.0.0.1
  1m		33s		3	{kubelet 127.0.0.1}			Warning		FailedSync	Error syncing pod, skipping: failed to "StartContainer" for "POD" with ErrImagePull: "image pull failed for registry.access.redhat.com/rhel7/pod-infrastructure:latest, this may be because there are no credentials on this request.  details: (open /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt: no such file or directory)"

  48s	11s	3	{kubelet 127.0.0.1}		Warning	FailedSync	Error syncing pod, skipping: failed to "StartContainer" for "POD" with ImagePullBackOff: "Back-off pulling image \"registry.access.redhat.com/rhel7/pod-infrastructure:latest\""
```
解决办法：
1. 执行命令：
   ```shell
   wget http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm
   ```
2. 执行命令：
   ```shell
   rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv --to-stdout ./etc/rhsm/ca/redhat-uep.pem | tee /etc/rhsm/ca/redhat-uep.pem
   ```
   前两个命令会生成`/etc/rhsm/ca/redhat-uep.pem`文件。

如果有必要主动验证，可以执行下面的命令（**首次一般不使用，出现上面的问题后可以用来验证**）：
```shell
docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest
```

### 1.5.按顺序启动所有的服务
```shell
systemctl start etcd
systemctl start docker
systemctl start kube-apiserver
systemctl start kube-controller-manager
systemctl start kube-scheduler
systemctl start kubelet
systemctl start kube-proxy
```
至此，一个 **单机版的Kubernetes集群环境** 就安装启动完成了。接下来，我们可以在这个单机版的
Kubernetes集群中上手练习了。
```
注：本书示例中的Docker镜像下载地址为：https://hub.docker.com/u/kubeguide/ 。
```

## 2.启动MySQL服务
首先为MySQL服务创建一个 **RC定义文件：`mysql-rc.yaml`**，下面给出了该文件的完整内容和解释：
```yaml
apiVersion: v1
kind: ReplicationController                           #副本控制器RC
metadata:
  name: mysql                                         #RC的名称，全局唯一
apec:
  replicas: 1                                         #Pod副本期待数量
  selector:
    app: mysql                                        #符合目标的Pod拥有些标签
  template:
    metadata:
      labels:
        app: mysql                                    #Pod副本拥有的标签，对应RC的Selector
    spec:
      containers:                                     #Pod内容器的定义部分
      - name: mysql                                   #容器的名称
        image: mysql                                  #容器对应的Docker Image
        ports:
        - containerPort: 3306                         #容器应用监听的端口号
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "123456"
```
yaml定义文件中的 **kind属性，用来表明此资源对象的类型**，比如这里的值为"ReplicationController"，
表示这是一个RC；**spec** 一节中是 **RC的相关属性定义**，比如 **spec.selector是RC的Pod标签
（Label）选择器，即监控和管理拥有这些标签的Pod实例，确保当前集群上始终有且仅有`replicas`个Pod
实例在运行**，这里我们设置`replicas=1`表示只能运行一个MySQL Pod实例。**当集群中运行的Pod数量
小于`replicas`时，RC会根据`spec.template`一节中定义的Pod模板来生成一个新的Pod实例，`spec.template.metadata.labels`
指定了该Pod的标签，需要特别注意的是：这里的labels必须匹配之前的`spec.selector`**，否则此RC每
次创建了一个无法匹配Label的Pod，就会不停地尝试创建新的Pod，最终陷入“为他人做嫁衣裳”的悲惨世界中，
永无翻身之时。

创建好`mysql-rc.yaml`文件以后，为了将它发布到Kubernetes集群中，我们在 **Master节点** 执行
命令：
```shell
kubectl create -f mysql-rc.yaml
```
```
replicationcontroller "mysql" created
```
接下来，我们用`kubectl`命令查看刚刚创建的`RC`：
```shell
kubectl get rc
```
```
Name  DESIRED   CURRENT   AGE
mysql 1         1         1m
```
查看Pod的创建情况时，可以运行下面的命令：
```shell
kubectl get pods
```
```
NAME          READY       STATUS        RESTARTS        AGE
mysql-c95jc   1/1         Running       0               2m 
```





























dd
