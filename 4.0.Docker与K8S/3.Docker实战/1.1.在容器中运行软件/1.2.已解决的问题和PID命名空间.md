已解决的问题和PID命名空间
===================================================================================
每一个运行的程序或进程，在Linux机器都有一个唯一编号，叫作 **进程标识符（PID）。一个PID命名空间是一
组识别进程的数字**。Linux提供了工具可以创建多个PID命名空间。**每个命名空间拥有一套完整的PID**。这
意味着，**每个PID命名空间将包含其自己的PID1、2、3，依此类推**。从进程的一个命名空间角度来看，PID1
可能是指像runit或supervisord这样的init系统进程。在不同的命名空间中，PID1可能是指诸如bash的shell命令。
**为每个容器创建一个PID命名空间是Docker的关键特征**。运行以下命令可以看到：
```shell 
docker run -d --name namespaceA busybox:latest /bin/sh -c "sleep 30000"
docker exec namespaceA ps    #1
```
命令#1应该产生类似如下的进程列表：
```
PID   USER     TIME  COMMAND
    1 root      0:00 sleep 30000
   16 root      0:00 ps
```
在这个示例中，**使用`docker exec`命令在运行的容器中运行额外的进程**。在这种情况下，使用的命令被称
为 **ps**，**显示所有正在运行的进程和它们的PID**。从输出上很明显地看到，**每个容器都有一个带有PID1
的进程**。

**若没有PID命名空间，在一个容器内运行的进程将和其他容器或主机共享相同的ID空间**。这样，容器无法确
定其他主机有哪些进程在运行。更糟的是，命名空间将许多授权决策转交域来决定。这意味着，一个容器中的进
程可能控制其他容器中的进程。**没有PID命名空间的Docker显得苍白无力。Docker使用的是Linux的功能，如
命名空间，可以帮你完整解决这一层面的软件问题**。

**像大多数Docker的隔离功能，你可以有选择地创建没有PID命名空间的容器。可以通过在命令`docker create`
或`docker run`中设置`--pid`标志以及将该值设置为host来自行尝试**。也可以运行BusyBox的Linux容器和使
用ps命令试试：
```shell 
# 应该列出本机中运行着的所有进程
docker run --pid host busybox:latest ps
```
回想一下前面Web服务器监控的示例。假设你没有使用Docker，只是在你的机器上直接运行NGINX。现在假设你
忘了已经为另一个项目启动了NGINX。当再次启动NGINX，第二个进程将不能访问它需要的资源，因为第一个进
程已经占有了这些资源。这是一个软件冲突的基本示例。你可以尝试在同一容器中运行Nginx的两个副本看看：
```shell

```
