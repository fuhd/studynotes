秒杀系统架构分析与实战
===============================================================

### 1.秒杀业务分析

1. **正常电子商务流程**
（1）查询商品；（2）创建订单；（3）扣减库存；（4）更新订单；（5）付款；（6）卖家发货
2. **秒杀业务的特性**
（1）低廉价格；（2）大幅推广；（3）瞬时售空；（4）一般是定时上架；（5）时间短、瞬时并发量高；

### 2.秒杀技术挑战
假设某网站秒杀活动只推出一件商品，预计会吸引1万人参加活动，也就说最大并发请求数是`10000`，秒杀系统需要面对的技术挑战有：

1. **对现有网站业务造成冲击**：
秒杀活动只是网站营销的一个附加活动，这个活动具有时间短，并发访问量大的特点，如果和网站原有应用部署在一起，
必然会对现有业务造成冲击，稍有不慎可能导致整个网站瘫痪。
**解决方案：将秒杀系统独立部署，甚至使用独立域名，使其与网站完全隔离。**

2. **高并发下的应用、数据库负载**：
用户在秒杀开始前，通过不停刷新浏览器页面以保证不会错过秒杀，这些请求如果按照一般的网站应用架构，访问应用服务器、
连接数据库，会对应用服务器和数据库服务器造成负载压力。
**解决方案：重新设计秒杀商品页面，不使用网站原来的商品详细页面，页面内容静态化，用户请求不需要经过应用服务**。

3. **突然增加的网络及服务器带宽**：
假设商品页面大小`200K`（主要是商品图片大小），那么需要的网络和服务器带宽是`2G（200K×10000）`，
这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。
**解决方案：因为秒杀新增的网络带宽，必须到运营商重新购买或者租借。为了减轻网站服务器的压力，
需要将秒杀商品页面缓存在`CDN`，同样需要和`CDN`服务商临时租借新增的出口带宽**。

4. **直接下单**：
秒杀的游戏规则是到了秒杀才能开始对商品下单购买，在此时间点之前，只能浏览商品信息，不能下单。而下单页面也是一个普通的`URL`，
如果得到这个`URL`，不用等到秒杀开始就可以下单了。
**解决方案：为了避免用户直接访问下单页面`URL`，需要将`URL`动态化，即使秒杀系统的开发者也无法在秒杀开始前访问下单页面的`URL`。
办法是在下单页面`URL`加入由服务器端生成的随机数作为参数，在秒杀开始的时候才能得到**。

5. **如何控制秒杀商品页面购买按钮的点亮**：
购买按钮只有在秒杀开始的时候才能点亮，在此之前是灰色的。如果该页面是动态生成的，当然可以在服务器端构造响应页面输出，
控制该按钮是灰色还是点亮，但是为了减轻服务器端负载压力，更好地利用`CDN`、反向代理等性能优化手段，该页面被设计为静态页面，
缓存在`CDN`、反向代理服务器上，甚至用户浏览器上。秒杀开始时，用户刷新页面，请求根本不会到达应用服务器。
**解决方案：使用`JavaScript`脚本控制，在秒杀商品静态页面中加入一个`JavaScript`文件引用，该`JavaScript`文件中包含秒杀开始标志为否；
当秒杀开始的时候生成一个新的`JavaScript`文件（文件名保持不变，只是内容不一样），更新秒杀开始标志为是，
加入下单页面的`URL`及随机数参数（这个随机数只会产生一个，即所有人看到的`URL`都是同一个，
服务器端可以用`redis`这种分布式缓存服务器来保存随机数），并被用户浏览器加载，控制秒杀商品页面的展示。
这个`JavaScript`文件的加载可以加上随机版本号（例如`xx.js?v=32353823`），这样就不会被浏览器、`CDN`和反向代理服务器缓存**。
这个`JavaScript`文件非常小，即使每次浏览器刷新都访问`JavaScript`文件服务器也不会对服务器集群和网络带宽造成太大压力。

6. **如何只允许第一个提交的订单被发送到订单子系统**：
由于最终能够成功秒杀到商品的用户只有一个，因此需要在用户提交订单时，检查是否已经有订单提交。如果已经有订单提交成功，
则需要更新`JavaScript`文件，更新秒杀开始标志为否，购买按钮变灰。事实上，由于最终能够成功提交订单的用户只有一个，
为了减轻下单页面服务器的负载压力， 可以控制进入下单页面的入口，只有少数用户能进入下单页面，其他用户直接进入秒杀结束页面。
**解决方案：假设下单服务器集群有`10`台服务器，每台服务器只接受最多`10`个下单请求。在还没有人提交订单成功之前，
如果一台服务器已经有十单了，而有的一单都没处理，可能出现的用户体验不佳的场景是用户第一次点击购买按钮进入已结束页面，
再刷新一下页面，有可能被一单都没有处理的服务器处理，进入了填写订单的页面，可以考虑通过`cookie`的方式来应对，符合一致性原则。
当然可以采用最少连接的负载均衡算法，出现上述情况的概率大大降低**。

7. **如何进行下单前置检查**：
  + **下单服务器检查本机已处理的下单请求数目**：如果超过10条，直接返回已结束页面给用户；如果未超过10条，则用户可进入填写订单及确认页面；
  + **检查全局已提交订单数目**：已超过秒杀商品总数，返回已结束页面给用户；未超过秒杀商品总数，提交到子订单系统；

8. **秒杀一般是定时上架**
该功能实现方式很多。不过目前比较好的方式是：提前设定好商品的上架时间，用户可以在前台看到该商品，但是无法点击“立即购买”的按钮。
但是需要考虑的是，有人可以绕过前端的限制，直接通过URL的方式发起购买，这就需要在前台商品页面，以及`bug`页面到后端的数据库，
都要进行时钟同步。越在后端控制，安全性越高。

定时秒杀的话，就要 **避免卖家在秒杀前对商品做编辑** 带来的不可预期的影响。这种特殊的变更需要多方面评估。一般禁止编辑，如需变更，
可以走数据订正多的流程。

9. **减库存的操作**
有两种选择，一种是拍下减库存，另外一种是付款减库存；目前采用的“ **拍下减库存** ”的方式，拍下就是一瞬间的事，对用户体验会好些。

10. **库存会带来“超卖”的问题：售出数量多于库存数量**
由于库存并发更新的问题，导致在实际库存已经不足的情况下，库存依然在减，导致卖家的商品卖得件数超过秒杀的预期。**方案：采用乐观锁**
```sql
update auction_auctions set quantity = ＃inQuantity＃ where auction_id = ＃itemId＃ and quantity = ＃dbQuantity＃
```
还有一种方式，会更好些，叫做尝试扣减库存，扣减库存成功才会进行下单逻辑：
```sql
update auction_auctions set quantity = quantity-＃count＃ where auction_id = ＃itemId＃ and quantity >= ＃count＃
```

11. **秒杀器的应对**
秒杀器一般下单个购买及其迅速，根据购买记录可以甄别出一部分。可以通过校验码达到一定的方法，这就要求校验码足够安全，不被破解，
采用的方式有：**秒杀专用验证码**，**电视公布验证码**，**秒杀答题**。

### 3.秒杀架构原则

**尽量将请求拦截在系统上游**

传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，
下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】。

**读多写少的常用多使用缓存**

这是一个典型的读多写少的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，
写比例只有0.1%，读比例占99.9%】，**非常适合使用缓存**。

### 4.秒杀架构设计
秒杀系统为秒杀而设计，不同于一般的网购行为，参与秒杀活动的用户更关心的是如何能快速刷新商品页面，在秒杀开始的时候抢先进入下单页面，
而不是商品详情等用户体验细节，因此 **秒杀系统的页面设计应尽可能简单**。

商品页面中的购买按钮只有在秒杀活动开始的时候才变亮，在此之前及秒杀商品卖出后，该按钮都是灰色的，不可以点击。

下单表单也尽可能简单，购买数量只能是一个且不可以修改，送货地址和付款方式都使用用户默认设置，没有默认也可以不填，
允许等订单提交后修改；只有第一个提交的订单发送给网站的订单子系统，其余用户提交订单后只能看到秒杀结束页面。

要做一个这样的秒杀系统，业务会分为两个阶段，**第一个阶段是秒杀开始前某个时间到秒杀开始**， 这个阶段可以称之为准备阶段，
用户在准备阶段等待秒杀； **第二个阶段就是秒杀开始到所有参与秒杀的用户获得秒杀结果**， 这个就称为秒杀阶段吧。

#### 4.1 前端层设计
首先要有一个展示秒杀商品的页面， 在这个页面上做一个秒杀活动开始的倒计时，在准备阶段内用户会陆续打开这个秒杀的页面，
并且可能不停的刷新页面。这里需要考虑两个问题：

**第一个是秒杀页面的展示**

我们知道一个`html`页面还是比较大的，即使做了压缩，`http`头和内容的大小也可能高达数十K，加上其他的`css`，`js`，
图片等资源，如果同时有几千万人参与一个商品的抢购，一般机房带宽也就只有`1G~10G`，网络带宽就极有可能成为瓶颈，
所以 **这个页面上各类静态资源首先应分开存放，然后放到`cdn`节点上分散压力**，由于`CDN`节点遍布全国各地，
能缓冲掉绝大部分的压力，而且还比机房带宽便宜。

**第二个是倒计时**

出于性能原因这个一般由`js`调用客户端本地时间，就有可能出现客户端时钟与服务器时钟不一致，另外服务器之间也是有可能出现时钟不一致。
**客户端与服务器时钟不一致可以采用客户端定时和服务器同步时间**，这里考虑一下性能问题，用于同步时间的接口由于不涉及到后端逻辑，
**只需要将当前`web`服务器的时间发送给客户端** 就可以了，因此速度很快，就我以前测试的结果来看，一台标准的`web`服务器`2W+QPS`不会有问题，
如果`100W`人同时刷，`100W QPS`也只需要`50`台`web`，一台硬件`LB`就可以了，并且`web`服务器群是可以很容易的横向扩展的(`LB+DNS`轮询)，
**这个接口可以只返回一小段`json`格式的数据，而且可以优化一下减少不必要`cookie`和其他`http`头的信息，所以数据量不会很大**，
一般来说网络不会成为瓶颈，即使成为瓶颈也可以考虑 **多机房专线连通**，加智能`DNS`的解决方案；**`web`服务器之间时间不同步可以采用统一时间服务器的方式**，
比如每隔1分钟所有参与秒杀活动的web服务器就与时间服务器做一次时间同步。

**浏览器层请求拦截**
+ 产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求;
+ JS层面，限制用户在x秒之内只能提交一次请求;

#### 4.2 站点层设计
前端层的请求拦截，只能拦住小白用户（不过这是`99%`的用户哟），高端的程序员根本不吃这一套，写个`for`循环，
直接调用你后端的`http`请求，怎么整？

1. 同一个`uid`，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面
2. 同一个`item`的查询，例如手机车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面

如此限流，又有`99%`的流量会被拦截在站点层。

#### 4.3 服务层设计
站点层的请求拦截，只能拦住普通程序员，高级黑客，假设他控制了`10w`台肉鸡（并且假设买票不需要实名认证），
这下`uid`的限制不行了吧？怎么整？

1. 大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有`2000`张车票，我透`10w`个请求去数据库有什么意义呢？
对于写请求，做请求队列，每次只透过有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”；
2. 对于读请求，还用说么？`cache`来抗，不管是`memcached`还是`redis`，单机抗个每秒`10w`应该都是没什么问题的；

如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有`99.9%`的请求被拦住了。

**用户请求分发模块**：使用`Nginx`或`Apache`将用户的请求分发到不同的机器上。

**用户请求预处理模块**：判断商品是不是还有剩余来决定是不是要处理该请求。

**用户请求处理模块**：把通过预处理的请求封装成事务提交给数据库，并返回是否成功。

**数据库接口模块**：该模块是数据库的唯一接口，负责与数据库交互，提供`RPC`接口供查询是否秒杀结束、剩余数量等信息。

##### 用户请求预处理模块
经过`HTTP`服务器的分发后，单个服务器的负载相对低了一些，但总量依然可能很大，如果后台商品已经被秒杀完毕，
那么直接给后来的请求返回秒杀失败即可，不必再进一步发送事务了，示例代码可以如下所示：
```java
package seckill;
import org.apache.http.HttpRequest;
/**
* 预处理阶段，把不必要的请求直接驳回，必要的请求添加到队列中进入下一阶段.
*/
public class PreProcessor {
    // 商品是否还有剩余
    private static boolean reminds = true;
    private static void forbidden() {
        // Do something.
    }
    public static boolean checkReminds() {
        if (reminds) {
            // 远程检测是否还有剩余，该RPC接口应由数据库服务器提供，不必完全严格检查.
            if (!RPC.checkReminds()) {
                reminds = false;
            }
        }
        return reminds;
    }
    /**
    * 每一个HTTP请求都要经过该预处理.
    */
    public static void preProcess(HttpRequest request) {
        if (checkReminds()) {
            // 一个并发的队列
            RequestQueue.queue.add(request);
        } else {
            // 如果已经没有商品了，则直接驳回请求即可.
            forbidden();
        }
    }
}
```
