Throwables：简化异常和错误的传播与检查
================================================================================
## 1.异常传播
**有时候，你会想把捕获到的异常再次抛出**。这种情况通常发生在`Error`或`RuntimeException`被捕
获的时候，你没想捕获它们，但是声明捕获`Throwable`和`Exception`的时候，也包括了了`Error`或
`RuntimeException`。Guava提供了若干方法，来判断异常类型并且重新传播异常。例如：
```java
try {
    someMethodThatCouldThrowAnything();
} catch (IKnowWhatToDoWithThisException e) {
    handle(e);
} catch (Throwable t) {
    Throwables.propagateIfInstanceOf(t, IOException.class);
    Throwables.propagateIfInstanceOf(t, SQLException.class);
    throw Throwables.propagate(t);
}
```
**所有这些方法都会自己决定是否要抛出异常，但也能直接抛出方法返回的结果**——例如：
```java
throw Throwables.propagate(t);
```
这样可以向编译器声明这里一定会抛出异常。

Guava中的异常传播方法简要列举如下：

| 方法 | 描述 |
| :------------- | :------------- |
| `RuntimeException propagate(Throwable)` | 如果Throwable是Error或RuntimeException，直接抛出；否则把Throwable包装成RuntimeException抛出。返回类型是RuntimeException，所以你可以像上面说的那样写成`throw Throwables.propagate(t)`，Java编译器会意识到这行代码保证抛出异常。 |
| `void propagateIfInstanceOf(Throwable, Class<X extends Exception>) throws X` | Throwable类型为X才抛出 |
| `void propagateIfPossible(Throwable)` | Throwable类型为Error或RuntimeException才抛出 |
| `void propagateIfPossible(Throwable, Class<X extends Throwable>) throws X` | Throwable类型为X, Error或RuntimeException才抛出 |

































ss
