集合之新集合类型
================================================================================
Guava引入了很多JDK没有的、但我们发现明显有用的新集合类型。这些新类型是为了和JDK集合框架共存，而
没有往JDK集合抽象中硬塞其他概念。作为一般规则，**Guava集合非常精准地遵循了JDK接口契约**。

## 1.Multiset
统计一个词在文档中出现了多少次，传统的做法是这样的：
```java
Map<String, Integer> counts = new HashMap<String, Integer>();
for (String word : words) {
    Integer count = counts.get(word);
    if (count == null) {
        counts.put(word, 1);
    } else {
        counts.put(word, count + 1);
    }
}
```
这种写法很笨拙，也容易出错，并且不支持同时收集多种统计信息，如总词数。我们可以做的更好。

Guava提供了一个新集合类型 **Multiset**，**它可以多次添加相等的元素**。维基百科从数学角度这样
定义Multiset：”**集合[set]概念的延伸，它的元素可以重复出现…与集合[set]相同而与元组[tuple]相
反的是，Multiset元素的顺序是无关紧要的：`Multiset{a, a, b}`和`{a, b, a}`是相等的**”。——
译者注：**这里所说的集合[set]是数学上的概念，Multiset继承自JDK中的Collection接口，而不是Set
接口**，所以包含重复元素并没有违反原有的接口契约。

可以用两种方式看待Multiset：
+ **没有元素顺序限制的`ArrayList<E>`**；
+ **`Map<E, Integer>`，键为元素，值为计数**；

当把Multiset看成普通的Collection时，它表现得就像无序的ArrayList：
+ **`add(E)`添加单个给定元素**；
+ **`iterator()`返回一个迭代器，包含Multiset的所有元素（包括重复的元素）**；
+ **`size()`返回所有元素的总个数（包括重复的元素）**；

当把Multiset看作`Map<E, Integer>`时，它也提供了符合性能期望的查询操作：
+ **`count(Object)`返回给定元素的计数。`HashMultiset.count`的复杂度为`O(1)`，
`TreeMultiset.count`的复杂度为`O(log n)`**。
































dd
