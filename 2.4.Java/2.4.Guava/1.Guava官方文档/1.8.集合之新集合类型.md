集合之新集合类型
================================================================================
Guava引入了很多JDK没有的、但我们发现明显有用的新集合类型。这些新类型是为了和JDK集合框架共存，而
没有往JDK集合抽象中硬塞其他概念。作为一般规则，**Guava集合非常精准地遵循了JDK接口契约**。

## 1.Multiset
统计一个词在文档中出现了多少次，传统的做法是这样的：
```java
Map<String, Integer> counts = new HashMap<String, Integer>();
for (String word : words) {
    Integer count = counts.get(word);
    if (count == null) {
        counts.put(word, 1);
    } else {
        counts.put(word, count + 1);
    }
}
```
这种写法很笨拙，也容易出错，并且不支持同时收集多种统计信息，如总词数。我们可以做的更好。

Guava提供了一个新集合类型 **Multiset**，**它可以多次添加相等的元素**。维基百科从数学角度这样
定义Multiset：”**集合[set]概念的延伸，它的元素可以重复出现…与集合[set]相同而与元组[tuple]相
反的是，Multiset元素的顺序是无关紧要的：`Multiset{a, a, b}`和`{a, b, a}`是相等的**”。——
译者注：**这里所说的集合[set]是数学上的概念，Multiset继承自JDK中的Collection接口，而不是Set
接口**，所以包含重复元素并没有违反原有的接口契约。

可以用两种方式看待Multiset：
+ **没有元素顺序限制的`ArrayList<E>`**；
+ **`Map<E, Integer>`，键为元素，值为计数**；

当把Multiset看成普通的Collection时，它表现得就像无序的ArrayList：
+ **`add(E)`添加单个给定元素**；
+ **`iterator()`返回一个迭代器，包含Multiset的所有元素（包括重复的元素）**；
+ **`size()`返回所有元素的总个数（包括重复的元素）**；

当把Multiset看作`Map<E, Integer>`时，它也提供了符合性能期望的查询操作：
+ **`count(Object)`返回给定元素的计数。`HashMultiset.count`的复杂度为`O(1)`，
`TreeMultiset.count`的复杂度为`O(log n)`**；
+ **`entrySet()`返回`Set<Multiset.Entry<E>>`，和Map的entrySet类似**；
+ **`elementSet()`返回所有不重复元素的`Set<E>`，和Map的`keySet()`类似**；
+ **所有Multiset实现的内存消耗随着不重复元素的个数线性增长**；

值得注意的是，除了极少数情况，Multiset和JDK中原有的Collection接口契约完全一致——具体来说，
`TreeMultiset`在判断元素是否相等时，与`TreeSet`一样用`compare`，而不是`Object.equals`。
另外特别注意，`Multiset.addAll(Collection)`可以添加`Collection`中的所有元素并进行计数，这
比用for循环往Map添加元素和计数方便多了。

| 方法 | 描述 |
| :------------- | :------------- |
| count(E) | 给定元素在Multiset中的计数 |
| elementSet() | Multiset中不重复元素的集合，类型为Set<E> |
| entrySet() | 和Map的entrySet类似，返回Set<Multiset.Entry<E>>，其中包含的Entry支持getElement()和getCount()方法 |
| add(E, int) | 增加给定元素在Multiset中的计数 |
| remove(E, int) | 减少给定元素在Multiset中的计数 |
| setCount(E, int) | 设置给定元素在Multiset中的计数，不可以为负数 |
| size() | 返回集合元素的总个数（包括重复的元素） |

## 1.1.Multiset不是Map
请注意，`Multiset<E>`不是`Map<E, Integer>`，虽然Map可能是某些Multiset实现的一部分。**准
确来说Multiset是一种Collection类型，并履行了Collection接口相关的契约**。关于Multiset和Map
的显著区别还包括：
+ **Multiset中的元素计数只能是正数。任何元素的计数都不能为负，也不能是0。`elementSet()`和
`entrySet()`视图中也不会有这样的元素**。
+ **`multiset.size()`返回集合的大小，等同于所有元素计数的总和。对于不重复元素的个数，应使用
`elementSet().size()`方法**。（因此，add(E)把multiset.size()增加1）
+ **`multiset.iterator()`会迭代重复元素，因此迭代长度等于`multiset.size()`**。
+ **Multiset支持直接增加、减少或设置元素的计数。`setCount(elem, 0)`等同于移除所有elem**。
+ **对multiset中没有的元素，`multiset.count(elem)`始终返回0**。








































dd
