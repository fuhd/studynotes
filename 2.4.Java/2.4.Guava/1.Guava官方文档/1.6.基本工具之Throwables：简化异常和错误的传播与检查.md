Throwables：简化异常和错误的传播与检查
================================================================================
## 1.异常传播
**有时候，你会想把捕获到的异常再次抛出**。这种情况通常发生在`Error`或`RuntimeException`被捕
获的时候，你没想捕获它们，但是声明捕获`Throwable`和`Exception`的时候，也包括了了`Error`或
`RuntimeException`。Guava提供了若干方法，来判断异常类型并且重新传播异常。例如：
```java
try {
    someMethodThatCouldThrowAnything();
} catch (IKnowWhatToDoWithThisException e) {
    handle(e);
} catch (Throwable t) {
    Throwables.propagateIfInstanceOf(t, IOException.class);
    Throwables.propagateIfInstanceOf(t, SQLException.class);
    throw Throwables.propagate(t);
}
```
**所有这些方法都会自己决定是否要抛出异常，但也能直接抛出方法返回的结果**——例如：
```java
throw Throwables.propagate(t);
```
这样可以向编译器声明这里一定会抛出异常。

Guava中的异常传播方法简要列举如下：

| 方法 | 描述 |
| :------------- | :------------- |
| `RuntimeException propagate(Throwable)` | 如果Throwable是Error或RuntimeException，直接抛出；否则把Throwable包装成RuntimeException抛出。返回类型是RuntimeException，所以你可以像上面说的那样写成`throw Throwables.propagate(t)`，Java编译器会意识到这行代码保证抛出异常。 |
| `void propagateIfInstanceOf(Throwable, Class<X extends Exception>) throws X` | Throwable类型为X才抛出 |
| `void propagateIfPossible(Throwable)` | Throwable类型为Error或RuntimeException才抛出 |
| `void propagateIfPossible(Throwable, Class<X extends Throwable>) throws X` | Throwable类型为X, Error或RuntimeException才抛出 |

## 2.Throwables.propagate的用法

### 2.1.模仿Java7的多重异常捕获和再抛出
通常来说，如果调用者想让异常传播到栈顶，他不需要写任何catch代码块。因为他不打算从异常中恢复，他
可能就不应该记录异常，或者有其他的动作。他可能是想做一些清理工作，但通常来说，无论操作是否成功，
清理工作都要进行，所以清理工作可能会放在finallly代码块中。但有时候，**捕获异常然后再抛出也是有
用的：也许调用者想要在异常传播之前统计失败的次数，或者有条件地传播异常**。

当只对一种异常进行捕获和再抛出时，代码可能还是简单明了的。但 **当多种异常需要处理时，却可能变得
一团糟**：
```java  
@Override public void run() {
    try {
        delegate.run();
    } catch (RuntimeException e) {
        failures.increment();
        throw e;
    }catch (Error e) {
        failures.increment();
        throw e;
    }
}
```
Java7用多重捕获解决了这个问题：
```java
} catch (RuntimeException | Error e) {
    failures.increment();
    throw e;
}
```
**非Java7用户却受困于这个问题**。他们想要写如下代码来统计所有异常，**但是编译器不允许他们抛出
Throwable**（译者注：这种写法把原本是Error或RuntimeException类型的异常修改成了Throwable，
因此调用者不得不修改方法签名）：
```java
} catch (Throwable t) {
    failures.increment();
    throw t;
}
```
**解决办法是用`throw Throwables.propagate(t)`替换`throw t`**。在限定情况下（捕获Error和
RuntimeException），`Throwables.propagate`和原始代码有相同行为。然而，用`Throwables.propagate`
也很容易写出有其他隐藏行为的代码。尤其要注意的是，**这个方案只适用于处理RuntimeException 或
Error。如果catch块捕获了受检异常，你需要调用`propagateIfInstanceOf`来保留原始代码的行为，
因为`Throwables.propagate`不能直接传播受检异常**。

总之，`Throwables.propagate`的这种用法也就马马虎虎，在Java7中就没必要这样做了。在其他Java版
本中，它可以减少少量的代码重复，但简单地提取方法进行重构也能做到这一点。此外，**使用propagate会
意外地包装受检异常**。

































ss
