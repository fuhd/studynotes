Throwables：简化异常和错误的传播与检查
================================================================================
## 1.异常传播
**有时候，你会想把捕获到的异常再次抛出**。这种情况通常发生在`Error`或`RuntimeException`被捕
获的时候，你没想捕获它们，但是声明捕获`Throwable`和`Exception`的时候，也包括了了`Error`或
`RuntimeException`。Guava提供了若干方法，来判断异常类型并且重新传播异常。例如：
```java
try {
    someMethodThatCouldThrowAnything();
} catch (IKnowWhatToDoWithThisException e) {
    handle(e);
} catch (Throwable t) {
    Throwables.propagateIfInstanceOf(t, IOException.class);
    Throwables.propagateIfInstanceOf(t, SQLException.class);
    throw Throwables.propagate(t);
}
```
**所有这些方法都会自己决定是否要抛出异常，但也能直接抛出方法返回的结果**——例如：
```java
throw Throwables.propagate(t);
```
这样可以向编译器声明这里一定会抛出异常。

Guava中的异常传播方法简要列举如下：

| 方法 | 描述 |
| :------------- | :------------- |
| `RuntimeException propagate(Throwable)` | 如果Throwable是Error或RuntimeException，直接抛出；否则把Throwable包装成RuntimeException抛出。返回类型是RuntimeException，所以你可以像上面说的那样写成`throw Throwables.propagate(t)`，Java编译器会意识到这行代码保证抛出异常。 |
| `void propagateIfInstanceOf(Throwable, Class<X extends Exception>) throws X` | Throwable类型为X才抛出 |
| `void propagateIfPossible(Throwable)` | Throwable类型为Error或RuntimeException才抛出 |
| `void propagateIfPossible(Throwable, Class<X extends Throwable>) throws X` | Throwable类型为X, Error或RuntimeException才抛出 |

## 2.Throwables.propagate的用法

### 2.1.模仿Java7的多重异常捕获和再抛出
通常来说，如果调用者想让异常传播到栈顶，他不需要写任何catch代码块。因为他不打算从异常中恢复，他
可能就不应该记录异常，或者有其他的动作。他可能是想做一些清理工作，但通常来说，无论操作是否成功，
清理工作都要进行，所以清理工作可能会放在finallly代码块中。但有时候，**捕获异常然后再抛出也是有
用的：也许调用者想要在异常传播之前统计失败的次数，或者有条件地传播异常**。

当只对一种异常进行捕获和再抛出时，代码可能还是简单明了的。但 **当多种异常需要处理时，却可能变得
一团糟**：
```java  
@Override public void run() {
    try {
        delegate.run();
    } catch (RuntimeException e) {
        failures.increment();
        throw e;
    }catch (Error e) {
        failures.increment();
        throw e;
    }
}
```
Java7用多重捕获解决了这个问题：
```java
} catch (RuntimeException | Error e) {
    failures.increment();
    throw e;
}
```
**非Java7用户却受困于这个问题**。他们想要写如下代码来统计所有异常，**但是编译器不允许他们抛出
Throwable**（译者注：这种写法把原本是Error或RuntimeException类型的异常修改成了Throwable，
因此调用者不得不修改方法签名）：
```java
} catch (Throwable t) {
    failures.increment();
    throw t;
}
```
**解决办法是用`throw Throwables.propagate(t)`替换`throw t`**。在限定情况下（捕获Error和
RuntimeException），`Throwables.propagate`和原始代码有相同行为。然而，用`Throwables.propagate`
也很容易写出有其他隐藏行为的代码。尤其要注意的是，**这个方案只适用于处理RuntimeException 或
Error。如果catch块捕获了受检异常，你需要调用`propagateIfInstanceOf`来保留原始代码的行为，
因为`Throwables.propagate`不能直接传播受检异常**。

总之，`Throwables.propagate`的这种用法也就马马虎虎，在Java7中就没必要这样做了。在其他Java版
本中，它可以减少少量的代码重复，但简单地提取方法进行重构也能做到这一点。此外，**使用propagate会
意外地包装受检异常**。

### 2.2.非必要用法：把抛出的Throwable转为Exception
**有少数API，尤其是Java反射API和（以此为基础的）Junit，把方法声明成抛出Throwable。和这样的API
交互太痛苦了，因为即使是最通用的API通常也只是声明抛出Exception**。当确定代码会抛出Throwable，
而不是Exception或Error时，调用者可能会用`Throwables.propagate`转化Throwable。这里有个用
Callable执行Junit测试的范例：
```java
public Void call() throws Exception {
    try {
        FooTest.super.runTest();
    } catch (Throwable t) {
        Throwables.propagateIfPossible(t, Exception.class);
        Throwables.propagate(t);
    }
    return null;
}
```
**在这儿没必要调用`propagate()`方法，因为`propagateIfPossible`传播了Throwable之外的所有
异常类型，第二行的propagate就变得完全等价于`throw new RuntimeException(t)`**。（题外话：
这个例子也提醒我们，propagateIfPossible可能也会引起混乱，因为它不但会传播参数中给定的异常类型，
还抛出Error和RuntimeException）。

## 3.Throwables.propagate的有争议用法

### 3.1.争议一：把受检异常转化为非受检异常
**原则上，非受检异常代表bug，而受检异常表示不可控的问题。但在实际运用中，即使JDK也有所误用**——
如`Object.clone()`、`Integer.parseInt(String)`、`URI(String)`——或者至少对某些方法来说，
没有让每个人都信服的答案，如`URI.create(String)`的异常声明。

因此，**调用者有时不得不把受检异常和非受检异常做相互转化**：
```java
//1
try {
    return Integer.parseInt(userInput);
} catch (NumberFormatException e) {
    throw new InvalidInputException(e);
}
//2
try {
    return publicInterfaceMethod.invoke();
} catch (IllegalAccessException e) {
    throw new AssertionError(e);
}
```
有时候，**调用者会使用`Throwables.propagate`转化异常。这样做有没有什么缺点？最主要的恐怕是代
码的含义不太明显**。`throw Throwables.propagate(ioException)`做了什么？
`throw new RuntimeException(ioException)`做了什么？**这两者做了同样的事情，但后者的意思更
简单直接**。前者却引起了疑问：”它做了什么？它并不只是把异常包装进RuntimeException吧？如果它真
的只做了包装，为什么还非得要写个方法？”。应该承认，这些问题部分是因为”propagate”的语义太模糊了
（用来抛出未声明的异常吗？）。也许”wrapIfChecked”更能清楚地表达含义。但即使方法叫做
”wrapIfChecked”，用它来包装一个已知类型的受检异常也没什么优点。甚至会有其他缺点：也许比起
RuntimeException，还有更合适的类型——如IllegalArgumentException。

我们有时也会看到propagate被用于传播可能为受检的异常，**结果是代码相比以前会稍微简短点，但也稍微
有点不清晰**：
```java
//1
} catch (RuntimeException e) {
    throw e;
}catch (Exception e) {
    throw new RuntimeException(e);
}
//2
} catch (Exception e) {
    throw Throwables.propagate(e);
}
```
然而，**我们似乎故意忽略了把检查型异常转化为非检查型异常的合理性。在某些场景中，这无疑是正确的做
法，但更多时候它被用于避免处理受检异常**。这让我们的话题变成了争论受检异常是不是坏主意了，我不想
对此多做叙述。但可以这样说，**`Throwables.propagate`不是为了鼓励开发者忽略IOException这样
的异常**。
































ss
