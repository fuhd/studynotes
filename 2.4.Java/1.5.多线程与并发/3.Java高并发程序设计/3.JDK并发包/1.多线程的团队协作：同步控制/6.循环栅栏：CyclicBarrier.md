循环栅栏：CyclicBarrier
=====================================================================
**`CyclicBarrier`** 是另外一种多线程并发控制实用工具。和`CountDownLatch`非常类似，**它也可以实现线程间的计数等待**，
但它的功能比`CountDownLatch`更加复杂且强大。

`CyclicBarrier`可以理解为 **循环栅栏**。栅栏就是一种障碍物，这里当然就是用来阻止线程继续执行，
要求线程在栅栏处等待。前面`Cyclic`意为循环，也就是说 **这个计数器可以反复使用**。比如，**假设我们将计数器
设置为10，那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程，这就是循环栅栏内的的含义**。

比`CountDownLatch`略微强大一些，`CyclicBarrier`可以接收一个参数作为`barrierAction`。**所谓
`barrierAction`就是当计数器一次计数完成后，系统会执行的动作**。如下构造函数，其中，**`parties`表示
计数总数，也就是参与的线程总数**。
```java
public CyclicBarrier(int parties, Runnable barrierAction)
```

`CyclicBarrier`的使用场景也很丰富。比如，司令下达命令，要求10个士兵一起去完成一项任务。这时，
就会要求10个士兵先集合报道，接着，一起雄赳赳气昴昴地去执行任务。当10个士兵把自己手头的任务都执行完成了，
那么司令才能对外宣布，任务完成！示例如下：
```java
package concurrent;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {

    public static class Soldier implements Runnable {

        private String soldier;
        private final CyclicBarrier cyclic;

        Soldier(CyclicBarrier syclic, String soldierName) {
            this.cyclic = syclic;
            this.soldier = soldierName;
        }

        @Override
        public void run() {
            try {
                //等待所有士兵到齐
                cyclic.await();
                //开始工作
                doWork();
                //等待所有士兵完成工作
                cyclic.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }

        void doWork() {
            try {
                Thread.currentThread().sleep(Math.abs(new Random().nextInt() % 10000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(soldier + ":任务完成！！！");
        }
    }

    public static class BarrierRun implements Runnable {

        boolean flag;
        int n;

        public BarrierRun(boolean flag, int n) {
            this.flag = flag;
            this.n = n;
        }

        @Override
        public void run() {
            if (flag) {
                System.out.println("司令：[士兵" + n + "个，任务完成！]");
            } else {
                System.out.println("司令：[士兵" + n + "个，集合完毕！]");
                flag = true;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        final int n = 10;
        Thread[] allSoldier = new Thread[10];
        boolean flag = false;
        CyclicBarrier syclic = new CyclicBarrier(n, new BarrierRun(flag, n));
        //设置屏障点，主要是为了执行这个方法
        System.out.println("司令：集合队伍！！！");
        for (int i = 0; i < n; i++) {
            System.out.println("士兵" + i + "：报道！！！");
            allSoldier[i] = new Thread(new Soldier(syclic, "士兵" + i));
            allSoldier[i].start();
        }
    }
}
```
`CyclicBarrier.await()`方法可能会抛出两个异常。一个是`InterruptedException`，也就是在等待过程中，
线程被中断，应该说这是一个非常通用的异常。大部分迫使线程等待的方法都可能会抛出这个异常，使得线程在等待时
依然可以响应外部紧急事件。另外一个异常则是`CyclicBarrier`特有的`BrokenBarrierException`。
一旦遇到这个异常，则表示当前的`CyclicBarrier`已经破损了，可能系统已经没有办法等待所有线程到齐了。
如果继续等待，可能就是徒劳无功的。因此，还是就是散货，打道回府吧！

如果我们在上述代码中，插入以下代码，使得第5个士兵线程产生中断：
```java
if (i == 5) {
    allSoldier[0].interrupt();
}
```
如果这样做，我们很可能就会得到1个`InterruptedException`和9个`BrokenBarrierException`。
这个`InterruptedException`就是被中断线程抛出的。而其他9个`BrokenBarrierException`，
则是等待在当前`CyclicBarrier`上的线程抛出的。这个异常可以避免其他9个线程进行永久的，无谓的等待
（因为其中一个线程已经被中断，等待是没有结果的）。
