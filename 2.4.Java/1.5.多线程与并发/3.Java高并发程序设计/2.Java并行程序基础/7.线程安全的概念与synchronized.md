线程安全的概念与synchronized
=================================================
并行程序开发的一大关注重点就是线程安全。一般来说，程序并行化是为了获得更高的执行效率，但前提是，
高效率不能以牺牲正确性为代价。

下面的代码演示了一个计数器，两个线程同时对`i`进行累加操作，各执行10000000次。我们希望的执行结果当然
是最终i的值可以达到20000000。

我们必须保证多个线程在对`i`进行操作时完全同步。也就是说，当线程A在写入时，线程B不仅不能写，同时也不能读。
因为在线程A写完之前，线程B读取的一定是一个过期数据。Java中，提供了一个重要的关键字`synchronized`来
实现这个功能。

**关键字`synchronized`的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次，
只能有一个线程进入同步块，从而保证线程间的安全性**。

关键字`synchronized`可以有多种用法。这里做一个简单的整理：
+ **指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁**。
+ **直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁**。
+ **直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁 **。

示例代码：
```java
package test3;

public class AccountingSync implements Runnable {

    int i = 0;

    public static void main(String[] args) throws InterruptedException {
        AccountingSync instance = new AccountingSync();
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.printf("最后 %d", instance.i);
    }

    @Override
    public void run() {
        for (int j = 0; j < 10000000; j++) {
            increase();
        }
    }

    public synchronized void increase() {
        i++;
    }
}
```
**除了用于线程同步，确保线程安全外，`synchronized`还可以保证线程间的可见性和有序性**。从可见性的角度上讲，
`synchronized`可以完全替代`volatile`的功能，只是使用上没有那么方便。就有序性而言，由于`synchronized`
限制每次只有一个线程可以访问同步块，因此，无论同步块内的代码如何被乱序执行，只要保证串行语义一致，
那么执行结果总是一样的。而其他访问线程，又必须在获得锁后方能进入代码块读取数据，因此，它们看到的最终结果并不取
决于代码的执行过程，从而有序性问题自然得到了解决。
