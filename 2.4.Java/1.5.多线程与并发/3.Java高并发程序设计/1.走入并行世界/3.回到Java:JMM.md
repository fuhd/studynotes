回到Java:JMM（Java内存模型）
====================================================
由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序下数据访问的 **一致性** 和 **安全性** 将会受到严重挑战。
JMM的关键技术点都是围绕着多线程的 **原子性**，**可见性** 和 **有序性** 来建立的。

### 原子性（Atomicity）
原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

### 可见性（Visibility）
**可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改**。显然，对于串行程序来说，
可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，那么在后续的步骤中，读取这个变量的值，
一定是修改后的新值。

但是这个问题在并行程序中就不见得了。如果一个线程修改了某一个全局变量，那么其他线程未必可以马上知道这个改动。
如果CPU1和CPU2上各运行了一个线程，它们共享变量T，由于编译器优化或者硬件优化的缘故，在CPU1上的线程将变量t进行
了优化，将其缓存在cache中或者寄存器里。这种情况下，如果在CPU2上的某个线程修改了变量T的实际值，那么CPU1上
的线程可能并无法意识到这个改动，依然会读取cache中或者寄存器里的数据。因此，就产生了可见性问题。
外在表现为：变量T的值被修改，但是CPU1上的线程依然会取到一个旧值。可见性问题也是并行程序开发中需要重点关注的问题之一。

可见性问题是一个综合性问题。除了上述提到的缓存优化或者硬件优化（有些内存读写可能不会立即触发，
而会先进入一个硬件队列等待）会导致可见性问题外，指令重排以及编译器优化，都有可能导致一个线程的修改不会
立即被其他线程察觉。

### 有序性（Ordering）
有序性问题可能是三个问是中最难理解的了。对于一个线程的执行代码而言，我们总是习惯地认为代码的执行是从先往后，
依次执行的。这么理解也不能说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行
可能就会出现乱序。给人直观的感觉就是：写在前面的代码，会在后面执行。听起来有些不可思议，是吗？有序性问题
的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。

不过这里还需要强调一点，对于一个线程来说，它看到的指令执行顺序一定是一致的（否则的话我们的应用根本无法正常工作，
不是吗？）。也就是说指令重排是有一个基本前提的，就是保证串行语言的一致性，指令重排不会使串行的语言逻辑发生问题。
因此，在串行代码中，大可不必担心。

**注意：指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。

**为什么要指令重排呢？之所以那么做，完全是因为性能考虑**。一条指令的执行是可以分为很多步骤的，简单地说，
可以分为以下几步：
+ 取指 IF
+ 译码和取寄存器操作数 ID
+ 执行或者有效地址计算 EX
+ 存储器访问 MEM
+ 写回 WB

我们的汇编指令也不是一步就可以执行完毕的，在CPU中实际工作时，它还是需要分为多个步骤依次执行的。当然，
每个步骤所涉及的硬件也可能不同。比如，取指时会用到PC寄存器和存储器，译码时会用到指令寄存器组，
执行时会使用ALU，写回时需要寄存器组。

由于每一个步骤都可能使用不同的硬件完成，因此，聪明的工程师们就发明了流水线技术来执行指令。

有了流水线这个神器，我们CPU才能真正高效的执行，但是，别忘记了一点，流水线总是害怕被中断的。流水线满载时，
性能确实相当不错，但是一旦中断，所有的硬件设备都会进入一个停顿期，再次满载又需要几个周期，因此，性能损失会
比较大。所以，我们必须要想办法尽量不让流水线中断！

那么答案就来了，之所以需要做指令重排，就是为了尽量少的中断流水线。当然了，指令重排只是减少中断的一种技术，
实际上，在CPU的设计中，我们还会使用更多的软硬件技术来防止中断，不过对它们的讨论已经远远超出了这里讲述的范围。

由此可见，指令重排对于提高CPU处理性能是十分必要的。虽然确实带来了乱序的问题，但是这点牺牲是完全值得的。

### 哪些指令不能重排：Happen-Befor规则
虽然Java虚拟机和执行系统会对指令进行一定的重排，但是指令重排是有原则的，并非所有的指令都可以随便改变执行位置，
以下罗列了一些基本原则，这些原则是指令重排不可违背的：
+ 程序顺序原则：一个线程内保证语义的串行性；
+ volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性；
+ 锁规则：解锁（unlock）必然发生在随后的加锁（lock)前；
+ 传递性：A先于B，B先于C，那么A必然先于C；
+ 线程的start()方法先于它的每一个动作；
+ 线程的所有操作先于线程的终结（Thread.join()）；
+ 线程的中断（interrupt()）先于被中断线程的代码；
+ 对象的构造函数执行，结束先于`finalize()`方法；
