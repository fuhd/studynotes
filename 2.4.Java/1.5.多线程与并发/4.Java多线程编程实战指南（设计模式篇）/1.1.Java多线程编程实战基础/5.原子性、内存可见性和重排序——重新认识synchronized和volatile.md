原子性、内存可见性和重排序——重新认识synchronized和volatile
===============================================================================
**原子（`Atomic`）操作指相应的操作是单一不可分割的操作**。例如，对`int`型变量`count`执行`count++`的操作
就 **不是原子操作**。这是因为`count++`实际上可以分解为`3`个操作：
1. 读取变量`count`的当前值；
2. 拿`count`的当前值和`1`做加法运行；
3. 将`count`的当前值增加`1`后的值赋值给`count`变量；

在多线程环境中，非原子操作可能会受其他线程的干扰。比如，上述例子如果没有对相应的代码进行同步（`Synchronization`）处理，
则可能出现在执行第`2`个操作的时候`count`的值已经被其他线程修改了，因此这一步的操作所使用的`count`变量的“当前值”
其实已经是过期的了。当然，**`synchronized`关键字可以帮助我们实现操作的原子性，以避免这种线程间的干扰情况**。

**`synchronized`关键字可以实现操作的原子性，其本质是通过该关键字所包括的临界区（`Critical Section`）的排他性
保证在任何一个时刻只有一个线程能够执行临界区中的代码，这使得临界区中的代码代表了一个原子操作**。这一点，读者可能已经
很清楚。但是，**`synchronized`关键字所起的另外一个作用————保证内存的可见性（`Memory Visibility`）**，也是值得我们
回顾的。

**`CPU`在执行代码的时候，为了减少变量访问的时间消耗可能将代码中访问的变量的值缓存到该`CPU`的缓存区（如`L1 Cache`、
`L2 Cache`等）中。因此相应代码再次访问某个变量时，相应的值可能是从`CPU`缓存区而不是主内存中读取的。同样地，代码对这些
被缓存过的变量的值的修改也可能仅是被写入`CPU`缓存区，而没有被写回主内存。由于每个`CPU`都有自己的缓存区，因此一个
`CPU`缓存区中的内容对于其他`CPU`而言是不可见的。这就导致了在其他`CPU`上运行的其他线程可能无法“看到”该线程对某个变量值
所做的更改。这就是所谓的内存可见性**。







