原子性、内存可见性和重排序——重新认识synchronized和volatile
===============================================================================
**原子（`Atomic`）操作指相应的操作是单一不可分割的操作**。例如，对`int`型变量`count`执行`count++`的操作
就 **不是原子操作**。这是因为`count++`实际上可以分解为`3`个操作：
1. 读取变量`count`的当前值；
2. 拿`count`的当前值和`1`做加法运行；
3. 将`count`的当前值增加`1`后的值赋值给`count`变量；

在多线程环境中，非原子操作可能会受其他线程的干扰。比如，上述例子如果没有对相应的代码进行同步（`Synchronization`）处理，
则可能出现在执行第`2`个操作的时候`count`的值已经被其他线程修改了，因此这一步的操作所使用的`count`变量的“当前值”
其实已经是过期的了。当然，**`synchronized`关键字可以帮助我们实现操作的原子性，以避免这种线程间的干扰情况**。

**`synchronized`关键字可以实现操作的原子性，其本质是通过该关键字所包括的临界区（`Critical Section`）的排他性
保证在任何一个时刻只有一个线程能够执行临界区中的代码，这使得临界区中的代码代表了一个原子操作**。这一点，读者可能已经
很清楚。


