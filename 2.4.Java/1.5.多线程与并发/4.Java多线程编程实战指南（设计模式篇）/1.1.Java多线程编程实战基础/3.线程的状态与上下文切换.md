线程的状态与上下文切换
====================================================================
`Java`语言中，一个线程从其创建、启动到其运行结束的整个生命周期可能经历若干个状态。

`Java`线程的状态可以通过调用相应`Thread`实例的`getState`方法获取。该方法的返回值类型`Thread.State`
是一个枚举类型（`Enum`）。`Thread.State`所定义的线程状态包括以下几种：
+ **`NEW`**：一个刚创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态。
+ **`RUNNABLE`**：该状态可以看成是一个复合的状态。它包括两个子状态：`READY`和`RUNNING`。前者表示处于该状态的线程可
以被`JVM`的线程调度器（`Scheduler`）进行调度而使之处于`RUNNING`状态。后者表示处于该状态的线程正在运行，即相应线程对象
的`run`方法中的代码所对应的指令正在由`CPU`执行。**当`Thread`实例的`yield`方法被调用时或者由于线程调度器的原因，相应线程
的状态会由`RUNNIG`转换为`READY`**。
+ **`BLOCKED`**：一个线程发起一个阻塞式`I/O`（`Blocking I/O`）操作后，或者试图去获得一个由其他线程持有的锁时，
相应的线程会处于该状态。**处于该状态的线程并不会占用`CPU`资源**。当相应的`I/O`操作完成后，或者相应的锁被其他线程释放后，
该线程的状态又可以转换为`RUNNABLE`。
+ **`WAITING`**：一个线程执行了某些方法调用之后就会处于这种无限等待其他线程执行特定操作的状态。这些方法包括：`Object.wait()`、
`Thread.join()`和`LockSupport.park()`。能够使相应线程从`WAITING`转换到`RUNNABLE`的相应方法包括：
`Object.notify()`、`Object.notifyAll()`和`LockSupport.unpark(thread)`。
+ **`TIMED_WAITING`**：该状态和`WAITING`类似，差别在于处于该状态的线程并非无限等待其他线程执行特定操作，
而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为`RUNNABLE`。
+ **`TERMINATED`**：已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于
该状态。`Thread`实例的`run`方法正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。

从上述描述可知，**一个线程在其整个生命周期中，只可能一次处于`NEW`状态和`TERMINATED`状态。而一个线程的状态从`RUNNABLE`
状态转换为`BLOCKED`、`WAITING`和`TIMED_WAITING`这几个状态中的任何一个状态都意味着上下文切换的产生**。

**上下文切换类似于我们接听手机电话的场景**。比如，当我们正在接听一个电话并与对方讨论某件事情的时候，这时突然有另外一个来电。
通常这个时候我们会跟对方说：“我先接个电话，你别挂断”，并记下与之的讨论进行到什么程度了。然后，接听新的来电并告诉对方稍后
会回拨并将该来电挂断。接着，我们又继续先前的讨论。如果在接听新来电之前，我们没有特意记下当前的讨论进展到什么程度，
等我们接听新的来电后再回过头继续讨论时可能得问对方“刚才我们讲到哪里了”这样的问题。

多线程环境中，当一个线程的状态由`RUNNABLE`转换为非`RUNNABLE`（`BLOCKED`、`WAITING`或者`TIMED_WAITING`）时，
相应线程的上下文信息（即所谓的`Context`，**包括`CPU`的寄存器和程序计数器在某一时间点的内容等**）需要被保存，
以便相应线程稍后再次进入`RUNNABLE`状态时能够在之前的执行进度的基础上继续前进。**而一个线程的状态由非`RUNNABLE`状态
进入`RUNNABLE`状态时可能涉及恢复之前保存的线程上下文信息并在此基础上前进。这个对线程的上下文信息进行保存和恢复的过程
就被称为上下文切换**。

**上下文切换会带来额外的开销，这包括保存和恢复线程上下文信息的开销、对线程进行调度的`CPU`时间开销以及`CPU`缓存内容失效
（即`CPU`的`L1 Cache`、`L2 Cache`等）的开销**。

在`Linux`平台下，我们 **可以使用`perf`命令来监视`Java`程序运行过程中的上下文切换情况**。例如，我们可以使用`perf`命令来监视
如下清单所示的程序的运行，相应的命令如下：
```shell
$ perf stat -e cpu-clock,task-clock,cs,cache-references,cache-misses java JavaThreadCreationAndRun
```
上述命令中，**参数`e`的值中的`cs`表示要监视被监视程序的上下文切换的数量**。上述命令执行后输出的内容类似如下：
```shell
73.719681 cpu-clock (msec)
73.704906 task-clock (msec)         # 0.956 CPUs utilized
434 cs                              # 0.006 M/sec
2,361,905 cache-references          # 32.045 M/sec
419,134 cache-misses                # 17.746 % of all cache refs

0.077060925 seconds time elapsed
```
由此可见，上述运行一共产生了`434`次上下文切换。












