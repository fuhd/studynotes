线程的状态与上下文切换
====================================================================
`Java`语言中，一个线程从其创建、启动到其运行结束的整个生命周期可能经历若干个状态。

`Java`线程的状态可以通过调用相应`Thread`实例的`getState`方法获取。该方法的返回值类型`Thread.State`
是一个枚举类型（`Enum`）。`Thread.State`所定义的线程状态包括以下几种：
+ **`NEW`**：一个刚创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态。
+ **`RUNNABLE`**：该状态可以看成是一个复合的状态。它包括两个子状态：`READY`和`RUNNING`。前者表示处于该状态的线程可
以被`JVM`的线程调度器（`Scheduler`）进行调度而使之处于`RUNNING`状态。后者表示处于该状态的线程正在运行，即相应线程对象
的`run`方法中的代码所对应的指令正在由`CPU`执行。**当`Thread`实例的`yield`方法被调用时或者由于线程调度器的原因，相应线程
的状态会由`RUNNIG`转换为`READY`**。
+ **`BLOCKED`**：一个线程发起一个阻塞式`I/O`（`Blocking I/O`）操作后，或者试图去获得一个由其他线程持有的锁时，
相应的线程会处于该状态。**处于该状态的线程并不会占用`CPU`资源**。当相应的`I/O`操作完成后，或者相应的锁被其他线程释放后，
该线程的状态又可以转换为`RUNNABLE`。
+ **`WAITING`**：一个线程执行了某些方法调用之后就会处于这种无限等待其他线程执行特定操作的状态。这些方法包括：`Object.wait()`、
`Thread.join()`和`LockSupport.park()`。能够使相应线程从`WAITING`转换到`RUNNABLE`的相应方法包括：
`Object.notify()`、`Object.notifyAll()`和`LockSupport.unpark(thread)`。
+ **`TIMED_WAITING`**：该状态和`WAITING`类似，差别在于处于该状态的线程并非无限等待其他线程执行特定操作，
而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为`RUNNABLE`。
+ 