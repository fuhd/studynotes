异常处理
=======================================================
`HttpClient`会被抛出 **两种类型的异常**，一种是 **`java.io.IOException`**，当遇到`I/O`异常时抛出
（`socket`超时，或者`socket`被重置）;另一种是 **`HttpException`**，表示`Http`失败，如`Http`协议使用不正确。
通常认为，`I/O`错误时不致命、可修复的，而`Http`协议错误是致命了，不能自动修复的错误。

### HTTP传输安全
**`Http`协议不能满足所有类型的应用场景**，我们需要知道这点。Http是个简单的面向协议的请求/响应的协议，
当初它被设计用来支持静态或者动态生成的内容检索，之前从来没有人想过让它支持事务性操作。例如，Http服务器成功接收、
处理请求后，生成响应消息，并且把状态码发送给客户端，这个过程是`Http`协议应该保证的。但是，如果客户端由于读取超时、
取消请求或者系统崩溃导致接收响应失败，服务器不会回滚这一事务。如果客户端重新发送这个请求，服务器就会重复的解析、
执行这个事务。在一些情况下，这会导致应用程序的数据损坏和应用程序的状态不一致。

即使`Http`当初设计是 **不支持事务操作**，但是它仍旧可以作为传输协议为某些关键程序提供服务。**为了保证`Http`传输层的安全性，
系统必须保证应用层上的`http`方法的幂等性**。

### 方法的幂等性
`HTTP/1.1`规范中是这样定义 **幂等方法** 的：
```
Methods can also have the property of “idempotence” in that (aside from error or expiration issues)
the side-effects of N > 0 identical requests is the same as for a single request。
```
用其他话来说，**应用程序需要正确地处理同一方法多次执行造成的影响**。添加一个具有唯一性的id就能避免重复执行同一个逻辑请求，
问题解决。

请知晓，**这个问题不只是`HttpClient`才会有**，基于浏览器的应用程序也会遇到`Http`方法不幂等的问题。

**`HttpClient`默认把非实体方法`get`、`head`方法看做幂等方法，把实体方法`post`、`put`方法看做非幂等方法**。

### 异常自动修复
**默认情况下，`HttpClient`会尝试自动修复`I/O`异常。这种自动修复仅限于修复几个公认安全的异常**。
+ `HttpClient`不会尝试修复任何逻辑或者`http`协议错误（即从`HttpException`衍生出来的异常）。
+ `HttpClient`会自动再次发送幂等的方法（如果首次执行失败)。
+ `HttpClient`会自动再次发送遇到`transport`异常的方法，前提是`Http`请求仍旧保持着连接
（例如`http`请求没有全部发送给目标服务器，`HttpClient`会再次尝试发送）。

### 请求重试Handler
如果要 **自定义异常处理机制**，我们需要实现 **HttpRequestRetryHandler** 接口。示例：
```java
HttpRequestRetryHandler myRetryHandler = new HttpRequestRetryHandler() {  
    public boolean retryRequest(IOException exception,int executionCount,HttpContext context) {  
        if (executionCount >= 5) {  
            // Do not retry if over max retry count  
            return false;  
        }  
        if (exception instanceof InterruptedIOException) {  
            // Timeout  
            return false;  
        }  
        if (exception instanceof UnknownHostException) {  
            // Unknown host  
            return false;  
        }  
        if (exception instanceof ConnectTimeoutException) {  
            // Connection refused  
            return false;  
        }  
        if (exception instanceof SSLException) {  
            // SSL handshake exception  
            return false;  
        }  
        HttpClientContext clientContext = HttpClientContext.adapt(context);  
        HttpRequest request = clientContext.getRequest();  
        boolean idempotent = !(request instanceof HttpEntityEnclosingRequest);  
        if (idempotent) {  
            // Retry if the request is considered idempotent  
            return true;  
        }  
        return false;  
    }  
};  
CloseableHttpClient httpclient = HttpClients
        .custom()
        .setRetryHandler(myRetryHandler)  
        .build();
```
