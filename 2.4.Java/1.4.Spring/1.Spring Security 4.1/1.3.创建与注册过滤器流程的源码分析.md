创建与注册过滤器流程的源码分析
================================================================================
### 过滤器创建流程的源码分析
当我们在 **任意一个类** 上添加了一个注解 **`@EnableWebSecurity`**，就可以创建一个名为 **`springSecurityFilterChain`**的Filter。
在上一节中，我们是在一个自定义的`SecurityConfig`类上加了这个注解。`SecurityConfig`类同时也继承了`WebSecurityConfigurerAdapter`类，
不过需要注意的是，这个过滤器的创建是通过`@EnableWebSecurity`完成的，与是否继承这个类无关。关于`WebSecurityConfigurerAdapter`这个类我们
在后面会详细讲解，目前所需知道的是，即使我们自定义的类，不继承这个类，也可以自动帮我们创建一个`Filter`。

我们带着2个问题来考虑这个名字为`springSecurityFilterChain`的`Filter`的创建过程:
1. 这个`Filter`是在哪里创建的?
2. 这个`Filter`的实现类是什么?

#### springSecurityFilterChain过滤器的创建的位置
为什么在一个类上添加一个`@EnableWebSecurity`注解后，就可以自动创建一个`Filter`呢？我们首先看一下`@EnableWebSecurity`的源码：
```java
@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
@Target(value = { java.lang.annotation.ElementType.TYPE })
@Documented
@Import({ WebSecurityConfiguration.class, ObjectPostProcessorConfiguration.class,SpringWebMvcImportSelector.class })
@EnableGlobalAuthentication
@Configuration
public @interface EnableWebSecurity {
    /**
    * Controls debugging support for Spring Security. Default is false.
    * @return if true, enables debug support with Spring Security
    */
    boolean debug() default false;
}
```