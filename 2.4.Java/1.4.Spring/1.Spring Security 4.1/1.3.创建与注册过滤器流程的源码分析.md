创建与注册过滤器流程的源码分析
================================================================================
### 过滤器创建流程的源码分析
当我们在 **任意一个类** 上添加了一个注解 **`@EnableWebSecurity`**，就可以创建一个名为 **`springSecurityFilterChain`**的Filter。
在上一节中，我们是在一个自定义的`SecurityConfig`类上加了这个注解。`SecurityConfig`类同时也继承了`WebSecurityConfigurerAdapter`类，
不过需要注意的是，这个过滤器的创建是通过`@EnableWebSecurity`完成的，与是否继承这个类无关。关于`WebSecurityConfigurerAdapter`这个类我们
在后面会详细讲解，目前所需知道的是，即使我们自定义的类，不继承这个类，也可以自动帮我们创建一个`Filter`。

我们带着2个问题来考虑这个名字为`springSecurityFilterChain`的`Filter`的创建过程:
1. 这个`Filter`是在哪里创建的?
2. 这个`Filter`的实现类是什么?

#### springSecurityFilterChain过滤器的创建的位置
为什么在一个类上添加一个`@EnableWebSecurity`注解后，就可以自动创建一个`Filter`呢？我们首先看一下`@EnableWebSecurity`的源码：
```java
@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
@Target(value = { java.lang.annotation.ElementType.TYPE })
@Documented
@Import({ WebSecurityConfiguration.class, ObjectPostProcessorConfiguration.class,SpringWebMvcImportSelector.class })
@EnableGlobalAuthentication
@Configuration
public @interface EnableWebSecurity {
    /**
    * Controls debugging support for Spring Security. Default is false.
    * @return if true, enables debug support with Spring Security
    */
    boolean debug() default false;
}
```
可以看到，这个注解上面加了`@Configuration`、`@EnableGlobalAuthentication`、`@Import`三个注解，因此，当我们把这个注解加在某个类之上，
就相当于在这个类上面同时加上了这三个注解。我们将这个注解加在`SecurityConfig`类上，意味着相当于在`SecurityConfig`类上加上了这个三个注解。

其中`@Import`这个注解中导入了三个配置类：`WebSecurityConfiguration` 、`ObjectPostProcessorConfiguration` 、
`SpringWebMvcImportSelector`，我们的`Filter`实际上就是由 **`WebSecurityConfiguration`** 这个类创建，查看其核心部分源码：
```java
@Configuration
public class WebSecurityConfiguration implements ImportAware, BeanClassLoaderAware {
    private WebSecurity webSecurity;
    ....
    private List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers;
    ....
     
    //创建一个名为springSecurityFilterChain的Filter
    @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)
    public Filter springSecurityFilterChain() throws Exception {
        boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty();
        if (!hasConfigurers) {
        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor.postProcess(
            new WebSecurityConfigurerAdapter() {}
        );
        webSecurity.apply(adapter);
    }
    return webSecurity.build();
    }
    ....
}
```
可以看到这个配置类中生成了一个名字为`AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME`的`Filter`
(读者目前不要过多关注实现细节，后面会详细讲解)，这是一个静态常量，其定义如下：
```java
public abstract class AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer {
     
    ....
    public static final String DEFAULT_FILTER_NAME = "springSecurityFilterChain";
    ....
}
```
因此，这段配置的作用实际上是，创建一个`Spring Bean`，`Bean`的类型是`Filter`，名字为`springSecurityFilterChain`。
只要我们保证自定义的`SecuirtyConfig`类，可以被`Spring`扫描到，就可以帮助我们创建这个`Filter`了。 

#### springSecurityFilterChain过滤器的类型是什么
在上面的分析中，我们可以看到`Filter`的创建时通过`WebSecurity`对象的`build`方法完成的。我们先看一下`WebSecurity`对象的部分文档注释：
```
The WebSecurity is created by WebSecurityConfiguration to create the FilterChainProxy known as the Spring Security Filter Chain (springSecurityFilterChain). 
```
这段话大致的意思是，`WebSecurity`由`WebSecurityConfiguration`创建，而`WebSecurity`的作用是用于创建一个类型为`FilterChainProxy`的过滤器，
`FilterChainProxy`是`Filter`的子类，我们所说的创建一个名字为**`springSecurityFilterChain`**的过滤器，实际上过滤器的具体类型就是**`FilterChainProxy`**。

