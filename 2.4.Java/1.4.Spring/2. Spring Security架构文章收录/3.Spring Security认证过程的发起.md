Spring Security认证过程的发起
==================================================================================
### 发起的条件
用户访问资源时，发生 **授权异常（`AuthenticationException`）或认证异常（AccessDeniedException）**，
`ExceptionTranslationFilter`通过调用`AuthenticationEntryPoint`的`commence`方法发起认证过程。
如果`ExceptionTranslationFilter`接收到的是授权异常，并且当前认证过的票据不是匿名票据（`AnonymousAuthenticationToken`），
将不会发起认证过程，而是交给`AccessDeniedHandler`处理（一般会直接提示用户拒绝访问）。

### 发起过程
发起认证之前，`Spring Security`会将用户之前的请求信息保存在`session`里。还会清空`SecurityContextHolder`中的票据。
**`AuthenticationEntryPoint`将用户定向到认证的入口**，收集认证信息。认证入口一般是个页面，需要用户输入用户名和密码，
也有其他方式的入口。收集到认证信息之后，重新提交认证请求。认证信息会再次通过过滤器，由`AuthenticationManager`认证。
**`AuthenticationEntryPoint`是用户提供凭证的入口**，真正的认证是由过滤器来完成。（但是`DigestProcessingFilter`的实现，
是直接使用了一个`userDetailsService`，这是个特例并且这个过滤器也没有继承`SpringSecurityFilter`）。

### AuthenticationEntryPoint的实现
下面是`Spring Security`提供的几个`AuthenticationEntryPoint`的实现。

#### AuthenticationProcessingFilterEntryPoint
**会生成一个用于认证的表单，收集认证信息**。生成的页面的`URL`缺省值是`/j_spring_security_check`，可以配置自己指定的`URL`。
只有以这个`URL`结尾的请求收集上来的认证信息，才会被`AuthenticationProcessingFilter`用来认证。
用户提交的用户名和密码之后转交`AuthenticationManager`处理认证。

#### BasicProcessingFilterEntryPoint
将会向浏览器发送一个`RFC2616`规定的`basic`认证头信息。浏览器在识别到认证头之后，会弹出对话框，收集用户名和密码。
浏览器会将收集到的用户名和密码，打包成`RFC`标准的认证响应，发送到服务器。在下一次请求到达`BasicProcessingFilter`时，
过滤器会提取认证信息，并由`AuthenticationManager`处理认证。

#### DigestProcessingFilterEntryPoint
和`Basic`认证类似，会向浏览器发送一个`RFC2616`标准的`digest`认证头信息。浏览器在收到认证头后，会弹出对话框，
收集用户名和密码。浏览器会将收集到的用户名和密码，打包成`RFC`标准的认证响应，发送到服务器。
在下一次请求到达`DigestProcessingFilter`时，过滤器会提取认证信息，并由`AuthenticationManager`处理认证。

#### PreAuthenticatedProcessingFilterEntryPoint
简单的向浏览器发送一个错误页面，不做任何处理。
