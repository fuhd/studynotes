写入Ringbuffer
================================================================================
本文的重点是：**不要让Ring重叠；如何通知消费者；生产者一端的批处理；以及多个生产者如何协同工作**。

## ProducerBarriers
**Disruptor代码给消费者提供了一些接口和辅助类，但是没有给写入Ring Buffer的生产者提供接口。这是
因为除了你需要知道生产者之外，没有别人需要访问它**。尽管如此，Ring Buffer还是与消费端一样提供了一
个 **ProducerBarrier** 对象，让生产者通过它来写入Ring Buffer。

**写入Ring Buffer的过程涉及到两阶段提交**（`two-phase commit`）。**首先，你的生产者需要申请
buffer里的下一个节点。然后，当生产者向节点写完数据，它将会调用ProducerBarrier的commit方法**。

那么让我们首先来看看第一步。“**给我Ring Buffer里的下一个节点**”，这句话听起来很简单。的确，从生
产者角度来看它很简单：**简单地调用ProducerBarrier的nextEntry()方法**，这样会返回给你一个Entry
对象，这个对象就是Ring Buffer的下一个节点。

## ProducerBarrier如何防止Ring Buffer重叠
在后台，由`ProducerBarrier`负责所有的交互细节来从Ring Buffer中找到下一个节点，然后才允许生产
者向它写入数据。

![Ringbuffer生产者图1](img/7.png)

在这幅图中，我们假设只有一个生产者写入Ring Buffer。过一会儿我们再处理多个生产者的复杂问题。

**ConsumerTrackingProducerBarrier对象拥有所有正在访问Ring Buffer的消费者列表**。这看起来
有点儿奇怪－我从没有期望ProducerBarrier了解任何有关消费端那边的事情。但是等等，这是有原因的。
因为我们不想与队列“混为一谈”（队列需要追踪队列的头和尾，它们有时候会指向相同的位置），**Disruptor
由消费者负责通知它们处理到了哪个序列号，而不是Ring Buffer。所以，如果我们想确定我们没有让
Ring Buffer重叠，需要检查所有的消费者们都读到了哪里**。

在上图中，有一个消费者顺利的读到了最大序号`12`（用 **红色/粉色高亮**）。第二个消费者有点儿落后——
可能它在做`I/O`操作之类的——它停在序号`3`。因此消费者`2`在赶上消费者`1`之前要跑完整个`Ring Buffer`
一圈的距离。

**现在生产者想要写入Ring Buffer中序号3占据的节点，因为它是Ring Buffer当前游标的下一个节点。但是
ProducerBarrier明白现在不能写入，因为有一个消费者正在占用它。所以，ProducerBarrier停下来自旋
(spins)，等待，直到那个消费者离开**。

## 申请下一个节点
现在可以想像消费者`2`已经处理完了一批节点，并且向前移动了它的序号。可能它挪到了序号`9`（因为消费端
的批处理方式，现实中我会预计它到达`12`，但那样的话这个例子就不够有趣了）。

![Ringbuffer生产者图2](img/8.png)

上图显示了当消费者`2`挪动到序号`9`时发生的情况。在这张图中我已经忽略了`ConsumerBarrier`，因为它
没有参与这个场景。

`ProducerBarier`会看到下一个节点——序号`3`那个已经可以用了。它会抢占这个节点上的`Entry`（我还没
有特别介绍 **Entry对象，基本上它是一个放写入到某个序号的Ring Buffer数据的桶**），把下一个序号`13`
更新成`Entry`的序号，然后把`Entry`返回给生产者。生产者可以接着往`Entry`里写入数据。

## 提交新的数据
两阶段提交的第二步是——对，**提交**。

![Ringbuffer生产者图3](img/9.png)

绿色表示最近写入的`Entry`，序号是`13`。当生产者结束向`Entry`写入数据后，它会要求`ProducerBarrier`
提交。`ProducerBarrier`先等待`Ring Buffer`的游标追上当前的位置（对于单生产者这毫无意义－比如，
我们已经知道游标到了`12`，而且没有其他人正在写入`Ring Buffer`）。然后`ProducerBarrier`更新
`Ring Buffer`的游标到刚才写入的`Entry`序号－在我们这儿是`13`。接下来，`ProducerBarrier`会让消费
者知道`buffer`中有新东西了。它戳一下`ConsumerBarrier`上的`WaitStrategy`对象说－“喂，醒醒！有事
情发生了！”（注意－不同的`WaitStrategy`实现以不同的方式来实现提醒，取决于它是否采用阻塞模式。）

现在消费者`1`可以读`Entry 13`的数据，消费者`2`可以读`Entry 13`以及前面的所有数据，然后它们都过
得很`happy`。

## ProducerBarrier上的批处理
有趣的是 **Disruptor可以同时在生产者和消费者​两端实现批处理**。还记得伴随着程序运行，消费者`2`最后
达到了序号`9`吗？**ProducerBarrier可以在这里做一件很狡猾的事－它知道Ring Buffer的大小，也知道最
慢的消费者位置。因此它能够发现当前有哪些节点是可用的**。

![Ringbuffer生产者图4](img/10.png)

如果`ProducerBarrier`知道`Ring Buffer`的游标指向`12`，而最慢的消费者在`9`的位置，它就可以让
生产者写入节点`3`，`4`，`5`，`6`，`7`和`8`，中间不需要再次检查消费者的位置。








































ddd
