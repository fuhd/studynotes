对付啰嗦
================================================================================
目前，当要把新的行为传递给`filterApples`方法的时候，你不得不声明好几个实现`ApplePredicate`
接口的类，然后实例化好几个只会提到一次的`ApplePredicate`对象。这真的很啰嗦，很费时间！
```java
//行为参数化，用谓词筛选苹果
public class AppleHeavyWeightPredicate implements ApplePredicate {
  public boolean test(Apple apple) {
    return apple.getWeight() > 150;
  }
}
public class AppleGreenColorPredicate implements ApplePredicate {
  public boolean test(Apple apple) {
    return "green".equals(apple.getColor());
  }
}
public class FilteringApples {
  public static void main(String... args) {
    List<Apple> inventory = Arrays.asList(
      new Apple(80, "green"),
      new Apple(155, "green"),
      new Apple(120, "red"));
    List<Apple> heavyAppples = filterApples(inventory, new AppleHeavyWeightPredicate());
    List<Apple> greenApples = filterApples(inventory, new AppleGreenColorPredicate());
  }
  public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory) {
      if(p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }
}
```
费这么大劲儿真没必要，能不能做得更好呢？Java有一个机制称为匿名类。它可以让你同时声明和实例化一个
类。它可以帮助你进一步改善代码，让它变得更简洁。

## 1.第五次尝试：使用匿名类
下面的代码展示了如何通过创建一个用 **匿名类** 实现`ApplePredicate`的对象，重定筛选的例子：
```java
List<Apple> redApples = filterApples(inventory, new ApplePredicate(){
  public boolean test(Apple apple) {
    return "red".equals(apple.getColor());
  }
});
```
但匿名类还是不够好。

在理想的情况下，我们想鼓励程序员使用行为参数化模式，因为正如你在前面看到的，它让代码更能适应需求的
变化。**Java8的语言设计者通过引用Lambda表达式————一种更简洁的传递代码的方式————解决了这个问题**。

## 2.第六次尝试：使用Lambda表达式
上面的代码在Java8里可以用Lambda表达式重写为下面的样子：
```java
List<Apple> result = filterApples(inventory, (Apple apple) -> "red".equals(apple.getColor()));
```
不得不承认这代码看上去比先前干净很多，它看起来更像问题陈述本身了。

## 3.第七次尝试：将List类型抽象化
在通往抽象的路上，我们还可以更进一步。目前，`filterApples`方法还只适用于Apple。**你还可以将
List类型抽象化，从而超越你眼前要处理的问题**：
```java
public interface Predicate<T> {
  boolean test(T t);
}
//引入类型参数T
public static <T> List<T> filter(List<T> list, Predicate<T> p) {
  List<T> result = new ArrayList<>();
  for(T e: list) {
    if(p.test(e)) {
      result.add(e);
    }
  }
  return result;
}
```































dd
