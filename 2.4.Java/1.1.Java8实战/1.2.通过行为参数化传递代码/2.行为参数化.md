行为参数化
================================================================================
在上一节中已经看到了，你需要一种比添加很多参数更好的方法来应对变化的需求。让我们后退一步来看看更
高层次的抽象。一种可能的解决方案是对你的选择标准建模：你考虑的是苹果，需要根据Apple的某些属性（
比如它是绿色的吗？重量超过150克吗？）来返回一个`boolean`值。我们把它称为 **谓词**（ **即一个
返回`boolean`值的函数**）。让我们定义一个接口来对选择标准建模：
```java
public interface ApplePredicate {
  boolean test(Apple apple);
}
```
现在你就可以用ApplePredicate的多个实现代表不同的选择标准了，如：
```java
public class AppleHeavyWeightPredicate implements ApplePredicate {
  public boolean  test(Apple apple) {
    return apple.getWeight() > 150;
  }
}

public class AppleGreenColorPredicate implements ApplePredicate {
  public boolean test(Apple apple) {
    return "green".equals(apple.getColor());
  }
}
```
你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”相关，它让你定义一族算法，
把它封装起来（称为”策略“），然后在运行时选择一个算法。在这里，算法族就是applePredicate，不同的
策略就是AppliHeavyWeightPrediate和AppleGreenColorPredicate。

但是，该怎么利用applePredicate的不同实现呢？你需要filterApples方法接受appliPredicate对象，
对Apple做条件测试。**这就是行为参数化：让方法接受多种行为（或战略）作为参数，并在内部使用，来完
成不同的行为**。

## 第四次尝试：根据抽象条件筛选
利用ApplePredicate改过之后，filter方法看起来是这样的：
```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
  List<Apple> result = new ArrayList<>();
  for(Apple apple: inventory) {
    if(p.test(apple)) {
      result.add(apple);
    }
  }
  return result;
}
```

### 1.传递代码/行为
这段代码比我们第一次尝试的时候灵活多了，现在你可以创建不同的ApplePredicate对象，并将它们传递给
filterApples方法。比如，如果农民让你找出所有重量超过150克的红苹果，你只需要创建一个类来实现
ApplePredicate就行了。
```java
public class AppleRedAndHeavyPredicate implements ApplePredicate {
  public boolean test(Apple apple) {
    return "red".equals(apple.getColor()) && apple.getWeight() > 150;
  }
}

List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate());
```
你已经做成了一件很酷的事：filterApples方法的行为取决于你通过ApplePredicate对象传递的代码。换
句话说，**你把filterApples方法的行为参数化了**！

请注意，在上一个例子中，唯一重要的代码是test方法的实现，正是它定义了filterApples方法的新行为。
但令人遗憾的是，由于该filterApples方法只能接受对象，所以你必须把代码包裹在ApplePredicate对象
里。你的做法类似于在内联“传递代码”，因为你是通过一个实现了test方法的对象来传递布尔表达式的。你将
在下一节中看到，**通过使用Lambda，你可以直接把表达式**:
```java
"red".equals(apple.getColor()) && apple.getWeight() > 150
```
**传递给filterApples方法，而无需定义多个ApplePredicate类，从而去掉不必要的代码**。

### 2.多种行为，一个参数
正如我们先前解释的那样，**行为参数化的好处在于你可以把迭代要筛选的集合的逻辑与对集合中每个元素应
用的行为区分开来。这样你可以重复使用同一个方法，给它不同的行为来达到不同的目的**。
