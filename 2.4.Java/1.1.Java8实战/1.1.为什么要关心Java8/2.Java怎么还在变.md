Java怎么还在变
===============================================================
编程语言就像生态系统一样，新的语言会出现，旧语言则被取代，除非它们不断演变。我们都希望出现一种
完㺯的通用语言，可在现实中，某些语言只是更适合某些方面。比如，`C`和`C++`仍然是构建操作系统和
各种嵌入式系统的流行工具，因为它们编写出的程序尽管安全性不佳，但运行时占用资源少。缺乏安全性可
能导致程序意外崩溃，并把安全漏洞暴露给病毒和其他东西；确实，`Java`和`C#`等安全型语言在诸多运行
资源不太紧张的应用中已经取代了`C`和`C++`。

在过去15年的时间里，`Java`已经成功地霸占了编程生态系统中的一大块，同时替代了竞争对手语言。
让我们来看看其中的原因。

### Java在编程语言生态系统中的位置
**`Java`虚拟机（`JVM`）及其字节码可能会变得比`Java`语言本身更重要**，而且对于某些应用来说，
`Java`可能会被同样运行在`JVM`上的竞争对手语言（如`Scala`或`Groovy`）取代。`JVM`各种最新的更新
（例如`JDK7`中的新`invokedynamic`字节码）旨在帮助这些竞争对手语言在`JVM`上顺利运行，并与`Java`互操作。

编程语言生态系统的气候正在变化。程序员越来越多地要处理 **所谓的大数据**（数百万兆甚至更多字节的数据集），
并希望利用多核计算机或计算集群来有效地处理。这意味着 **需要使用并行处理**————`Java`以前对此并不支持。

`Java8`对于程序员的主要好处在于它提供了 **更多的编程工具和概念**，能以更快，更重要的是能以 **更为简洁、更易维护
的方式** 解决新的或现有的编程问题。虽然这些概念对于`Java`来说是新的，但是研究型的语言已经证明了它们的强大。
我们会突出并探讨三个这样的编程概念背后的思想，**它们促使`Java8`中开发出并行和编写更简洁通用代码的功能**。

### 流处理
第一个编程概念是 **流处理**。介绍一下，**流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，
然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流**。

一个实际的例子是在`Unix`或`Linux`中，很多程序都从标准输入（`Unix`和`C`中的`stdin`，`Java`中的`System.in`）
读取数据，然后把结果写入标准输出（`Unix`和`C`中的`stdout`，`Java`中的`System.out`）。首先我们来看一点点背景：
`Unix`的`cat`命令会把两个文件连接起来创建一个流，`tr`会转换流中的字符，`sort`会对流中的行进行排序，而`tail -3`
则给出流的最后3行。**`Unix`命令行允许这些程序通过管道（`|`）连接在一起**，比如
```shell
$ cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```
会（假设`file1`和`file2`中每行都只有一个词）先把字母转换成小写字母，然后打印出按照词典排序出现在最后的三个单词。
我们说`sort`把一个行流作为输入，产生了另一个行流（进行排序）作为输出。**请注意在`Unix`中，命令（`cat`、`tr`、`sort`
和`tail`）是同时执行的，这样`sort`就可以在`cat`或`tr`完成前先处理头几行**。

基于这一思想，`Java8`在`java.util.stream`中添加了一个`Stream API`；`Stream<T>`就是一系列`T`类型的项目。
**你现在可以把它看成一种比较花哨的迭代器。`Stream API`的很多方法可以链接起来形成一个复杂的流水线**，就像先前例子里面
链接起来的`Unix`命令一样。

推动这种做法的关键在于，**现在你可以在一个更高的抽象层次上写`java8`程序了**：思路变成了 **把这样的流变成那样的流**，
而不是一次只处理一个项目。另一个好处是，**`Java8`可以透明地把输入的不相关部分拿到几个`CPU`内核上去分别执行你的`Stream`
操作流水线————这是几乎免费的并行**，用不着去费劲搞`Thread`了。

### 用行为参数化把代码传递给方法
`java8`中增加的另一个编程概念是通过API来传递代码的能力。**`java8`增加了把方法（你的代码）作为参数传递给另一个方法的能力**。
我们把这一概念称为 **行为参数化**。它的重要之处在哪儿呢？`Stream API`就是构建在通过传递代码使操作行为实现参数化的思想上的。

### 并行与共享的可变数据
**第三个编程概念更隐晦一点，它来自我们前面讨论流处理能力时说的“几乎免费的并行”。你需要放弃什么吗？你可能需要对传给流方法的行为
的写法稍作改变**。这些改变可能一开始会让你感觉有点儿不舒服，但一旦习惯了你就会爱上它们。**你的行为必须能够同时对不同的输入安全地
执行。一般情况下这就意味着，你写代码时不能访问共享的可变数据。这些函数有时被称为“纯函数”或“无副作用函数”或“无状态函数”**。
前面说的并行只有在假定你的代码的多个副本可以独立工作时才能进行。但如果要写入的是一个共享变量或对象，这就行不通了：**如果两个进程
需要同时修改这个共享变量怎么办？后面我们会给出详细的解释**。

**`java8`的流实现并行比`Java`现有的线程API更容易，因此，尽管可以使用`synchronized`来打破“不能有共享的可烃数据”这一规则，
但这相当于是在和整个体系作对，因为它使所有围绕这一规则做出的优化都失去意义了**。在多个处理器内核之间使用`synchronized`，
其代价往往比你预期的要大得多，因为同步迫使代码按照顺序执行，而这与并行处理的宗旨相悖。

这两个要点（**没有共享的可变数据，将方法和函数即代码传递给其他方法的能力**）是我们平常所说的函数式编程范式的基石。








