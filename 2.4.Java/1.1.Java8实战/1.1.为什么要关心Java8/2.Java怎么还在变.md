Java怎么还在变
===============================================================
编程语言就像生态系统一样，新的语言会出现，旧语言则被取代，除非它们不断演变。我们都希望出现一种完㺯
的通用语言，可在现实中，某些语言只是更适合某些方面。比如，`C`和`C++`仍然是构建操作系统和各种嵌入
式系统的流行工具，因为它们编写出的程序尽管安全性不佳，但运行时占用资源少。缺乏安全性可能导致程序意
外崩溃，并把安全漏洞暴露给病毒和其他东西；确实，`Java`和`C#`等安全型语言在诸多运行资源不太紧张的
应用中已经取代了`C`和`C++`。

在过去15年的时间里，`Java`已经成功地霸占了编程生态系统中的一大块，同时替代了竞争对手语言。让我们
来看看其中的原因。

## 1.Java在编程语言生态系统中的位置
**`Java`虚拟机（`JVM`）及其字节码可能会变得比`Java`语言本身更重要**，而且对于某些应用来说，
`Java`可能会被同样运行在`JVM`上的竞争对手语言（如`Scala`或`Groovy`）取代。`JVM`各种最新的更
新（例如`JDK7`中的新`invokedynamic`字节码）旨在帮助这些竞争对手语言在`JVM`上顺利运行，并与
`Java`互操作。

编程语言生态系统的气候正在变化。程序员越来越多地要处理 **所谓的大数据**（数百万兆甚至更多字节的数
据集），并希望利用多核计算机或计算集群来有效地处理。这意味着 **需要使用并行处理**————`Java`以前
对此并不支持。

`Java8`对于程序员的主要好处在于它提供了 **更多的编程工具和概念**，能以更快，更重要的是能以 **更
为简洁、更易维护的方式** 解决新的或现有的编程问题。虽然这些概念对于`Java`来说是新的，但是研究型
的语言已经证明了它们的强大。我们会突出并探讨三个这样的编程概念背后的思想，**它们促使`Java8`中开发
出并行和编写更简洁通用代码的功能**。

## 2.流处理
第一个编程概念是 **流处理**。介绍一下，**流是一系列数据项，一次只生成一项。程序可以从输入流中一个
一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流**。

一个实际的例子是在`Unix`或`Linux`中，很多程序都从标准输入（`Unix`和`C`中的`stdin`，`Java`中
的`System.in`）读取数据，然后把结果写入标准输出（`Unix`和`C`中的`stdout`，`Java`中的
`System.out`）。首先我们来看一点点背景：`Unix`的`cat`命令会把两个文件连接起来创建一个流，`tr`
会转换流中的字符，`sort`会对流中的行进行排序，而`tail -3`则给出流的最后3行。**`Unix`命令行允许
这些程序通过管道（`|`）连接在一起**，比如
```shell
$ cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```
会（假设`file1`和`file2`中每行都只有一个词）先把字母转换成小写字母，然后打印出按照词典排序出现
在最后的三个单词。我们说`sort`把一个行流作为输入，产生了另一个行流（进行排序）作为输出。**请注意
在`Unix`中，命令（`cat`、`tr`、`sort`和`tail`）是同时执行的，这样`sort`就可以在`cat`或`tr`
完成前先处理头几行**。

基于这一思想，`Java8`在`java.util.stream`中添加了一个`Stream API`；`Stream<T>`就是一系列
`T`类型的项目。**你现在可以把它看成一种比较花哨的迭代器。`Stream API`的很多方法可以链接起来形成
一个复杂的流水线**，就像先前例子里面链接起来的`Unix`命令一样。

推动这种做法的关键在于，**现在你可以在一个更高的抽象层次上写`java8`程序了**：思路变成了 **把这
样的流变成那样的流**，而不是一次只处理一个项目。另一个好处是，**`Java8`可以透明地把输入的不相关
部分拿到几个`CPU`内核上去分别执行你的`Stream`操作流水线————这是几乎免费的并行**，用不着去费劲
搞`Thread`了。

## 3.用行为参数化把代码传递给方法
`java8`中增加的另一个编程概念是通过API来传递代码的能力。**`java8`增加了把方法（你的代码）作为
参数传递给另一个方法的能力**。我们把这一概念称为 **行为参数化**。它的重要之处在哪儿呢？`Stream API`
就是构建在通过传递代码使操作行为实现参数化的思想上的。

## 4.并行与共享的可变数据
**第三个编程概念更隐晦一点，它来自我们前面讨论流处理能力时说的“几乎免费的并行”。你需要放弃什么吗？
你可能需要对传给流方法的行为的写法稍作改变**。这些改变可能一开始会让你感觉有点儿不舒服，但一旦习惯
了你就会爱上它们。**你的行为必须能够同时对不同的输入安全地执行。一般情况下这就意味着，你写代码时不
能访问共享的可变数据。这些函数有时被称为“纯函数”或“无副作用函数”或“无状态函数”**。前面说的并行只
有在假定你的代码的多个副本可以独立工作时才能进行。但如果要写入的是一个共享变量或对象，这就行不通了：
**如果两个进程需要同时修改这个共享变量怎么办？后面我们会给出详细的解释**。

**`java8`的流实现并行比`Java`现有的线程API更容易，因此，尽管可以使用`synchronized`来打破“不
能有共享的可变数据”这一规则，但这相当于是在和整个体系作对，因为它使所有围绕这一规则做出的优化都失去
意义了**。在多个处理器内核之间使用`synchronized`，其代价往往比你预期的要大得多，因为同步迫使代码
按照顺序执行，而这与并行处理的宗旨相悖。

这两个要点（**没有共享的可变数据，将方法和函数即代码传递给其他方法的能力**）是我们平常所说的函数
式编程范式的基石。
