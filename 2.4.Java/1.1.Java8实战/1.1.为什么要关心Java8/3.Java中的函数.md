Java中的函数
================================================================
`java8`中新增了 **函数————值的一种新形式**。有了它，`java8`可以进行多核处理器上的 **并行编程**。
我们首先来展示一下作为值的函数本身的有用之处。

想想`Java`程序可能操作的值吧。首先有原始值，比如42和3.14。其次，值可以是对象。那么有什么问题呢？
我们要注意到，编程语言的整个目的就在于操作值，要是按照历史上编程语言的传统，这些值因此被称为 **一等值**
（或**一等公民**）。编程语言中的其他结构也许有助于我们表示值的结构，但在程序执行期间不能传递，因而是
二等公民。前面所说的 **值是`Java`中的一等公民，但其他很多`Java`概念（如方法和类等）则是二等公民**。
方法和类本身都不是值，这又有什么关系呢？还真有，人们发现，**在运行时传递方法能将方法变成一等公民**。
这在编程中非常有用，因此`java8`的设计者把这个功能加入到了`Java`中。

### 方法和Lambda作为一等公民
`Scala`和`Groovy`等语言的实践已经证明，让方法等概念作为一等值可以扩充程序员的工具库，从而让编程变得更容易。
因此，`java8`的设计者决定允许方法作为值，让编程更轻松。此外，让方法作为值也构成了其他若干`java8`功能
（如`Stream`）的基础。

我们介绍的`java8`的第一个新功能是 **方法引用**。比方说，你想要筛选一个目录中的所有隐藏文件。你需要编写一个方法，
然后给它一个`File`，它就会告诉你文件是不是隐藏的。幸好，`File`类里面有一个叫作`isHidden`的方法。
我们可以把它看作一个函数，接受一个`File`，返回一个布尔值。但要用它做筛选，你需要把它包在一个`FileFilter`对象里，
然后传递给`File.listFiles`方法，如下所示：
```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    @Override
    public boolean accept(File file) {
        return file.isHidden();
    }
});
```
虽然只有三行，但这三行可真够绕的。我们已经有一个方法`isHidden`可以使用，为什么非得把它包在一个啰嗦的`FileFilter`
类里面再实例化呢？因为在`java8`之前你必须这么做！如今在`java8`里，你可以把代码重写成这个样子：
```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
你已经有了函数`isHidden`，因此只需用`java8`的 **方法引用::语法（即“把这个方法作为值”）** 将其传给`listFiles`方法；
请注意，**我们也开始用函数代表方法了**。稍后我们会解释这个机制是如何工作的。方法不再是二等值了。与用对象引用传递对象类似，
在`java8`里写下`File::isHidden`的时候，你就创建了一个方法引用，你同样可以传递它。

#### Lambda———匿名函数
除了允许 **（命名）函数** 成为一等值外，`java8`还体现了 **更广义的将函数作为值的思想**，包括 **`Lambda`（或匿名函数）**。
比如，你现在可以写`(int x) -> x + 1`，表示“调用时给定参数x，就返回x+1值的函数”。你可能会想这有什么必要呢？
因为你可以在`MyMathsUtils`类里面定义一个`add1`方法，然后写`MyMathsUtils::add1`嘛！确实是可以，**但要是你没有方便的
方法和类可用，新的`Lambda`语法更简洁**。这些概念的程序为函数式编程风格，这句话的意思是“编写把函数作为一等值来传递的程序”。

### 传递代码：一个例子
假设你有一个`Apple`类，它有一个`getColor`方法 ，还有一个变量`inventory`保存着一个`Apples`列表。你可能想要选出
所有的绿苹果，并返回一个列表。通常我们用筛选（`filter`）一词来表达这个概念。在`java8`之前，你可能会写这样一个方法
`filterGreenApples`：
```java
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ("green".equals(apple.getColor())) {
            result.add(apple);
        }
    }
    return result;
}
```
但是接下来，有人可能想要选出重的苹果，比如超过150克，于是你心情沉重地写了下面这个方法，甚至用了复制粘贴：
```java
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (applegetWeight() > 150) {
            result.add(apple);
        }
    }
    return result;
}
```
我们都知道软件工程中复制粘贴的危险————给一个做了更新和修正，却忘了另一个。嘿，这两个方法只有一行不同。
但是，我们前面提过了，**`java8`会把条件代码作为参数传递进去，这样可以避免`filter`方法出现重复的代码**。
现在你可以写：
```java
public static boolean isGreenApple(Apple apple) {
    return "green".equals(apple.getColor());
}

public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

//写出来是为了清晰（平常只要从java.util.function导入就可以了）
public interface Predicate<T> {
    boolean test(T t);
}

//方法作为Predicate参数p传递进去
static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple: inventory) {
        if(p.test(apple)) {
            result.add(apple);
        }
    }
}
```
要用它的话，你可以写：
```java
filterApples(inventory, Apple::isGreenApple);
```
或者：
```java
filterApples(inventory, Apple::isHeavyApple);
```
```
什么是谓词？
前面的代码传递了方法Apple::isGreenApple（它接受参数Apple并返回一个boolean）给filterApples，
后者则希望接受一个Predicate<Apple>参数。谓词（predicate）在数学上常常用来代表一个类似函数的东西，
它接受一个参数值，并返回true或false。你在后面会看到，Java8也会允许你写Function<Apple,Boolean>————
在学校学过函数却没学过谓词的读者对此可能更熟悉，但用Predicate<Apple>是更标准的方式，效率也会更高一点儿，
这避免了把boolean封装在Boolean里面。
```