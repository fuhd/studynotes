Java中的函数
================================================================================
`java8`中新增了 **函数————值的一种新形式**。有了它，`java8`可以进行多核处理器上的 **并行编程**。
我们首先来展示一下作为值的函数本身的有用之处。

想想`Java`程序可能操作的值吧。首先有原始值，比如42和3.14。其次，值可以是对象。那么有什么问题呢？
我们要注意到，编程语言的整个目的就在于操作值，要是按照历史上编程语言的传统，这些值因此被称为 **一
等值**（或 **一等公民**）。编程语言中的其他结构也许有助于我们表示值的结构，但在程序执行期间不能
传递，因而是二等公民。前面所说的 **值是`Java`中的一等公民，但其他很多`Java`概念（如方法和类等）
则是二等公民**。方法和类本身都不是值，这又有什么关系呢？还真有，人们发现，**在运行时传递方法能将
方法变成一等公民**。这在编程中非常有用，因此`java8`的设计者把这个功能加入到了`Java`中。

## 1.方法和Lambda作为一等公民
`Scala`和`Groovy`等语言的实践已经证明，让方法等概念作为一等值可以扩充程序员的工具库，从而让编
程变得更容易。因此，`java8`的设计者决定允许方法作为值，让编程更轻松。此外，让方法作为值也构成了
其他若干`java8`功能（如`Stream`）的基础。

我们介绍的`java8`的第一个新功能是 **方法引用**。比方说，你想要筛选一个目录中的所有隐藏文件。你
需要编写一个方法，然后给它一个`File`，它就会告诉你文件是不是隐藏的。幸好，`File`类里面有一个叫
作`isHidden`的方法。我们可以把它看作一个函数，接受一个`File`，返回一个布尔值。但要用它做筛选，
你需要把它包在一个`FileFilter`对象里，然后传递给`File.listFiles`方法，如下所示：
```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    @Override
    public boolean accept(File file) {
        return file.isHidden();
    }
});
```
虽然只有三行，但这三行可真够绕的。我们已经有一个方法`isHidden`可以使用，为什么非得把它包在一个
啰嗦的`FileFilter`类里面再实例化呢？因为在`java8`之前你必须这么做！如今在`java8`里，你可以把
代码重写成这个样子：
```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
你已经有了函数`isHidden`，因此只需用`java8`的 **方法引用::语法（即“把这个方法作为值”）** 将
其传给`listFiles`方法；请注意，**我们也开始用函数代表方法了**。稍后我们会解释这个机制是如何工
作的。方法不再是二等值了。与用对象引用传递对象类似，在`java8`里写下`File::isHidden`的时候，你
就创建了一个方法引用，你同样可以传递它。

### 1.1.Lambda———匿名函数
除了允许 **（命名）函数** 成为一等值外，`java8`还体现了 **更广义的将函数作为值的思想**，包括
**`Lambda`（或匿名函数）**。比如，你现在可以写`(int x) -> x + 1`，表示“调用时给定参数x，就
返回x+1值的函数”。你可能会想这有什么必要呢？因为你可以在`MyMathsUtils`类里面定义一个`add1`方
法，然后写`MyMathsUtils::add1`嘛！确实是可以，**但要是你没有方便的方法和类可用，新的`Lambda`
语法更简洁**。这些概念的程序为函数式编程风格，这句话的意思是“编写把函数作为一等值来传递的程序”。

## 2.传递代码：一个例子
假设你有一个`Apple`类，它有一个`getColor`方法 ，还有一个变量`inventory`保存着一个`Apples`
列表。你可能想要选出所有的绿苹果，并返回一个列表。通常我们用筛选（`filter`）一词来表达这个概念。
在`java8`之前，你可能会写这样一个方法
`filterGreenApples`：
```java
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ("green".equals(apple.getColor())) {
            result.add(apple);
        }
    }
    return result;
}
```
但是接下来，有人可能想要选出重的苹果，比如超过150克，于是你心情沉重地写了下面这个方法，甚至用了复
制粘贴：
```java
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (applegetWeight() > 150) {
            result.add(apple);
        }
    }
    return result;
}
```
我们都知道软件工程中复制粘贴的危险————给一个做了更新和修正，却忘了另一个。嘿，这两个方法只有一行
不同。但是，我们前面提过了，**`java8`会把条件代码作为参数传递进去，这样可以避免`filter`方法出
现重复的代码**。现在你可以写：
```java
public static boolean isGreenApple(Apple apple) {
    return "green".equals(apple.getColor());
}

public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

//写出来是为了清晰（平常只要从java.util.function导入就可以了）
public interface Predicate<T> {
    boolean test(T t);
}

//方法作为Predicate参数p传递进去
static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple: inventory) {
        if(p.test(apple)) {
            result.add(apple);
        }
    }
}
```
要用它的话，你可以写：
```java
filterApples(inventory, Apple::isGreenApple);
```
或者：
```java
filterApples(inventory, Apple::isHeavyApple);
```
```
什么是谓词？
前面的代码传递了方法Apple::isGreenApple（它接受参数Apple并返回一个boolean）给filterApples，后者则希望接受一个
Predicate<Apple>参数。谓词（predicate）在数学上常常用来代表一个类似函数的东西，它接受一个参数值，并返回true或false。
你在后面会看到，Java8也会允许你写Function<Apple,Boolean>————在学校学过函数却没学过谓词的读者对此可能更熟悉，但用
Predicate<Apple>是更标准的方式，效率也会更高一点儿，这避免了把boolean封装在Boolean里面。
```

## 3.从传递方法到Lambda
把方法作为值来传递显然很有用，**但要是为类似于`isHeavyApple`和`isGreenApple`这种可能只用一两
次的短方法写一堆定义有点儿烦人。不过`java8`也解决了这个问题，它引入了一套新记法（匿名函数或
`Lambda`）**，让你可以写：
```java
filterApples(inventry, (Apple s) -> "green".equals(a.getColor()));
```
或者：
```java
filterApples(inventory, (Apple s) -> a.getWeight() > 150);
```
所以，**你甚至都不需要为只用一次的方法写定义**；代码更干净、更清晰，因为你用不着去找自己到底传递
了什么代码。**但要是`Lambda`的长度多于几行的话，那你还是应该用方法引用来指向一个有描述性名称的方
法，而不是使用匿名的`Lambda`**。你应该以代码的清晰度为准绳。

`java8`的设计师几乎可以就此打住了，要是没有多核CPU，可能他们真的就到此为止了。我们迄今为止谈到的
函数式编程竟然如此强大，在后面你更会体会到这一点。本来，`Java`加上`filter`和几个相关的东西作为
通知库方法就足以让人满意了，比如：
```java
static <T> Collection<T> filter(Collection<T> c, Predicate<T> p);
```
这样你甚至都不需要写`filterApples`了，因为比如先前的调用：
```java
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```
就可以直接调用库方法`filter`：
```java
filter(inventory, (Apple a) -> a.getWeight() > 150);
```
但是，**为了更好地利用并行，`Java`的设计师没有这么做。`Java8`中有一整套新的类集合API————Stream，
它有一套函数式程序员熟悉的、类似于`filter`的操作，比如`map`、`reduce`**，还有我们接下来要讨论
的在`Collections`和`Stream`之间做转换的方法。
