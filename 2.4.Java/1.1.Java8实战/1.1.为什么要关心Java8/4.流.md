流
=============================================================
几乎每个Java应用都会制造和处理集合。但集合用起来并不总是那么理想。比方说，你需要从一个列表中筛选金额
较高的交易，然后按货币分组。你需要写一大堆套路化的代码来实现这个数据处理命令，如下所示：
```java
//建立累积交易分组的Map
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();
//遍历交易的List
for (Transaction transaction: transactions) {
    //筛选金额较高的交易
    if(transaction.getPrice() > 1000) {
        //提取交易货币
        Currency currency = transaction.getCurrency();
        //如果这个货币的分组Map是空的，那就建立一个
        List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);
        if (transactionsForCurrency == null) {
            transactionsForCurrency = new ArrayList<>();
            transactionsByCurrencies.put(currency, transactionsForCurrency);
        }
        //将当前遍历的交易添加到具有同一货币的交易List中
        transactionsForCurrency.add(transaction);
    }
}
```
此外，我们很难一眼看出来这些代码是做什么的，因为还有好几个嵌套的控制流指令。有了`Stream API`，你现在可以
这样解决这个问题：
```java
import static java.util.Stream.Collectors.toList;
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream().
    filter((Transaction t) -> t.getPrice() > 1000).     //筛选金额较高的交易
    collect(groupingBy(Transaction::getCurrency()));    //按货币分组
```
现在值得注意的是，和`Collection API`相比，`Stream API`处理数据的方式非常不同。用集合的话，你得自己
去做迭代的过程。你得用`for-each`循环一个个去迭代元素，然后再处理元素。我们把这种数据迭代的方法称为 **外部迭代**。
相反，有了`Stream API`，你根本用不着操心循环的事情。数据处理完全是在库内部进行的。我们把这种思想叫作 **内部迭代**。

使用集合的另一个头疼的地方是，想想看，要是你的交易量非常庞大，你要怎么处理这个巨大的列表呢？单个CPU根本搞不定
这么大量的数据，但你很可能已经有了一台多核电脑。**理想的情况下，你可能想让这些CPU内核共同分担处理工作，
以缩短处理时间**。理论上来说，要是你有八个核，那并行起来，处理数据的速度应该是单核的8倍。

### 多线程并非易事
问题在于，**通过多线程代码来利用并行（使用先前`Java`版本中的`Thread API`）并非易事**。你得换一种思路：线程可能
会同时访问并更新共享变量。因此，如果没有协调好，数据可能会被意外改变。相比一步步执行的顺序模型，这个模型不太好理解。

`Java8`也用`Stream API`（`java.util.stream`）解决了这两个问题：集合处理时的套路和晦涩，以及验证以利用多核。
这样设计的 **第一个原因是，有许多反复出现的数据处理模式**，例如筛选数据、提取数据或给数据分组等。**第二个原因是，这类操作
常常可以并行化**。例如，在两个CPU上筛选列表，可以让一个CPU处理列表的前一半，第二个CPU处理后一半。CPU随后对各自的半
个列表做筛选。最后，一个CPU会把两个结果合并起来。

到这里，我们只是说新的`Stream API`和`java`现有的集合`API`的行为差不多：它们都能够访问数据项目的序列。 不过，
现在最好记得，**`Collection`主要是为了存储和访问数据，而`Stream`则主要用于描述对数据的计算。这里的关键点在于，
`Stream`允许并提倡并行处理一个`Stream`中的元素**。虽然可能乍看上去有点儿怪，**但筛选一个`Collection`的最快方法
常常是将其转换为`Stream`，进行并行处理，然后再转换回`List`**。下面举的 **串行** 和 **并行** 的例子都是如此：




