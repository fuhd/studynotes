流
================================================================================
几乎每个Java应用都会制造和处理集合。但集合用起来并不总是那么理想。比方说，你需要从一个列表中筛选
金额较高的交易，然后按货币分组。你需要写一大堆套路化的代码来实现这个数据处理命令，如下所示：
```java
//建立累积交易分组的Map
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();
//遍历交易的List
for (Transaction transaction: transactions) {
    //筛选金额较高的交易
    if(transaction.getPrice() > 1000) {
        //提取交易货币
        Currency currency = transaction.getCurrency();
        //如果这个货币的分组Map是空的，那就建立一个
        List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);
        if (transactionsForCurrency == null) {
            transactionsForCurrency = new ArrayList<>();
            transactionsByCurrencies.put(currency, transactionsForCurrency);
        }
        //将当前遍历的交易添加到具有同一货币的交易List中
        transactionsForCurrency.add(transaction);
    }
}
```
此外，我们很难一眼看出来这些代码是做什么的，因为还有好几个嵌套的控制流指令。有了`Stream API`，
你现在可以这样解决这个问题：
```java
import static java.util.Stream.Collectors.toList;
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream().
    filter((Transaction t) -> t.getPrice() > 1000).     //筛选金额较高的交易
    collect(groupingBy(Transaction::getCurrency()));    //按货币分组
```
现在值得注意的是，和`Collection API`相比，`Stream API`处理数据的方式非常不同。用集合的话，你
得自己去做迭代的过程。你得用`for-each`循环一个个去迭代元素，然后再处理元素。我们把这种数据迭代的
方法称为 **外部迭代**。相反，有了`Stream API`，你根本用不着操心循环的事情。数据处理完全是在库内
部进行的。我们把这种思想叫作 **内部迭代**。

使用集合的另一个头疼的地方是，想想看，要是你的交易量非常庞大，你要怎么处理这个巨大的列表呢？单个
CPU根本搞不定这么大量的数据，但你很可能已经有了一台多核电脑。**理想的情况下，你可能想让这些CPU
内核共同分担处理工作，以缩短处理时间**。理论上来说，要是你有八个核，那并行起来，处理数据的速度应
该是单核的8倍。

## 1.多线程并非易事
问题在于，**通过多线程代码来利用并行（使用先前`Java`版本中的`Thread API`）并非易事**。你得换
一种思路：线程可能会同时访问并更新共享变量。因此，如果没有协调好，数据可能会被意外改变。相比一步
步执行的顺序模型，这个模型不太好理解。

`Java8`也用`Stream API`（`java.util.stream`）解决了这两个问题：集合处理时的套路和晦涩，以
及难以利用多核。这样设计的 **第一个原因是，有许多反复出现的数据处理模式**，例如筛选数据、提取数据
或给数据分组等。**第二个原因是，这类操作常常可以并行化**。例如，在两个CPU上筛选列表，可以让一个
CPU处理列表的前一半，第二个CPU处理后一半。CPU随后对各自的半个列表做筛选。最后，一个CPU会把两个
结果合并起来。

到这里，我们只是说新的`Stream API`和`java`现有的集合`API`的行为差不多：它们都能够访问数据项目
的序列。不过，现在最好记得，**`Collection`主要是为了存储和访问数据，而`Stream`则主要用于描述对
数据的计算。这里的关键点在于，`Stream`允许并提倡并行处理一个`Stream`中的元素**。虽然可能乍看上
去有点儿怪，**但筛选一个`Collection`的最快方法常常是将其转换为`Stream`，进行并行处理，然后再转
换回`List`**。下面举的 **串行** 和 **并行** 的例子都是如此：

顺序处理：
```java
// 顺序处理
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples = inventory.stream().filter((Apple a) -> a.getWeight() > 150).collect(toList());
```

并行处理：
```java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples = inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150).collect(toList());
```
在加入所有这些新玩意儿改进`Java`的时候，`Java8`设计者发现的一个现实问题就是现在的接口也在改进。
比如，`Collections.sort`方法真的应该属于`List`接口，但却从来没有放在后者里。理想的情况下，你
会希望做`list.sort(comparator`，而不是`Collections.sort(list, comparator)`。这看起来无
关紧要，**但是在`java8`之前，你可能会更新一个接口，然后发现你把所有实现它的类也给更新了**————简
直是逻辑灾难！这个问题在`java8`里由 **默认方法** 解决了。
