流与集合
================================================================================
**集合与流之间的差异就在于什么时候进行计算**。集合是一个内存中的数据结构，它包含数据结构中目前所
有的值————集合中的每个元素都得先算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（
你不能添加或删除元素），其元素则是按需计算的。这对编程有很大的好处。从另一个角度来说，**流就像是
一个延迟创建的集合：只有在消费者要求的时候才会计算值**。

## 1.只能遍历一次
请注意，和迭代器类似，**流只能遍历一次**。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始
数据源再获得一个新的流来重新遍历一遍，就像迭代器一样。例如，如下代码会抛出一个异常，说流已被消费
掉了：
```java
List<String> title = Arrays.asList("Java8","In","Action");
Stream<String> s = title.stream();
s.forEach(System.out::println);
//java.lang.IllegalStateException: 流已被操作或关闭
s.forEach(System.out::println);
```
```
哲学中的流和集合

对于喜欢哲学的读者，你可以把流看作在时间中分布的一组值。相反，集合则是空间（这里就是计算机内存）中分布的一组值，在一个时间
点上全体存在————你可以使用迭代器来访问for-each循环中的内部成员。
```

## 2.外部迭代与内部迭代
**使用`Collection`接口需要用户去做迭代（比如用`for-each`），这称为外部迭代。相反，`Streams`
库使用内部迭代————它帮你把迭代做了**，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么
就可以了。

集合：用`for-each`循环外部迭代
```java
List<String> names = new ArrayList<>();
for(Dish d: menu) {
  names.add(d.getName());
}
```

流：内部迭代
```java
List<String> names = new ArrayList<>();
Iterator<String> iterator = menu.iterator();
while(iterator.hasNext()) {
  Dish d = iterator.next();
  names.add(d.getName());
}
```


































dd
