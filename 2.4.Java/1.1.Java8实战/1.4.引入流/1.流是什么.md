流是什么
================================================================================
**流是Java API的新成员，它允许你以声明性方式处理数据集合**（通过查询语句来表达，而不是临时编写
一个实现）。就现在来说，**你可以把它们看成遍历数据集的高级迭代器**。此外，**流还可以透明地并行处
理**，你无需写任何多线程代码了。下面两段代码都是用来返回低热量的菜肴名称的，并按照卡路里排序，一
个是用Java7写的，另一个是用Java8的流写的。

之前（Java7）：
```java
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish d: menu) {
  if(d.getCalories() < 400) {
    //用累加器筛选元素
    lowCaloricDishes.add(d);
  }
}
//用匿名类对菜希排序
Collections.sort(lowCaloricDishes, new Comparator<Dish>(){
  public int compare(Dish d1, Dish d2) {
    return Integer.compare(d1.getCalories(), d2.getCalories());
  }
});
//处理排序后的菜名列表
List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish d: lowCaloricDishes) {
  lowCaloricDishesName.add(d.getName());
}
```
在这段代码中，你用了一个“垃圾变量” lowCaloricDishes。它唯一的作用就是作为一次性的中间容器。在
Java8中，实现的细节被放在它本该归属的库里了。

之后（Java8）：
```java
import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.toList;

List<String> lowCaloricDishesName = menu.stream()
    .filter(d -> d.getCalories() < 400)   //选出400卡路里以下的菜肴
    .sorted(comparing(Dish::getCalories)) //并按照卡路里排序
    .map(Dish::getName)                   //提取菜肴的名称
    .collect(toList());                   //将所有名称保存在List中
```
**为了利用多核架构并行执行这段代码，你只需要把stream()换成parallelStream()**：
```java
List<String> lowCaloricDishesName = menu.parallelStream()
    .filter(d -> d.getCalories() < 400)  
    .sorted(comparing(Dish::getCalories))
    .map(Dish::getName)                  
    .collect(toList());
```
你可能会想，**在调用parallelStream方法的时候到底发生了什么。用了多少个线程？对性能有多大提升**？
第7章会详细讨论这些问题。现在，你可以看出，从软件工程师的角度来看，新的方法有几个显而易见的好处。
+ **代码是以声明性方式写的：说明想要完成什么，而不是说明如何实现一个操作**。
+ **你可以把几个基础操作链接起来，来表达复杂的数据处理流水线，同时保持代码清晰可读**。

**因为filter、sorted、map和collect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现
可以是单线程的，也可能透明地充分利用你的多核架构**！在实践中，这意味着你用不着为了让某些数据处理
任务并行而去操心线程和锁，Stream API都替你做好了！

新的Stream API表达能力非常强。比如在读完本章以及第5章、第6章之后，你就可以写出像下面这样的代码：
```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));
```
我们在第6章中解释这个例子。简单来说就是，**按照Map里面的类别对菜肴进行分组**。比如Map可能包含下
列结果：
```
{FISH=[prawns, salmon],
OTHER=[french fries, rice, season fruit, pizza],
MEAT=[pork, beef, chicken]}
```

总结一下，Java8中的Stream API可以让你写出这样的代码：
+ **声明性**————更简洁、更易读
+ **可复合**————更灵活
+ **可并行**————性能更好

在本章剩下的部分和下一章中，我们会使用这样一个例子：一个menu，它只是一张菜肴列表。
```java
List<Dish> menu = Arrays.asList(
  new Dish("pork", false, 800, Dish.Type.MEAT),
  new Dish("beef", false, 700, Dish.Type.MEAT),
  new Dish("chicken", false, 400, Dish.Type.MEAT),
  new Dish("french fries", true, 530, Dish.Type.OTHER),
  new Dish("rice", true, 350, Dish.Type.OTHER),
  new Dish("season fruit", true, 120, Dish.Type.OTHER),
  new Dish("pizza", true, 550, Dish.Type.OTHER),
  new Dish("prawns", false, 300, Dish.Type.FISH),
  new Dish("salmon", false, 450, Dish.Type.FISH)
);
```
Dish类的定义是：
```java
public class Dish {

    private final String name;
    private final boolean vegetarian;
    private final int calories;
    private final Type type;

    public Dish(String name, boolean vegetarian, int calories, Type type) {
        this.name = name;
        this.vegetarian = vegetarian;
        this.calories = calories;
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public int getCalories() {
        return calories;
    }

    public Type getType() {
        return type;
    }

    public enum Type {
        MEAT, FISH, OTHER
    }
}
```
