流操作
================================================================================
`java.util.stream.Stream`中的Stream接口定义了许多操作。它们可以分为 **两大类**。我们再来看
一下前面的例子：
```java
List<String> names = menu.stream()              //从菜单获得流
  .filter(d -> d.getCalories() > 300)           //中间操作
  .map(Dish::getName)                           //中间操作
  .limit(3)                                     //中间操作
  .collect(Collectors.toList());                //将Stream转换为List
```
你可以看到两类操作：
+ `filter`、`map`和`limit`可以连成一条流水线。
+ `collect`触发流水线执行并关闭它。
**可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作**。

## 1.中间操作
讲得如`filter`或`sorted`等中间操作会返回另一个流。**这让多个操作可以连接起来形成一个查询。重要
的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理**————它们很懒。这是因为中间操作
一般都可以合并起来，在终端操作时一次性全部处理。

为了搞清楚流水线中到底发生了什么，**我们把代码改一改，让每个Lambda都打印出当前处理的菜肴**。
```java
List<String> names = menu.stream()
  .filter(d -> {
      System.out.println("filtering" + d.getName());
      return d.getCalories() > 300;
  })
  .map(d -> {
      System.out.println("mapping" + d.getName());
      return d.getName();
  })
  .limit(3)
  .collect(Collectors.toList());
names.stream().forEach(System.out::println);
```
```
这种编程风格要是搁在生产代码里那就吓死人了，但是学习的时候却可以直接看清楚求值的顺序。
```
此代码执行时将打印：
```
filteringpork
mappingpork
filteringbeef
mappingbeef
filteringchicken
mappingchicken
pork
beef
chicken
```
你会发现，有好几种优化利用了 **流的延迟** 性质。第一，尽管很多菜的热量都高于300卡路里，但只选出
了前三个！这是因为limit操作和一种称为 **短路** 的技巧，我们会在下一章中解释。第二，**尽管filter
和map是两个独立的操作，但它们合并到同一次遍历中了（我们把这种技术叫作循环合并）**。

## 2.终端操作
**终端操作会从流水线生成结果。其结果是任何不是流的值**，比如List、Integer，甚至void。例如，在
下面的流水线中，`forEach`是一个返回void的终端操作，它会对源中的每道菜应用一个Lambda。把
`System.out.println`传递给`forEach`，并要求它打印出由menu生成的流中的每一个Dish：
```java
menu.stream().forEach(System.out::println);
```
```
测验：中间操作与终端操作

在下列流水线中，你能找出中间操作和终端操作吗？

long count = menu.stream()
    .filter(d -> d.getCalories() > 300)
    .distinct()
    .limit(3)
    .count();

答案：流水线中最后一个操作count返回一个long，这是一个非Stream的值。因此它是一个终端操作。所有前面的操作，filter、distinct、
limit，都是连接起来的，并返回一个Stream，因此它们是中间操作。
```


































dd
