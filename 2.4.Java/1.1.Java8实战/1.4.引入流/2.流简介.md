流简介
================================================================================
Java8中的集合支持一个新的`stream`方法，它会返回一个流（接口定义在`java.util.stream.Stream`
里）。你在后面会看到，还有很多其他的方法可以得到流，比如利用数值范围或从`I/O`资源生成流元素。

那么，**流到底是什么呢**？简短的定义就是“**从支持数据处理操作的源生成的元素序列**”。
+ **元素序列**————就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值（如`ArrayList`
与`LinkedList`）。**但流的目的在于表达计算**，比如你前面见到的`filter`、`sorted`和`map`。
**集合讲的是数据，流讲的是计算**。
+ **源**————流会使用一个提供数据的源，如集合、数组或输入/输出资源。**请注意，从有序集合生成流时
会保留原有的顺序**。由列表生成的流，其元素顺序与列表一致。
+ **数据处理操作**————**流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，
如`filter`、`map`、`reduce`、`find`、`match`、`sort`等。流操作可以顺序执行，也可并行执行**。

此外，流操作有两人个重要的特点：
+ **流水线**————很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这
让我们下一章中的一些优化成为可能，如 **延迟** 和 **短路**。**流水线的操作可以看作对数据源进行数
据库式查询**。
+ **内部迭代**————与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。

让我们来看一段能够体现所有这些概念的代码：
```java
import static java.util.stream.Collectors.toList;

List<String> threeHighCaloricDishNames = menu.stream()    //从menu获得流（菜肴列表）
  .filter(d -> d.getCalories() > 300)                     //建立操作流水线：首先选出高热量的菜肴
  .map(Dish::getName)                                     //获取菜名
  .limit(3)                                               //只选择头三个
  .collect(toList());                                     //将结果保存在另一个List中
```   
在本例中，我们先是对`menu`调用`stream`方法，由菜单得到一个流。数据源是菜肴列表，它给流提供一个
元素序列。接下来，对流应用一系列数据处理操作；`filter`、`map`、`limit`和`collect`。**除了
`collect`之外，所有这些操作都会返回另一个流，这样它们就可以接成一条流水线，于是就可以看作对源的
一个查询**。最后，`collect`操作开始处理流水线，并返回结果（它和别的操作不一样，因为它返回的不是
流，在这里是一个List）。**在调用`collect`之前，没有任何结果产生，实际上根本就没有从`menu`里选
择元素。你可以这么理解：链中的方法调用都在排队等待，直到调用`collect`**。
