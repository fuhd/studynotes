方法引用
================================================================================
**方法引用让你可以重复使用现有的方法定义**，并像Lambda一样传递它们。下面就是我们借助更新的Java8
API，用方法引用写的一个排序的例子：
```java
//先前
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
//之后使用方法引用和java.util.Comparator.comparing
inventory.sort(Comparator.comparing(Apple::getWeight));
```

## 1.管中窥豹
你为什么应该关心方法引用？**方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法**。它的基
本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如
何调用它。事实上，**方法引用就是让你根据已有的方法实现来创建Lambda表达式**。但是，**显式地指明
方法的名称，你的代码的可读性会更好。当你需要使用方法引用时，目标引用放在分隔符（`::`）前，方法的
名称放在后面**。例如，`Apple::getWeight`就是引用了`Apple`类中定义的方法`getWeight`。请记
住，**不需要括号，因为你没有实际调用这个方法**。方法引用就是Lambda表达式`(Apple a) -> a.getWeight()`
的快捷写法。下表给出了Java8中方法引用的其他一些例子：

| Lambda | 等效的方法引用 |
| :------------- | :------------- |
| (Apple a) -> a.getWeight() | Apple::getWeight |
| () -> Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
| (str, i) -> str.substring(i) | String::substring |
| (String s) -> System.out.println(s) | String.out::println |

**你可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖**。

### 1.1.如何构建方法引用
方法引用主要有三类：
1. **指向静态方法的方法引用**：例如Integer的parseInt方法，写作`Integer::parseInt`。
2. **指向任意类型实例方法的方法引用**：例如String的length方法，写作`String::length`。
3. **指向现有对象的实例方法的方法引用**：假设你有一个局部变量`expensiveTransaction`用于存放
`Transaction`类型的对象，它支持实例方法`getValue`，那么你就可以写`expensiveTransaction::getValue`。

第二种和第三种方法引用可能乍看起来有点儿晕。类似于`String::length`的 **第二种方法引用的思想就
是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数**。例如，Lambda表达式
`(String s) -> s.toUppeCase()`可以写作`String::toUpperCase`。但 **第三种方法引用指的是，
你在Lambda中调用一个已经存在的外部对象中的方法**。例如，Lambda表达式
`() -> expensiveTransaction.getValue()`可以写作`expensiveTransaction::getValue` 。
示例：
```java
//1.转静态方法的方法引用
//原
(args) -> ClassName.staticMethod(args);
//转
ClassName::staticMethod

//2.任意类型实例
//原
(arg0, rest) -> arg0.instanceMethod(rest);
//转
ClassName::instanceMethod

//3.现有对象实例
//原
(args) -> expr.instanceMethod(args)
//转
expr::instanceMethod
```
**请注意，还有针对构造函数、数组构造函数和父类调用（`supper-call`）的一些特殊形式的方法引用**。

## 2.构造函数引用
**对于一个现有构造函数，你可以利用它的名称和关键字`new`来创建它的一个引用：`ClassName::new`**。
它的功能与指向静态方法的引用类似。例如，假设有一个构造函数没有参数。它适合`Supplier`的签名
`() -> Apple`。你可以这样做：
```java
//构造函数引用指向默认的Apple()构造函数
Supplier<Apple> c1 = Apple::new;
//调用Supplier的get方法将产生一个新的Apple
Apple a1 = c1.get();
```
这就等价于：
```java
Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();
```
**如果你的构造函数的签名是`Apple(Integer weight)`，那么它就适合`Function`接口的签名**，于
是你可以这样写：
```java
//指向Apple(Integer weight)的构造函数引用
Function<Integer, Apple> c2 = Apple::new;
//调用该Function函数的apply方法，并给出要求的重量，将产生一个Apple
c2.apply(110);
```
这等价于：
```java
Function<Integer, Apple> c2 = (weight) -> new Apple(weight);
Apple a2 = c2.apply(110);
```
在下面的代码中，一个由Integer构成的List中的每个元素都通过我们前面定义的 类似的map方法



























dd









































dd
