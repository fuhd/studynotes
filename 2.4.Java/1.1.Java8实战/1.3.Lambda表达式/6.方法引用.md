方法引用
================================================================================
**方法引用让你可以重复使用现有的方法定义**，并像Lambda一样传递它们。下面就是我们借助更新的Java8
API，用方法引用写的一个排序的例子：
```java
//先前
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
//之后使用方法引用和java.util.Comparator.comparing
inventory.sort(Comparator.comparing(Apple::getWeight));
```

## 1.管中窥豹
你为什么应该关心方法引用？**方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法**。它的基
本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如
何调用它。事实上，**方法引用就是让你根据已有的方法实现来创建Lambda表达式**。但是，**显式地指明
方法的名称，你的代码的可读性会更好。当你需要使用方法引用时，目标引用放在分隔符（`::`）前，方法的
名称放在后面**。例如，`Apple::getWeight`就是引用了`Apple`类中定义的方法`getWeight`。请记
住，**不需要括号，因为你没有实际调用这个方法**。方法引用就是Lambda表达式`(Apple a) -> a.getWeight()`
的快捷写法。下表给出了Java8中方法引用的其他一些例子：

| Lambda | 等效的方法引用 |
| :------------- | :------------- |
| (Apple a) -> a.getWeight() | Apple::getWeight |
| () -> Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
| (str, i) -> str.substring(i) | String::substring |
| (String s) -> System.out.println(s) | String.out::println |

**你可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖**。

### 1.1.如何构建方法引用
方法引用主要有三类：
1. **指向静态方法的方法引用**：例如Integer的parseInt方法，写作`Integer::parseInt`。
2. **指向任意类型实例方法的方法引用**：例如String的length方法，写作`String::length`。
3. **指向现有对象的实例方法的方法引用**：假设你有一个局部变量`expensiveTransaction`用于存放
`Transaction`类型的对象，它支持实例方法`getValue`，那么你就可以写`expensiveTransaction::getValue`。

第二种和第三种方法引用可能乍看起来有点儿晕。类似于`String::length`的 **第二种方法引用的思想就
是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数**。例如，Lambda表达式
`(String s) -> s.toUppeCase()`可以写作`String::toUpperCase`。但 **第三种方法引用指的是，
你在Lambda中调用一个已经存在的外部对象中的方法**。例如，Lambda表达式
`() -> expensiveTransaction.getValue()`可以写作`expensiveTransaction::getValue` 。
示例：
```java
//1.转静态方法的方法引用
//原
(args) -> ClassName.staticMethod(args);
//转
ClassName::staticMethod

//2.任意类型实例
//原
(arg0, rest) -> arg0.instanceMethod(rest);
//转
ClassName::instanceMethod

//3.现有对象实例
//原
(args) -> expr.instanceMethod(args)
//转
expr::instanceMethod
```
**请注意，还有针对构造函数、数组构造函数和父类调用（`supper-call`）的一些特殊形式的方法引用**。










































dd
