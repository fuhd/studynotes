方法引用
================================================================================
**方法引用让你可以重复使用现有的方法定义**，并像Lambda一样传递它们。下面就是我们借助更新的Java8
API，用方法引用写的一个排序的例子：
```java
//先前
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
//之后使用方法引用和java.util.Comparator.comparing
inventory.sort(Comparator.comparing(Apple::getWeight));
```

## 1.管中窥豹
你为什么应该关心方法引用？**方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法**。它的基
本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如
何调用它。事实上，**方法引用就是让你根据已有的方法实现来创建Lambda表达式**。但是，**显式地指明
方法的名称，你的代码的可读性会更好。当你需要使用方法引用时，目标引用放在分隔符（`::`）前，方法的
名称放在后面**。例如，`Apple::getWeight`就是引用了`Apple`类中定义的方法`getWeight`。请记
住，**不需要括号，因为你没有实际调用这个方法**。方法引用就是Lambda表达式`(Apple a) -> a.getWeight()`
的快捷写法。下表给出了Java8中方法引用的其他一些例子：

| Lambda | 等效的方法引用 |
| :------------- | :------------- |
| (Apple a) -> a.getWeight() | Apple::getWeight |
| () -> Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
| (str, i) -> str.substring(i) | String::substring |
| (String s) -> System.out.println(s) | String.out::println |

**你可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖**。

### 1.1.如何构建方法引用
方法引用主要有三类：
1. **指向静态方法的方法引用**：例如Integer的parseInt方法，写作`Integer::parseInt`。
2. **指向任意类型实例方法的方法引用**：例如String的length方法，写作`String::length`。
3. **指向现有对象的实例方法的方法引用**：假设你有一个局部变量`expensiveTransaction`用于存放
`Transaction`类型的对象，它支持实例方法`getValue`，那么你就可以写`expensiveTransaction::getValue`。

第二种和第三种方法引用可能乍看起来有点儿晕。类似于`String::length`的 **第二种方法引用的思想就
是你在引用一个对象的方法，而这个对象本身是Lambda的一个参数**。例如，Lambda表达式
`(String s) -> s.toUppeCase()`可以写作`String::toUpperCase`。但 **第三种方法引用指的是，
你在Lambda中调用一个已经存在的外部对象中的方法**。例如，Lambda表达式
`() -> expensiveTransaction.getValue()`可以写作`expensiveTransaction::getValue` 。
示例：
```java
//1.转静态方法的方法引用
//原
(args) -> ClassName.staticMethod(args);
//转
ClassName::staticMethod

//2.任意类型实例
//原
(arg0, rest) -> arg0.instanceMethod(rest);
//转
ClassName::instanceMethod

//3.现有对象实例
//原
(args) -> expr.instanceMethod(args)
//转
expr::instanceMethod
```
**请注意，还有针对构造函数、数组构造函数和父类调用（`supper-call`）的一些特殊形式的方法引用**。

## 2.构造函数引用
**对于一个现有构造函数，你可以利用它的名称和关键字`new`来创建它的一个引用：`ClassName::new`**。
它的功能与指向静态方法的引用类似。例如，假设有一个构造函数没有参数。它适合`Supplier`的签名
`() -> Apple`。你可以这样做：
```java
//构造函数引用指向默认的Apple()构造函数
Supplier<Apple> c1 = Apple::new;
//调用Supplier的get方法将产生一个新的Apple
Apple a1 = c1.get();
```
这就等价于：
```java
Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();
```
**如果你的构造函数的签名是`Apple(Integer weight)`，那么它就适合`Function`接口的签名**，于
是你可以这样写：
```java
//指向Apple(Integer weight)的构造函数引用
Function<Integer, Apple> c2 = Apple::new;
//调用该Function函数的apply方法，并给出要求的重量，将产生一个Apple
c2.apply(110);
```
这等价于：
```java
Function<Integer, Apple> c2 = (weight) -> new Apple(weight);
Apple a2 = c2.apply(110);
```
在下面的代码中，一个由Integer构成的List中的每个元素都通过我们前面定义的类似的map方法传递给了
Apple的构造函数，得到了一个具有不同重量苹果的List：
```java
public static List<Apple> map(List<Integer> list, Function<Integer, Apple> f) {
    List<Apple> result = new ArrayList<>();
    for(Integer e: list) {
        result.add(f.apply(e));
    }
    return result;
}

List<Integer> weights = Arrays.asList(7,3,4,10);
List<Apple> apples = map(weights, Apple::new);
```
如果你有一个 **具有两个参数的构造函数`Apple(String color, Integer weight)`，那么它就适合
`BiFunction`接口的签名**，示例你可以这样写：
```java
//指向Apple(String color, Integer weight)的构造函数引用
BiFunction<String, Integer, Apple> c3 = Apple::new;
//调用该BiFunction函数的Apply方法，并给出要求的颜色和重量，将产生一个新的Apple对象
Apple a = c3.apply("green", 110);
```
这等价于：
```java
BiFunction<String, Integer, Apple> c3 = (color, weight) -> new Apple(color, weight);
Apple a = c3.apply("green", 110);
```
**不将构造函数实例化却能够引用它，这个功能有一些有趣的应用**。例如，你可以使用Map来将构造函数映
射到字符串值。你可以创建一个`giveMeFruit`方法，给它一个String和一个Integer，它就可以创建出不
同重量的各种水果：
```java
static Map<String, Function<Integer, Fruit>> map = new HashMap<>();
static {
    map.put("apple", Apple::new);
    map.put("orange", Orange::new);
    //etc......
}
public static Fruit giveMeFruit(String fruit, Integer weight) {
    return map.get(fruit.toLowerCase()).apply(weight);
}
```
```
关于构造函数引用

你已经看到了如何将有零个、一个、两个参数的构造函数转变为构造函数引用。那要怎么样才能对具有三个参数的构造函数，比如
Color(int ,int, int)，使用构造函数引用呢？

答案：你看，构造函数引用的语法是ClassName::new，那么在这个例子里面就是Color::new。但是你需要与构造函数引用的签
名匹配的函数式接口。但是语言本身并没有提供这样的函数式接口，你可以自己创建一个：
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}
现在你可以像下面这样使用构造函数引用了：
TriFunction<Integer, Integer, Integer, Color> colorFactory = Color::new;
```
