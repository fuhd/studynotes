使用函数式接口
================================================================================
**函数式接口定义且只定义了一个抽象方法**。函数式接口很有用，因为抽象方法的签名可以描述Lambda表
达式的签名。**函数式接口的抽象方法的签名称为函数描述符**。所以为了应用不同的Lambda表达式，你需
要一套能够描述常见函数描述符的函数式接口。Java API中已经有了几个函数式接口。

Java8的库设计师帮你在`java.util.function`包中引入了几个新的函数式接口。我们接下来会介绍
`Predicate`、`Consumer`和`Function`，更完整的列表可以见下表：

| 函数式接口 | 函数描述符 | 原始类型特化 |
| :------------- | :------------- | :------------- |
| Predicate<T> | `T -> boolean` | IntPredicate、LongPredicate、DoublePredicate |
| Consumer<T> | `T -> void` | IntConsumer、LongConsumer、DoubleConsumer |
| Function<T,R> | `T -> R` | IntFunction<R>、IntToDoubleFunction、IntToLongFunction、LongFunction<R>、LongToDoubleFunction、LongToIntFunction、DoubleFunction<R>、ToIntFunction<T>、ToDoubleFunction<T>、ToLongFunction<T> |
| Supplier<T> | `() -> T` | BooleanSupplier、IntSupplier、LongSupplier、DoubleSupplier |
| UnaryOperator<T> | `T -> T` | IntUnaryOperator、LongUnaryOperator、DoubleUnaryOperator |
| BinaryOperator<T> | `(T,T) -> T` | IntBinaryOperator、LongBinaryOperator、DoubleBinaryOperator |
| BiPredicate<L,R> | (L,R) -> boolean |  |
| BiConsumer<T,U> | (T,U) -> void | ObjIntConsumer<T>、ObjLongConsumer<T>、ObjDoubleConsumer<T> |
| BiFunction<T,U,R> | (T,U) -> R | ToIntBiFunction<T,U>、ToLongBiFunction<T,U>、ToDoubleBiFunction<T,U> |

## 1.Predicate
**`java.util.function.Predicate<T>`** 接口定义了一个名叫 **`test`的抽象方法**，它接受泛
型`T`对象，并返回一个boolean。在你需要 **表示一个涉及类型`T`的布尔表达式时，就可以使用这个接
口**。比如：
```java
@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}

public static <T> List<T> filter(List<T> list, Predicate<T> p) {
  List<T> results = new ArrayList<>();
  for (T s : list) {
    if(p.test(s)) {
      results.add(s);
    }
  }
  return results;
}

Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```

## 2.Consumer
**`java.util.function.Consumer<T>`** 定义了一个名叫 **`accept`的抽象方法**，它接受泛型T
的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。比如，
你可以用它来创建一个forEach方法，接受一个Integers的列表，并对其中每个元素执行操作。在下面的代码
中，你就可以使用这个forEach方法，并配合Lambda来打印列表中的所有元素。
```java
@FunctionalInterface
public interface Consumer<T> {
  void accept(T t);
}
public static <T> void forEach(List<T> list, Consumer<T> c) {
  for(T i: list) {
    c.accept(i);
  }
}
forEach(Arrays.asList(1,2,3,4,5), (Integer i) -> System.out.println(i));
```

## 3.Function
**`java.util.function.Function<T, R>`** 接口定义了一个叫作 **`apply`的方法**，它接受一
个泛型T的对象，并返回一个泛型R的对象。如果你需要定义一个Lambda，将输入对象的信息映射到输出，就可
以使用这个接口。在下面的代码中，我们向你展示如何利用它来创建一个map方法，以将一个String列表映射
到包含每个String长度的Integer列表。
```java
@FunctionalInterface
public interface Function<T, R> {
  R apply(T t);
}
public static <T, R> List<R> map(List<T> list, Function<T, R> f) {
  List<R> result = new ArrayList<>();
  for(T s: list) {
    result.add(f.apply(s));
  }
  return result;
}
List<Integer> l = map(Arrays.asList("lambdas", "in", "action"), (String s) -> s.length());
```

### 3.1.原始类型特化
回顾一下：Java类型要么是引用类型，要么是原始类型。**但是泛型（比如`Consumer<T>`中的`T`）只能
绑定到引用类型**。这是由泛型内部的实现方式造成的。因此，在Java里有一个将原始类型转换为对应的引用
类型。






































dd
