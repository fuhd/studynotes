把Lambda付诸实践：环绕执行模式
================================================================================
## 1.第一步：记得行为参数化
上篇中的示例代码是有局限的。你只能读文件的第一行。如果你想要返回头两行，甚至是返回使用最频繁的词，
该怎么办？是的，你需要把`processFile`的 **行为参数化**。

**传递行为正是Lambda的拿手好戏**。那要是想一次读两行，这个新的processFile方法看起来又该是什么
样的呢？基本上，你需要一个接收BufferedReader并返回String的Lambda。例如，下面就是从BufferedReader
中打印两行的写法：
```java
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

## 2.第二步：使用函数式接口来传递行为
**Lambda仅可用于上下文是函数式接口的情况**。你需要创建一个能匹配`BufferedReader -> String`，
还可以抛出IOException异常的接口。让我们把这一接口叫作`BufferedReaderProcessor`吧。
```java
@FunctionalInterface
public interface BufferedReaderProcessor {
  String process(BufferedReader b) throws IOException;
}
```
现在你就可以把这个接口作为新的processFile方法的参数了：
```java
public static String processFile(BufferedReaderProcessor p) throws IOException {
  ...
}
```

## 3.第三步：执行一个行为
任何`BufferedReader -> String`形式的Lambda都可以作为参数来传递，因为它们符合`BufferedReaderProcessor`
接口中定义的`process`方法的签名。
```
public static String processFile(BufferedReaderProcessor p) throws IOException {
  try(BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    return p.process(br);
  }
}
```

## 4.第四步：传递Lambda
现在你就可以通过传递不同的Lambda重用processFile方法，并以不同的方式处理文件了，处理一行：
```java
String oneLine = processFile(BufferedReader br) -> br.readLine());
```
处理两行：
```java
String twoLines = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```
