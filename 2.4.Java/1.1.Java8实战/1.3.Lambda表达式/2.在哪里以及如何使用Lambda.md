在哪里以及如何使用Lambda
================================================================================
那到底 **哪里可以使用Lambda呢**？你可以在 **函数式接口** 上使用Lambda表达式。

## 1.函数式接口
在第2章里，为了参数化`filter`方法的行为而创建的 **Predicate<T>接口** 吗？它就是一个 **函数
式接口**！为什么呢？**因为Predicate仅仅定义了一个抽象方法**：
```java
public interface Predicate<T> {
  boolean test(T t);
}
```
一言以蔽之，**函数式接口就是只定义一个抽象方法的接口**。如我们在第2章中谈到的`Comparator`和
`Runnable`。
```java
public interface Comparator<T> {
  int compare(T o1, T o2);
}

public interface Runnable {
  void run();
}
```
```
注意：

你将会在第9章中看到，接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。哪怕有很多默
认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。
```
**用函数式接口可以干什么呢？Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现**，
并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。

## 2.函数描述符
**函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。我们将这种抽象方法叫作函数描述符**。
例如，Runnable接口可以看作一个什么也不接受什么也不返回的函数的签名，因为它只有一个叫作`run`的抽
象方法，这个方法什么也不接受，什么也不返回。

现在，只要知道 **Lambda表达式可以被赋给一个变量，或传递给一个接受函数式接口作为参数的方法** 就
好了，**当然这个Lambda表达式的签名要和函数式接口的抽象方法一样**。比如，在我们之前的例子里，你可
以像下面这样直接把一个Lambda传给`process`方法：
```java
public void process(Runnable r) {
  r.run();
}

process(() -> System.out.println("This is awesome!!"));
```

### 2.1.测验：在哪里可以使用Lambda？
以下哪些是使用Lambda表达式的有效方式？
```java
//(1)
execute(() -> {});
public void execute(Runnable r) {
  r.run();
}
//(2)
public Callable<String> fetch() {
  return () -> "Tricky example;-)";
}
//(3)
Predicate<Apple> p = (Apple a) -> a.getWeight();
```
**答案：只有1和2是有效的**。第1个例子有效，是因为Lambda`() -> {}`具有签名：`() -> void`，
这和Runnable中的抽象方法`run`的签名相匹配。请注意，此代码运行后什么都不会做，因为Lambda是空的。
第2个例子也是有效的。事实上，`fetch`方法的返回类型是`Callable<String>`。`Callable<String>`
基本上就定义了一个方法，签名：`() -> String`，其中`T`被String代替了。因为Lambda
`()->"Trickyexample;-)"`的签名是：`()->String`，所以在这个上下文中可以使用Lambda。第3个例
子无效，因为Lambda表达式：`(Apple a) -> a.getWeight()`的签名是：`(Apple) -> Integer`，
这和`Predicate<Apple>:(Apple) -> boolean`中定义的`test`方法的签名不同。

```
@FunctionalInterface又是怎么回事？

如果你去看看新的Java API，会发现函数式接口带有@FunctionalInterface的标注。这个标注用于表示该接口会设计成一个函数式接口。
如果你用@FunctionalInterface定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。例如，错误消息可能
是“Multiple non-overriding abstract methods found in interface Foo“，表明存在多个抽象方法。请注意，
@FunctionalInterface不是必需的，但对于为此设计的接口而言，使用它是比较好的做法。它就像是@Override标注表示方法被重写了。
```
