类型检查、类型推断以及限制
================================================================================
**当我们第一次提到Lambda表达式时，说它可以为函数式接口生成一个实例**。然而，Lambda表达式本身并
不包含它在实现哪个函数式接口的信息。为了全面了解Lambda表达式，你应该知道Lambda的实际类型是什么。

## 1.类型检查
Lambda的类型是从使用Lambda的上下文推断出来的。**上下文中Lambda表达式需要的类型称为目标类型**。
示例：
```java
List<Apple> heavierThan150g = filter(inventory, (Apple a) -> a.getWeight() > 150);
```
类型检查过程可以分解为如下所示：
+ 首先，你要找出`filter`方法的声明。
+ 第二，要求它是`Predicate<Apple>`（目标类型）对象的第二个正式参数。
+ 第三，`Predicate<Apple>`是一个函数式接口，定义了一个叫作`test`的抽象方法。
+ 第四，`test`方法描述了一个函数描述符，它可以接受一个`Apple`，并返回一个`boolean`。
+ 最后，`filter`的任何实际参数都必须匹配这个要求。

**请注意，如果Lambda表达式抛出一个异常，那么抽象方法所声明的`throws`语句也必须与之匹配**。

## 2.同样的Lambda，不同的函数式接口
**有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名
能够兼容**。比如，前面提到的`Callable`和`PrivilegedAction`，这两个接口都代表着什么也不接受且
返回一个泛型`T`的函数。因此，下面两个赋值是有效的：
```java
Callable<Integer> c = () -> 42;
PrivilegedAtion<Integer> p = () -> 42;
```
这里，第一个赋值的目标类型是`Callable<Integer>`，第二个赋值的目标类型是
`PrivilegedAction<Integer>`。

在下表中，我们展示了一个类似的例子，同一个`Lambda`可用于多个不同的函数式接口：
```java
Comparator<Apple> c1 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
ToIntBiFunction<Apple, Apple> c2 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
BiFunction<Apple, Apple, Integer> c3 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```
```
菱形运算符

那些熟悉Java演变的人会记得，Java7已经引入了菱形运算符（<>），利用泛型推断从上下文推断类型的思想。一个类实例表达式可以出现在
两个或更多不同的上下文中，并会像下面这样推断出适当的类型参数：

List<String> listOfStrings = new ArrayList<>();
List<Integer> listOfIntegers = new ArrayList<>();
```
```
特殊的void兼容规则

如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法
的，尽管List的add方法返回了一个boolean，而不是Consumer上下文（T -> void）所要求的void：

//Predicate返回了一个boolean
Predicate<String> p = s -> list.add(s);
//Consumer返回了一个void
Consumer<String> b = s -> list.add(s);
```
**到现在为止，你应该能够很好地理解在什么时候以及在哪里可以使用Lambda表达式了。它们可以从赋值的上
下文、方法调用的上下文（参数和返回值），以及类型转换的上下文中获得目标类型**。

## 3.类型推断
你还可以进一步简化你的代码。Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表
达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处
在于，**编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型**。换句
话说，Java编译器会像下面这样推断Lambda的参数类型（请注意，当Lambda仅有一个类型需要推断的参数时，
参数名称两边的括号也可以省略）：
```java
//参数a没有显式类型
List<Apple> greenApples = filter(inventory, a -> "green".equals(a.getColor()));
```
Lambda表达式有多个参数，代码可读性的好处就更为明显。例如，你可以这样来创建一个`Comparator`对象：
```java
//没有类型推断
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
//有类型推断
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```
有时候显式写出类型更易读，有时候去掉它们更易读。没有什么法则说哪种更好。

## 4.使用局部变量
我们迄今为止所介绍的所有Lambda表达式都只用到了其主体里面的参数。**但Lambda表达式也允许使用自由
变量（不是参数，而是在外层作用域中定义的变量）**，就像匿名类一样。它们被称作捕获Lambda。例如，下
面的Lambda捕获了`portNumber`变量：
```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```
尽管如此，还有一点点小麻烦：关于能对这些变量做什么有一些限制。**Lambda可以没有限制地捕获（也就是
在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final**。换句话说，
**Lambda表达式只能捕获指派给它们的局部变量一次**。