类型检查、类型推断以及限制
================================================================================
**当我们第一次提到Lambda表达式时，说它可以为函数式接口生成一个实例**。然而，Lambda表达式本身并
不包含它在实现哪个函数式接口的信息。为了全面了解Lambda表达式，你应该知道Lambda的实际类型是什么。

## 1.类型检查
Lambda的类型是从使用Lambda的上下文推断出来的。**上下文中Lambda表达式需要的类型称为目标类型**。
示例：
```java
List<Apple> heavierThan150g = filter(inventory, (Apple a) -> a.getWeight() > 150);
```
类型检查过程可以分解为如下所示：
+ 首先，你要找出`filter`方法的声明。
+ 第二，要求它是`Predicate<Apple>`（目标类型）对象的第二个正式参数。
+ 第三，`Predicate<Apple>`是一个函数式接口，定义了一个叫作`test`的抽象方法。
+ 第四，`test`方法描述了一个函数描述符，它可以接受一个`Apple`，并返回一个`boolean`。
+ 最后，`filter`的任何实际参数都必须匹配这个要求。

**请注意，如果Lambda表达式抛出一个异常，那么抽象方法所声明的`throws`语句也必须与之匹配**。

## 2.同样的Lambda，不同的函数式接口
**有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名
能够兼容**。比如，前面提到的`Callable`和`PrivilegedAction`，这两个接口都代表着什么也不接受且
返回一个泛型`T`的函数。因此，下面两个赋值是有效的：
```java
Callable<Integer> c = () -> 42;
PrivilegedAtion<Integer> p = () -> 42;
```
这里，第一个赋值的目标类型是`Callable<Integer>`，第二个赋值的目标类型是
`PrivilegedAction<Integer>`。

在下表中，我们展示了一个类似的例子，同一个`Lambda`可用于多个不同的函数式接口：
```java
Comparator<Apple> c1 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
ToIntBiFunction<Apple, Apple> c2 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
BiFunction<Apple, Apple, Integer> c3 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```
```
菱形运算符

那些熟悉Java演变的人会记得，Java7已经引入了菱形运算符（<>），利用泛型推断从上下文推断类型的思想。一个类实例表达式可以
出现在两个或更多不同的上下文中，并会像下面这样推断出适当的类型参数：

List<String> listOfStrings = new ArrayList<>();
List<Integer> listOfIntegers = new ArrayList<>();
```



