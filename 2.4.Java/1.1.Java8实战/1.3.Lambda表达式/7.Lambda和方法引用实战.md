Lambda和方法引用实战
================================================================================
这一章以示例来讨论所有关于Lambda的内容收个尾，我们需要继续研究开始的那个问题————**用不同的排序
策略给一个Apple列表排序**，并需要展示如何把一个原始粗暴的解决方案转变得更为简明。这会用到书中迄
今讲到的所有概念和功能：**行为参数化、匿名类、Lambda表达式和方法引用**。

## 1.第一步：传递代码
Java8的API已经为你提供了一个List可用的sort方法，你不用自己去实现它。但是如何把排序策略传递给sort
方法呢？你看，sort方法的签名是这样的：
```java
void sort(Comparator<? super E> c)
```
它需要一个Comparator对象来比较两个Apple！这就是在Java中传递策略的方式：它们必须包裹在一个对象
里。我们说sort的行为被参数化了：传递给它的排序策略不同，其行为也会不同。

你的第一个解决方案看上去是这样的：
```java
public class AppleComparator implements Comparator<Apple> {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
}
```
```java
inventory.sort(new AppleComparator());
```

## 2.第二步：使用匿名类
你可以使用匿名类来改进解决方案，而不是实现Comparator却只实例化一次：
```java
inventory.sort(new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
});
```

## 3.第三步：使用Lambda表达式
Java8引入了Lambda表达式，它提供了一种轻量级语法来实现相同的目标：**传递代码。在需要函数式接口的
地方可以使用Lambda表达式**。我们回顾一下：**函数式接口就是仅仅定义一个抽象方法的接口**。抽象方
法的签名（称为 **函数描述符**）描述了Lambda表达式的签名。在这个例子里，Comparator代表了函数描
述符`(T, T) -> int`。因为你用的是苹果，所以它具体代表的就是`(Apple, Apple) -> int`。改进
后的新解决方案看上去就是这样的了：
```java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
```
我们前面解释过了，**Java编译器可以根据Lambda出现的上下文推断Lambda表达式参数的类型**。那么你
的解决方案就可以重写成这样：
```java
inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight()));
```
你的代码还能变得更易读一点吗？**Comparator具有一个叫作comparing的静态辅助方法，它可以接受一
个Function来提取Comparable键值，并生成一个Comparator对象**。它可以像下面这样用（**注意你现
在传递的Lambda只有一个参数**：Lambda说明了如何从苹果中提取需要比较的键值）：
```java
Comparator<Apple> c = Comparator.comparing((Apple a) -> a.getWeight());
```
现在你可以把代码再改得紧养伤一点了：
```java
import static java.util.Comparator.comparing;

imventory.sort(Comparing((a) -> a.getWeight()));
```

## 4.第4步：使用方法引用
**方法引用就是替代那些转发参数的Lambda表达式的语法糖**。你可以用方法引用让你的代码更简洁（假设
你静态导入了`java.util.Comparator.comparing`）：
```java
inventory.sort(comparing(Apple::getWeight));
```
恭喜你，这就是你的最终解决方案！这比java8之前的代码好在哪儿呢？**它比较短**。
