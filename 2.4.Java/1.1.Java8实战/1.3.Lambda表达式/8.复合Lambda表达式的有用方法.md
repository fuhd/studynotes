复合Lambda表达式的有用方法
================================================================================
Java8的好几个函数式接口都有为方便而设计的方法。具体而言，**许多函数式接口，比如用于传递Lambda
表达式的`Comparator`、`Function`和`Predicate`都提供了允许你进行复合的方法**。这是什么意思
呢？在实践中，**这意味着你可以把多个简单的Lambda复合成复杂的表达式**。比如，你可以让两个谓词之
间做一个or操作，组合成一个更大的谓词。而且，你还可以让一个函数的结果成为另一个函数的输入。你可能
会想，**函数式接口中怎么可能有更多的方法呢**？（毕竟，这违背了函数式接口的定义啊！）窍门在于，我
们即将介绍的方法都是 **默认方法，也就是说它们不是抽象方法**。

## 1.比较器复合
我们前面看到，你可以使用 **静态方法** `Comparator.comparing`，根据提取用于比较的键值的Function
来返回一个Comparator，如下所示：
```java
comparator<Apple> c = Comparator.comparing(Apple::getWeight);
```
### 1.1.逆序
如果你想要 **对苹果按重量递减排序怎么办？用不着去建立另一个Comparator的实例。接口有一个默认方法
reversed可以使给定的比较器逆序**。因此仍然用开始的那个比较器，只要修改一下前一个例子就可以对苹
果按重量递减排序：
```java
//按重量递减排序
inventory.sort(comparing(Apple::getWeight).reversed());
```
### 1.2.比较器链
上面说得都很好，**但如果发现有两个苹果一样重版块么办？哪个苹果应该排在前面呢？你可能需要再提供一
个Comparator来进一步定义这个比较**。比如，在按重量比较两个苹果之后，你可能想要按原产国排序，
**thenComparing方法就是做这个用的。它接受一个函数作为参数（就像comparing方法一样），如果两个
对象用第一个Comparator比较之后是一样的，就提供第二个Comparator**。你又可以优雅地解决这个问题
了：
```java
//按重量递减排序，两个苹果一样重时，进一步按国家排序
inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry));
```


































DDD
