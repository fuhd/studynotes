泛型基本概念
===============================================================
J2SE5.0引入了泛型的语言特性。泛型中包含的具体内容比较多，主要包括 **泛型类型和泛型方法的声明和实例化**。
泛型的引入也对Java标准库中的很多API造成了影响。泛型类型与一般类型的区别在于，泛型类型有 **形式类型参数（
`type parameter`）**，可以在泛型类型 **被实例化时** 替换成 **实际的具体类型（`type argument`）**。
示例：
```java
//声明泛型类型的示例
public class ObjectHolder<T> {
    private T obj;
    public T getObject() {
        return obj;
    }
    public void setObject(T obj) {
        this.obj = obj;
    }
}
```
如上例，与一般的类型不同，**泛型类型声明中的`<T>`用来表示形式类型参数`T`。形式类型参数`T`可以用在泛型类型
实现的代码中**。

**泛型类的使用** 与一般的Java类并没有太大的区别，**只是需要为其中声明的形式类型参数指定实际的类型**。
示例：
```java
//使用泛型类型的示例
ObjectHolder<String> holder = new ObjectHolder<String>();
holder.setObject("Hello");
String str = holder.getObject();
```
在创建出泛型类的对象之后，该对象在使用时的类型是受限的。如上例中的`holder`对象，在调用`setObject()`
方法时，参数的类型只能是`String`类型；`getObject()`方法的返回值也是`String`类型。如果不使用泛型
来实现类似的功能，那么`setObject()`方法的参数声明只能是`Object`类。

在实例化之后，泛型类型声明中的形式类型参数被替换成实际的类型。实例化之后的泛型类型被称为 **参数化类型（
`parameterized type`）**。`ObjectHolder<String>`是一种参数化类型。对于同一个泛型类型来说，
可能的参数化类型的数量非常多。**根据使用的实际类型，参数化类型分为两类**：
+ **不带通配符的类型**；
+ **带通配符的类型**；

**通配符（`wildcard`）“`?`”的作用是表示一组类型的集合，可以匹配特定范围内的类型。在使用通配符时可以指定
其上界或下界。通过添加上界或下界可以限制通配符表示的具体类型的范围。不包含上界或下界的通配符被称为无界通
配符（`unbounded wildcard`）。例如，参数化类型`ObjectHolder<?>`表示其中包含的对象的具体类型是不确定的，
可以是任何类型。在声明形式类型参数时也可以指定上界，用来限制实例化时可用的实际类型的范围**。

在Java中，**除了枚举类型、匿名内部类型和异常类型之外**，其他类型都可以添加形式类型参数，成为泛型类型。
**形式类型参数的名称可以是Java中任何合法的标识符**。一般使用 **单个大写字母作为形式类型参数的名称**，
以区别于一般的标识符。形式类型参数可以有多个，如“`MyClass<S,U,V>`”中声明了3个形式类型参数。不同的形式
类型参数在代码中表示不同的含义。以集合类框架为例，`List`接口只包含一个形式类型参数，表示列表中包含的元素的
类型；而`Map`接口则包含两个形式类型参数，分别表示映射表中条目的键合值的类型。

**形式类型参数** 类似于一般的类型，但是两者存在一些差别。两者的共同之处在于都可以作为类型使用在某些场合，
包括 **作为方法的参数和返回值类型、作为域和局部变量的类型声明、进行强制类型转换及作为泛型类型和泛型方法的实际
类型参数**。但是形式类型参数在某些情况下是不能使用的，**包括不能用来创建对象和数组、不能作为父类型、不能使用
在`instanceof`表达式中、不能使用其类型字面量、不能出现在异常处理中，以及不能出现在静态上下文中**。
这就意味着，如果`T`是形式类型参数，类似“`new T()`”、“`new T[]`”、“`class MyClass extends T`”、
“`instanceof T`”、“`T.class`”、“`catch(T)`”和“`static T`”等都是无法通过编译的错误用法。
**这些限制源于Java中泛型类型的实现机制，即类型擦除（`type erasure`）**。

**为了兼容J2SE 5.0之前的遗留代码，泛型类型在使用时可以不指定实际类型**。如果不指定实际类型而直接使用类型
声明，所得到的类型被称为 **原始类型（`raw type`）**。如果在代码中直接使用`ObjectHolder`进行声明，
则使用的是泛型类`ObjectHolder`的原始类型。**原始类型的作用是与无法使用泛型的遗留代码进行交互**。除此之外，
原始类型不应该用在其他地方，否则引入泛型就变得毫无意义。使用原始类型是不安全的操作，编译器会给出相关的警告
信息。

**在构造方法或一般方法的声明中也可以使用形式类型参数。包含形式类型参数的方法被称为泛型方法**。
泛型方法与泛型类型并没有直接的关系。**在一个非泛型类型中同样可以包含泛型方法。泛型类型中的泛型方法
可以使用在类型中定义的形式类型参数，也可以使用自己的形式类型参数**。






