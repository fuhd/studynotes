类型擦除
====================================================================
**类型擦除是Java中泛型的实现方式。泛型是在编译器这个层次来实现的**。在Java源代码中声明的泛型类型信息，
在编译过程中会被擦除，只保留不带类型参数的形式。**被擦除的类型信息包括泛型类型和泛型方法声明时的形式类型参数，
以及参数化类型中的实际类型信息**。经过类型擦除之后，包含泛型类型的代码被转换成不包含泛型类型的代码，
**相当于回到了泛型被引入之前的形式**。Java虚拟机在运行字节码时并不知道泛型类型的存在。虽然为了反射API的需要，
在Java字节码中包含了与泛型类型相关的信息，但这些信息在字节码执行时是不被使用的。与泛型相关的类型检查由编译器
在编译时进行。

### 基本概念
编译器和虚拟机所能区分的类型是不同的：**对于编译器来说，`List<String>`和`List<Integer>`是不同的类型；
而对于虚拟机来说，这两者的类型都是`List`**。在运行时可用的类型被称为 **可具体化类型（`reifiable type`）**。
**Java中的可具体化类型** 包括 **非泛型类型、所有实际类型都是无界通配符的参数化类型、原始类型、基本类型、元素类型为
可具体化类型的数组类型、以及父类型和自身都是可具体化类型的嵌套类型。举例来说，`String`、`List<?>`、`List`、`int`、`String[]`、
和`MyClass<?>.Inner`都是可具体化类型**。

**除了实际类型都是无界通配符的参数化类型外**，Java泛型实现中的最重要的特点是 **几乎所有参数化类型都是不可具体化的**。
如`List<String>`和`List<? extends Number>`等类型都是不可具体化的。虚拟机在执行字节代码时只能使用运行时
可用的可具体化类型。这使Java中与虚拟机相关的语法特性对于不可具体化的参数化类型是不可用的。以异常处理为例，
**Java代码运行时的异常捕获和处理是由虚拟机来完成的。因此异常类型必须是可具体化的。任何泛型类型都不能直接或
间接继承自`Throwable`类**。Java采用这种做法实现泛型的根本出发点是保持Java平台的兼容性，保证泛型引入之前的字节码
在不经过任何修改的情况下就可以在新版本的虚拟机上运行。因此，**Java选择在编译器这个层次来实现泛型，而保持虚拟机不变**。

