类型擦除
====================================================================
**类型擦除是Java中泛型的实现方式。泛型是在编译器这个层次来实现的**。在Java源代码中声明的泛型类型信息，
在编译过程中会被擦除，只保留不带类型参数的形式。**被擦除的类型信息包括泛型类型和泛型方法声明时的形式类型参数，
以及参数化类型中的实际类型信息**。经过类型擦除之后，包含泛型类型的代码被转换成不包含泛型类型的代码，
**相当于回到了泛型被引入之前的形式**。Java虚拟机在运行字节码时并不知道泛型类型的存在。虽然为了反射API的需要，
在Java字节码中包含了与泛型类型相关的信息，但这些信息在字节码执行时是不被使用的。与泛型相关的类型检查由编译器
在编译时进行。

### 基本概念
编译器和虚拟机所能区分的类型是不同的：**对于编译器来说，`List<String>`和`List<Integer>`是不同的类型；
而对于虚拟机来说，这两者的类型都是`List`**。在运行时可用的类型被称为 **可具体化类型（`reifiable type`）**。
**Java中的可具体化类型** 包括 **非泛型类型、所有实际类型都是无界通配符的参数化类型、原始类型、基本类型、元素类型为
可具体化类型的数组类型、以及父类型和自身都是可具体化类型的嵌套类型。举例来说，`String`、`List<?>`、`List`、`int`、`String[]`、
和`MyClass<?>.Inner`都是可具体化类型**。

**除了实际类型都是无界通配符的参数化类型外**，Java泛型实现中的最重要的特点是 **几乎所有参数化类型都是不可具体化的**。
如`List<String>`和`List<? extends Number>`等类型都是不可具体化的。虚拟机在执行字节代码时只能使用运行时
可用的可具体化类型。这使Java中与虚拟机相关的语法特性对于不可具体化的参数化类型是不可用的。以异常处理为例，
**Java代码运行时的异常捕获和处理是由虚拟机来完成的。因此异常类型必须是可具体化的。任何泛型类型都不能直接或
间接继承自`Throwable`类**。Java采用这种做法实现泛型的根本出发点是保持Java平台的兼容性，保证泛型引入之前的字节码
在不经过任何修改的情况下就可以在新版本的虚拟机上运行。因此，**Java选择在编译器这个层次来实现泛型，而保持虚拟机不变**。

在类型擦除过程中需要处理形式类型参数和参数化类型中的实际类型。**对于形式类型参数，在泛型类型声明中的部分会被直接删除，
如`ObjectHolder<T>`被替换成`ObjectHolder`；在泛型类型代码中出现的则根据上界替换成具体的类型。如果形式类型参数
声明了上界，则声明中最左边的上界作为进行替换的类型；如果没有上界，则使用`Object`类进行替换。而对于参数化类型的实际
类型，它们在代码中的出现会被直接删除。进行这些替换之后，可能会出现代码逻辑不合法的情况，编译器会通过插入适当的强制类型
转换代码和生成桥接方法（`bridge method`）来解决**。
