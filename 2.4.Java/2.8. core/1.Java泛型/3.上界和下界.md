上界和下界
==================================================================
泛型类型和泛型方法与一般类型和方法的区别在于可以声明形式类型参数。在实际的类型声明中，
形式类型参数会被替换成具体的类型。**虽然形式类型参数在源代码中可以使用，但其使用方式是受限的**。
**编译器把形式类型参数当成实际类型的占位符**。编译器不能对实际声明时可能使用的类型做出任何假定，
只能使用最严格的检查方式，以避免出现类型安全错误。

如果希望限制在实际类型声明时可以使用的类型，那么可以为形式类型参数添加上界。**在添加了上界之后，
泛型类型在实例化时只能使用由上界表示的类型及其子类型**。示例：
```java
// 形式类型参数的上界
public class ComparableObjectHolder<T extends Comparable<T>> {
    private T obj;
    public int compareTo(T anotherObj) {
        return obj.compareTo(anotherObj);
    }
}
```
上例中，**通过`extends`关键词为形式类型参数T添加了上界`Comparable<T>`接口。声明泛型类型时的实际类型
必须实现`Comparable`接口**，否则会出现编译错误。**这样可以确保实际类型实现了`Comparable`接口，可以在代码
中调用参数对象的`compareTo`方法**。如果没有显式指定上界，那么默认的上界是`Object`类。**形式类型参数虽然有
上界，但是没有上界**，这是因为下界在实际中几乎没有作用。

**形式类型参数上界的作用是限制泛型类型实例化时可以使用的类型，可以在代码中使用上界类型中提供的公开成员，
包括公开的方法、域和嵌套类型，但是不包括构造方法。这是因为构造方法是不被继承的**。

**除了基本类型和数组类型之外的其他类型都可以作为形式类型参数的上界，其中除了一般的类和接口之外，还包括参数化类型
和形式类型参数。对于`int`和`float`等基本类型，可以使用其对应的包装类来作为上界。对于数组类型，可以使用集合类
框架中的类或接口来替代**。示例：
```java
// 使用形式类型参数作为上界
public class SampleClass<S extends T, T> {
    public void test() {
        SampleClass<String, Comparable<String>> obj = new SampleClass<>();
    }
}
```







