如何在Java中使用双重检查锁实现单例
==================================================================
单例类在Java开发者中非常常用，但是它给开发者们造成了很多挑战。在整个应用生命周期中，要保证只有单例类的一个实例被创建，
**双重检查锁（`Double checked locking of Singleton`）是一种实现方法**。顾名思义，**在双重检查锁中，
代码会检查两次单例类是否有已存在的实例，一次加锁一次不加锁，其中一次确保不会有多个实例被创建**。
顺便提一下，**在JDK1.5中，Java修复了其内存模型的问题。在JDK1.5之前，这种方法会有问题**。本文中，
我们将会看到怎样用Java实现双重检查锁的单例类，为什么Java5之前的版本双重检查锁会有问题，以及怎么解决这个问题。

### 为什么你需要双重检查锁来实现单例类？
一个常见情景，单例类在多线程环境中违反契约。如果你要一个新手写出单例模式，可能会得到下面的代码：
```java
private static Singleton _instance;
public static Singleton getInstance() {
    if(_instance == null) {
        _instance = new Singleton();
    }
    return _instance;
}
```
然后，当你指出这段代码在超过一个线程并行被调用的时候会创建多个实例的问题时，**你很可能会把整个`getInstance()`方法
设为同步（`synchronized`）**，示例：
```java
public static Singleton getInstance() {
    if (_instance == null) {
        _instance = new Singleton();
    }
    return _instance;
}
```
**尽管这样做到了线程安全，并且解决了多实例问题，但并不高效。在任何调用这个方法的时候，你都需要承受
同步带来的性能开销，然而同步只在第一次调用的时候才被需要，也就是单例类实例创建的时候。这将促使我们
使用双重检查锁模式（`double checked locking pattern`），一种只在临界区代码加锁的方法。
程序员称其为双重检查锁，因为会有两次检查`_instance == null`，一次不加锁，另一次在同步块上加锁**。
这就是使用Java双重检查锁的示例：
```java
public static Singleton getInstanceDC() {
    if(_instance == null) {     //Single Checked
        synchronized(Singleton.class) {
            if(_instance == null) {     // Double checked
                _instance = new Singleton();
            }
        }
    }
    return _instance;
}
```
这个方法表面上看起来很完美，你只需要付出一次同步块的开销，但它依然有问题。除非你声明`_instance`变量时
使用了`volatile`关键字。**没有`volatile`修饰符，可能出现Java中的另一个线程看到个初始化了一半的`_instance`的情况**，
但使用了`volatile`变量后，就能保证先行发生关系（`happens-before relationship`）。**对于`volatile`变量`_instance`，
所有的写（`write`）都将先行发生于读（`read`），在Java5之前不是这样，所以在这之前使用双重检查锁有问题**。现在，
有了先行发生的保障（`happens-beffore guarantee`），你可以安全地假设其会工作良好。




