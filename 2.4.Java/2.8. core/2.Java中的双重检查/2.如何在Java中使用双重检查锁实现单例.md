如何在Java中使用双重检查锁实现单例
==================================================================
单例类在Java开发者中非常常用，但是它给开发者们造成了很多挑战。在整个应用生命周期中，要保证只有单例类的一个实例被创建，
**双重检查锁（`Double checked locking of Singleton`）是一种实现方法**。顾名思义，**在双重检查锁中，
代码会检查两次单例类是否有已存在的实例，一次加锁一次不加锁，其中一次确保不会有多个实例被创建**。
顺便提一下，**在JDK1.5中，Java修复了其内存模型的问题。在JDK1.5之前，这种方法会有问题**。本文中，
我们将会看到怎样用Java实现双重检查锁的单例类，为什么Java5之前的版本双重检查锁会有问题，以及怎么解决这个问题。

### 为什么你需要双重检查锁来实现单例类？
一个常见情景，单例类在多线程环境中违反契约。如果你要一个新手写出单例模式，可能会得到下面的代码：
```java
private static Singleton _instance;
public static Singleton getInstance() {
    if(_instance == null) {
        _instance = new Singleton();
    }
    return _instance;
}
```
然后，当你指出这段代码在超过一个线程并行被调用的时候会创建多个实例的问题时，**你很可能会把整个`getInstance()`方法
设为同步（`synchronized`）**，示例：
```java
public static Singleton getInstance() {
    if (_instance == null) {
        _instance = new Singleton();
    }
    return _instance;
}
```



