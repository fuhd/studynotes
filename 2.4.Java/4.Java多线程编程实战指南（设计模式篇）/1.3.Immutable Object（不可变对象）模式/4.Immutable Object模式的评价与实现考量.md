Immutable Object模式的评价与实现考量
===============================================================================================
**不可变对象具有天生的线程安全性**，多个线程共享一个不可变对象的时候无须使用额外的并发访问控制，这使得我们可以避免显式锁等
并发控制的开销和问题，简化了多线程编程。

### Immutable Object模式适用场景
+ **被建模对象的状态变化不频繁**：正如本章案例所展示的，这种场景下可以 **设置一个专门的线程（`Manipulator`参与者所在的线程）
用于在被建模对象状态变化时创建新的不可变对象。而其他线程则只是读取不可变对象的状态**。此场景下的一个小技巧是`Manipulator`对
**不可变对象的引用采用`volatile`关键字修饰，既可以避免使用显式销（如`synchronized`），又可以保证多线程间的内存可见性**。
+ **使用某个对象作为安全的`HashMap`的`Key`**：我们知道，**一个对象作为`HashMap`的`Key`被“放入”`HashMap`之后，若该对象状态
变化导致了其`Hash Code`的变化，则会导致后面在用同样的对象作为`Key`去`get`的时候无法获取关联的值**，尽管该`HashMap`中的确存在
以该对象为`Key`的条目。相反，**由于不可变对象的状态不变，因此其`Hash Code`也不变**。这使得不可变对象非常适于用作`HashMap`的`Key`。
+ **同时对一组相关的数据进行写操作，因此需要保证原子性**：此场景为了保证操作的原子性，通常的做法是使用显式锁。但若采用`Immutable Object`
模式，将这一组相关的数据“组合”成一个不可变对象，则对这一组数据的操作就可以无须加显式锁也能保证原子性，这既简化了编程，又提高了代码运行
效率。

### Immutable Object模式实现时需要注意以下几个问题
+ **被建模对象的状态变更比较频繁**：此时也不见得不能使用`Immutable Object`模式。**只是这意味着频繁创建新的不可变对象，因此会增加`JVM`
垃圾回收（`Garbage Collection`）的负担和`CPU`消耗**，我们需要综合考虑：被建模对象的规模、代码目标运行环境的`JVM`内存分配情况、
系统对吞吐率和响应性的要求。若这几个方面因素综合考虑都能满足要求，那么使用不可变对象建模也未尝不可。
+ **使用等效或者近似的不可变对象**：有时创建严格意义上的不可变对象比较难，但是尽量向严格意义上的不可变对象靠拢也有利于发挥不可变对象
的好处。
+ **防御性复制**：如果不可变对象本身包含一些状态需要对外暴露，而相应的字段本身又是可变的（如`HashMap`），那么返回这些字段的方法还是
需要做防御性复制，以避免外部代码修改了其内部状态。

