原子性、内存可见性和重排序——重新认识synchronized和volatile
===============================================================================
**原子（`Atomic`）操作指相应的操作是单一不可分割的操作**。例如，对`int`型变量`count`执行`count++`的操作
就 **不是原子操作**。这是因为`count++`实际上可以分解为`3`个操作：
1. 读取变量`count`的当前值；
2. 拿`count`的当前值和`1`做加法运行；
3. 将`count`的当前值增加`1`后的值赋值给`count`变量；

在多线程环境中，非原子操作可能会受其他线程的干扰。比如，上述例子如果没有对相应的代码进行同步（`Synchronization`）处理，
则可能出现在执行第`2`个操作的时候`count`的值已经被其他线程修改了，因此这一步的操作所使用的`count`变量的“当前值”
其实已经是过期的了。当然，**`synchronized`关键字可以帮助我们实现操作的原子性，以避免这种线程间的干扰情况**。

**`synchronized`关键字可以实现操作的原子性，其本质是通过该关键字所包括的临界区（`Critical Section`）的排他性
保证在任何一个时刻只有一个线程能够执行临界区中的代码，这使得临界区中的代码代表了一个原子操作**。这一点，读者可能已经
很清楚。但是，**`synchronized`关键字所起的另外一个作用————保证内存的可见性（`Memory Visibility`）**，也是值得我们
回顾的。

**`CPU`在执行代码的时候，为了减少变量访问的时间消耗可能将代码中访问的变量的值缓存到该`CPU`的缓存区（如`L1 Cache`、
`L2 Cache`等）中。因此相应代码再次访问某个变量时，相应的值可能是从`CPU`缓存区而不是主内存中读取的。同样地，代码对这些
被缓存过的变量的值的修改也可能仅是被写入`CPU`缓存区，而没有被写回主内存。由于每个`CPU`都有自己的缓存区，因此一个
`CPU`缓存区中的内容对于其他`CPU`而言是不可见的。这就导致了在其他`CPU`上运行的其他线程可能无法“看到”该线程对某个变量值
所做的更改。这就是所谓的内存可见性**。

`synchronized`关键字的另外一个作用就是它保证了一个线程执行临界区中的代码时所修改的变量值对于稍后执行该临界区中的代码的
线程来说是可见的。这对于保证多线程代码的正确性来说非常重要。

**而`volatile`关键字也能够保证内存可见性。即一个线程对一个采用`volatile`关键字修饰的变量的值的更改对于其他访问该变量
的线程而言总是可见的**。也就是说，其他线程不会读到一个“过期”的变量值。因此，有人将`volatile`关键字与`synchronized`
关键字所代表的内部锁做比较，将其称为轻量级的锁。这种称呼其实并不恰当，**`volatile`关键字只能保证内存可见性，它并不能像
`synchronized`关键字所代表的内部锁那样能够保证操作的原子性。`volatile`关键字实现内存可见性的核心机制是当一个线程修改
了一个`volatile`修饰的变量的值时，该值会被写入主内存（即`RAM`）而不仅仅是当前线程所在的`CPU`的缓存区，而其他`CPU`的缓存
区中存储的该变量的值也会因此而失效（从而得以更新为主内存中该变量的相应值）。这就保证了其他线程访问该`volatile`修饰的变量
时总是可以获取该变量的最新值**。

**`volatile`关键字的另外一个作用是它禁止了指令重排序。编译器和`CPU`为了提高指令的执行效率可能会进行指令重排序，这使得代码的
实际执行方式可能不是按照我们所认为的方式进行的**。例如下面的实例变量初始化语句：
```java
private SomeClass someObject = new SomeClass();
```
上述语句所做的事情非常简单：
1. 创建类`SomeClass`的实例；
2. 将类`SomeClass`的实例的引用赋值给变量`someObject`。

但是由于指令重排序的作用，这段代码的实际执行顺序可能是：
1. 分配一段用于存储`SomeClass`实例的内存空间；
2. 将对该内存空间的引用赋值给变量`someObject`；
3. 创建类`SomeClass`的实例。

因此，当其他线程访问`someObject`变量的值时，其得到的仅是指向一段存储`SomeClass`实例的内存空间的引用而已，
而该内存空间相应的`SomeClass`实例的初始化可能尚未完成，这就可能导致一些意想不到的结果。**而禁止指令重排序则可以
使得上述代码按照我们所期望的顺序（正如代码所表达的顺序）来执行**。

**禁止指令重排序虽然导致编译器和`CPU`无法对一些指令进行可能的优化，但是它某种程序上让代码的执行看起来更符合我们的期望**。

**`synchronized`即能保证操作的原子性，又能保证内存可见性。而`volatile`仅能保证内存可能性、禁止指令重排序。
但是，前者会导致上下文切换，而后者不会**。
















