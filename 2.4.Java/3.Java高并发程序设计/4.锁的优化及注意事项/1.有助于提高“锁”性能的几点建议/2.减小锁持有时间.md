减小锁持有时间
===========================================================
**在锁竞争过程中，单个线程对锁的持有时间与系统性能有着直接的关系**。如果线程持有锁的时间很长，那么相对地，
锁的竞争程度也就越激烈。**程序开发中，应该尽可能地减少对某个锁的占有时间，以减少线程间互斥的可能**。示例：
```java
public synchronized void syncMethod(){
  othercode1();
  mutextMethod();
  othercode2();
}
```
syncMethod()方法中，假设只有mutextMethod()方法是有同步需要的，而othercode1()和othercode2()
并不需要做同步控制。如果othercode1()和othercode2()分别是重量级的方法，则会花费较长的CPU时间。此时，
如果在并发量较大，使用这种对整个方法做同步的方案，会导致等待线程大量增加。因为一个线程，在进入该方法时
获得内部锁，只有在所有任务都执行完后，才会释放锁。

**一个较为优化的解决方案是，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量**。
```java
public void syncMethod2(){
  othercode1();
  synchronized(this){
    mutextMethod();
  }
  othercode2();
}
```
**注意：减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力**。
