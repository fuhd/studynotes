Java中的双重检查（Double-Check）详解
============================================================================
**在`Effective Java`一书的第`48`条中提到了双重检查模式，并指出这种模式在Java中通常并不适用**。该模式的结构如下：
```java
public Resource getResoure() {
    if(resource == null) {
        synchronized(this) {
            if(resource == null) {
                resource = new Resource();
            }
        }
    }
    return resoure;
}
```
该模式是对下面的代码改进：
```java
public synchronized Resource getResource() {
    if(resource == null) {
        resource = new Resource();
    }
    return resource;
}
```
**这段代码的目的是对`resource`延迟初始化。但是每次访问的时候都需要同步。为了减少同步的开销，于是有了双重检查模式**。

**在Java中双重检查模式无效的原因是在不同步的情况下引用类型不是线程安全的。对于除了`long`和`double`的基本类型，
双重检查模式是适用的**。比如下面这段代码就是正确的：
```java
private int count;
public int getCount() {
    if(count == 0) {
        synchronized(this) {
            if(count == 0) {
                count = computeCount(); //一个耗时的计算
            }
        }
    }
    return count;
}
```
上面就是关于Java中双重检查模式的一般结论。但是事情还没有结束，因为Java的内存模型也在改进中。
`Doug Lea`在他的文章中写道：“**根据最新的`JSR133`的Java内存模型，如果将引用类型声明为`volatile`，
双重检查模式就可以工作了**”。所以以后要在Java中使用双重检查模式，可以使用下面的代码：
```java
private volatile Resource resource;
public Resource getResource() {
    if(resource == null) {
        synchronized(this) {
            if(resource == null) {
                resource = new Resource();
            }
        }
    }
    return resource;
}
```
所以，**双重检查（`double-check`）在`J2SE 1.4`或早期版本中，在多线程或者JVM调优时由于无序写（`out-of-order writes`），
是不可用的。这个问题在`J2SE 5.0`中已经被修复，可以使用`volatile`关键字来保证多线程下的单例**。
```java
public class Singleton {
    private volatile Singleton instance = null;
    public Singleton getInstance() {
        if(instance == null) {
            synchronized(this) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
当然了，**创建单例对象的推荐方法是：`Initialization on Demand Holder(IODH)`**。示例：
```java
public class Singleton {
    static class SingletonHolder {
        static Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```
