自定义加载器
================================================================================
## 1.JDK中的ClassLoader
在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：
```java
protected synchronized Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
  // First, check if the class has already been loaded
  Class c = findLoadedClass(name);
  if (c == null) {
    try {
      if (parent != null) {
        c = parent.loadClass(name, false);
      } else {
        c = findBootstrapClass0(name);
      }
    } catch (ClassNotFoundException e) {
      // If still not found, then invoke findClass in order
      // to find the class.
      c = findClass(name);
    }
  }
  if (resolve) {
    resolveClass(c);
  }
  return c;
}
```
方法原理很简单，一步一步解释一下：
1. 第4行，首先查找`.class`是否被加载过。
2. 第5行~第11行，如果`.class`文件没有被加载过，那么会去找加载器的父加载器。如果父加载器不是null
（不是Bootstrap ClassLoader），那么就执行父加载器的loadClass方法，把类加载请求一直向上抛，
直到父加载器为null（是Bootstrap ClassLoader）为止。
3. 第12行~第16行，父加载器开始尝试加载`.class`文件，加载成功就返回一个`java.lang.Class`，加
载不成功就抛出一个ClassNotFoundException，给子加载器去加载。
4. 第18行~第20行，如果要解析这个`.class`文件的话，就解析一下，**主要就是将符号引用替换为直接引
用的过程**。

我们看一下`findClass`这个方法：
```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
  throw new ClassNotFoundException(name);
}
```
是的，没有具体实现，只抛了一个异常，而且是`protected`的，这充分证明了：**这个方法就是给开发者重
写用的**。

## 2.自定义类加载器
从上面对于`java.lang.ClassLoader`的`loadClass(String name, boolean resolve)`方法的解
析来看，可以得出以下2个结论：
1. **如果不想打破双亲委派模型，那么只需要重写findClass方法即可**。
2. **如果想打破双亲委派模型，那么就重写整个loadClass方法**。

**当然，我们自定义的ClassLoader不想打破双亲委派模型，所以自定义的ClassLoader继承自
`java.lang.ClassLoader`并且只重写`findClass`方法**。

### 2.1.第一步
自定义一个实体类`Person.java`，我把它编译后的`Person.class`放在指定的目录下：
```java
package com.fuhd;

public class Person {

    private String name;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "I am a person, my name is " + name;
    }
}
```

### 2.2.第二步
自定义一个类加载器，里面主要是一些IO和NIO的内容，**另外注意一下`defineClass`方法可以把二进制
流字节组成的文件转换为一个`java.lang.Class`————只要二进制字节流的内容符合Class文件规范**。
我们自定义的`MyClassLoader`继承自`java.lang.ClassLoader`，就像上面说的，只实现findClass
方法：
```java
package com.fuhd;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;

public class MyClassLoader extends ClassLoader {

    public MyClassLoader() {
    }

    public MyClassLoader(ClassLoader parent) {
        super(parent);
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        File file = getClassFile(name);
        System.out.println(name);
        try {
            byte[] bytes = getClassBytes(file);
            Class<?> c = this.defineClass(name, bytes, 0, bytes.length);
            return c;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return super.findClass(name);
    }

    private File getClassFile(String name) {
        File file = new File("/home/fuhd/work/Person.class");
        return file;
    }

    private byte[] getClassBytes(File file) throws Exception {
        // 这里要读入.class的字节，因此要使用字节流
        FileInputStream fis = new FileInputStream(file);
        FileChannel fc = fis.getChannel();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        WritableByteChannel wbc = Channels.newChannel(baos);
        ByteBuffer by = ByteBuffer.allocate(1024);

        while (true) {
            int i = fc.read(by);
            if (i == 0 || i == -1)
                break;
            by.flip();
            wbc.write(by);
            by.clear();
        }

        fis.close();

        return baos.toByteArray();
    }
}
```

### 2.3.第三步
**`Class.forName`有一个三个参数的重载方法，可以指定类加载器**，平时我们使用的
`Class.forName("XX.XX.XXX")`都是使用的系统类加载器`Application ClassLoader`。写一个测
试类：
```java
package com.fuhd;

public class Main {
    public static void main(String[] args) throws Exception {
        MyClassLoader mcl = new MyClassLoader();
        Class<?> c1 = Class.forName("com.fuhd.Person", true, mcl);
        Object obj = c1.newInstance();
        System.out.println(obj);
        System.out.println(obj.getClass().getClassLoader());
    }
}
```
看一下运行结果：
```
com.fuhd.Person
I am a person, my name is null
com.fuhd.MyClassLoader@14ae5a5
```
个人的经验来看，**最容易出问题的点是第二行的打印出来的是"sun.misc.Launcher$AppClassLoader"。
造成这个问题的关键在于Idea是自动编译的，并生成到CLASSPATH也就是bin目录下。在CLASSPATH下有
Person.class，那么自然是由Application ClassLoader来加载这个.class文件了**。解决这个问题有
个办法：**删除CLASSPATH下的`Person.class`，CLASSPATH下没有`Person.class`，Application
ClassLoader就把这个`.class`文件交给下一级用户自定义ClassLoader去加载了**。

## 3.ClassLoader.getResourceAsStream(String name)方法作用
ClassLoader中的`getResourceAsStream(String name)`其实是一个挺常见的方法，所以要写一下。
这个方法是用来 **读入指定资源的输入流，并将该输入流返回给用户，资源可以是图像、声音、.properties
文件等，资源名称是以"/"分隔的标识资源名称的路径名称**。

**不仅ClassLoader中有getResourceAsStream(String name)方法，Class下也有
getResourceAsStream(String name)方法**，它们两个方法的区别在于：
1. Class的`getResourceAsStream(String name)`方法，**参数不以"/"开头则默认从此类对应的
`.class`文件所在的packge下取资源，以"/"开头则从CLASSPATH下获取**。
2. ClassLoader的`getResourceAsStream(String name)`方法，**默认就是从CLASSPATH下获取资
源，参数不可以以"/"开头**。

其实，Class的`getResourceAsStream(String name)`方法，只是将传入的name进行解析一下而已，
最终调用的还是ClassLoader的`getResourceAsStream(String name)`。

## 4.`.class`和`getClass()`的区别
它们二者都可以获取一个唯一的`java.lang.Class`对象，但是区别在于：
1. **`.class`用于类名，`getClass()`是一个`final native`的方法，因此用于类实例**。
2. **class在编译期间就确定了一个类的java.lang.Class对象，但是getClass()方法在运行期间确定
一个类实例的java.lang.Class对象**。
