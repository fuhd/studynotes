自定义加载器
================================================================================
## 1.JDK中的ClassLoader
在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：
```java
protected synchronized Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
  // First, check if the class has already been loaded
  Class c = findLoadedClass(name);
  if (c == null) {
    try {
      if (parent != null) {
        c = parent.loadClass(name, false);
      } else {
        c = findBootstrapClass0(name);
      }
    } catch (ClassNotFoundException e) {
      // If still not found, then invoke findClass in order
      // to find the class.
      c = findClass(name);
    }
  }
  if (resolve) {
    resolveClass(c);
  }
  return c;
}
```
方法原理很简单，一步一步解释一下：
1. 第4行，首先查找`.class`是否被加载过。
2. 第5行~第11行，如果`.class`文件没有被加载过，那么会去找加载器的父加载器。如果父加载器不是null
（不是Bootstrap ClassLoader），那么就执行父加载器的loadClass方法，把类加载请求一直向上抛，
直到父加载器为null（是Bootstrap ClassLoader）为止。
3. 第12行~第16行，父加载器开始尝试加载`.class`文件，加载成功就返回一个`java.lang.Class`，加
载不成功就抛出一个ClassNotFoundException，给子加载器去加载。
4. 第18行~第20行，如果要解析这个`.class`文件的话，就解析一下，**主要就是将符号引用替换为直接引
用的过程**。


































dd
