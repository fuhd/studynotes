Java安全之理解Java沙箱
================================================================================
## 1.什么是沙箱
**Java安全模型的核心就是Java沙箱（`sandbox`）**，什么是沙箱？沙箱是一个限制程序运行的环境。限
制程序运行，一方面是为了保护系统资源，同时另一方面也为了保护程序自己。**沙箱主要限制系统资源访问，
那系统资源包括什么？——CPU、内存、文件系统、网络**。不同级别的沙箱对这些资源访问的限制也可以不一
样。

**所有的Java程序运行都可以指定沙箱，可以定制安全策略**。而一个Java程序运行的安全策略，包括了以
下几点基础：
+ **字节码校验器**（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java
程序实现内存保护。但是不是所有的类文件都会经过字节码校验，比如核心类。
+ **类加载器**（class loader）：所有的Java类都是通过类加载器加载的，可以自定义类加载器来设置
加载类的权限。
+ **访问控制器**（access controller）：访问控制器可以控制核心API对操作系统的存取权限，而这个
控制的策略设定，可以由用户指定。
+ **安全管理器**（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存
取控制器优先级高。
+ **安全软件包**（security package）：java.security下的类和扩展包下的类，允许用户为自己的
应用增加新的安全特性，包括：
  - 安全提供者
  - 消息摘要
  - 数字签名
  - 加密
  - 鉴别

## 2.沙箱包含哪些要素

### 2.1.权限
权限是指允许代码执行的操作。包含三部分：**权限类型、权限名和允许的操作。权限类型是实现了权限的Java
类名，是必需的。权限名一般就是对哪类资源进行操作的资源定位**（比如一个文件名或者通配符、网络主机
等），**一般基于权限类型来设置**，有的比如`java.security.AllPermission`不需要权限名。允许的
操作也和权限类型对应，指定了对目标可以执行的操作行为，比如读、写等。如下面的例子：
```
permission java.security.AllPermission;                 //权限类型
permission java.lang.RuntimePermission "stopThread";    //权限类型+权限名
permission java.io.FilePermission "/tmp/foo" "read";    //权限类型+权限名+允许的操作
```
**标准权限有哪些**：

|  | 类型 | 权限名 | 操作 | 例子 |
| :----------- | :----------- | :----------- | :----------- | :---------- |
| 文件权限 | java.io.FilePermission | 文件名（平台依赖） | 读、写、删除、执行 | **允许所有文件的读写删除执行**：`permission java.io.FilePermission "<< ALL FILES>>", "read,write,delete,execute";`。**允许对用户主目录的读**：`permission java.io.FilePermission "${user.home}/-", "read";` |
| 套接字权限 | java.net.SocketPermission | 主机名:端口 | 接收、监听、连接、解析 | **允许实现所有套接字操作**：`permission java.net.SocketPermission ":1-", "accept,listen,connect,resolve";`。**允许建立到特定网站的连接**：`permission java.net.SocketPermission ".abc.com:1-", "connect,resolve";` |
| 属性权限 | java.util.PropertyPermission | 需要访问的jvm属性名 | 读、写 | **读标准Java属性**：`permission java.util.PropertyPermission "java.", "read";`。**在sdo包中创建属性**：`permission java.util.PropertyPermission "sdo.", "read,write";`。 |
| 运行时权限 | java.lang.RuntimePermission | 多种权限名[见附录A] | 无 | **允许代码初始化打印任务**：`permission java.lang.RuntimePermission "queuePrintJob";` |
| AWT权限 | java.awt.AWTPermission | 6种权限名[见附录B] | 无 | **允许代码充分使用robot类**：`permission java.awt.AWTPermission "createRobot";` `permission java.awt.AWTPermission "readDisplayPixels";`。 |
| 网络权限 | java.net.NetPermission | 3种权限名[见附录C] | 无 | **允许安装流处理器**：`permission java.net.NetPermission "specifyStreamHandler";`。 |
| 安全权限 | java.security.SecurityPermission | 多种权限名[见附录D] | 无 | 无 |
| 序列化权限 | java.io.SerializablePermission | 2种权限名[见附录E] | 无 | 无 |
| 反射权限 | java.lang.reflect.ReflectPermission | suppressAccessChecks（允许利用反射检查任意类的私有变量） | 无 | 无 |
| 完全权限 | java.security.AllPermission | 无（拥有执行任何操作的权限） | 无 | 无 |

### 2.2.代码源
代码源是类所在的位置，表示为以URL地址。

### 2.3.保护域
**保护域用来组合代码源和权限，这是沙箱的基本概念**。保护域就在于声明了比如由代码A可以做权限B这样
的事情。

### 2.4.策略文件
为了管理沙箱，策略文件我认为是最重要的内容。**JVM可以使用多个策略文件，不过一般两个最常用。一个
是全局的：`$JREHOME/lib/security/java.policy`，作用于JVM的所有实例。另一个是用户自己的，
可以存储到用户的主目录下**。策略文件可以使用jdk自带的 **policytool工具** 编辑。

默认的策略文件我们先参考一下：
```java
// Standard extensions get all permissions by default
grant codeBase "file:${{java.ext.dirs}}/*" {
    permission java.security.AllPermission;
};

// default permissions granted to all domains
grant {
    // Allows any thread to stop itself using the java.lang.Thread.stop()
    // method that takes no argument.
    // Note that this permission is granted by default only to remain
    // backwards compatible.
    // It is strongly recommended that you either remove this permission
    // from this policy file or further restrict it to code sources
    // that you specify, because Thread.stop() is potentially unsafe.
    // See the API specification of java.lang.Thread.stop() for more
    // information.
    permission java.lang.RuntimePermission "stopThread";

    // allows anyone to listen on dynamic ports
    permission java.net.SocketPermission "localhost:0", "listen";

    // permission for standard RMI registry port
    permission java.net.SocketPermission "localhost:1099", "listen";

    // "standard" properies that can be read by anyone
    permission java.util.PropertyPermission "java.version", "read";
    permission java.util.PropertyPermission "java.vendor", "read";
    permission java.util.PropertyPermission "java.vendor.url", "read";
    permission java.util.PropertyPermission "java.class.version", "read";
    permission java.util.PropertyPermission "os.name", "read";
    permission java.util.PropertyPermission "os.version", "read";
    permission java.util.PropertyPermission "os.arch", "read";
    permission java.util.PropertyPermission "file.separator", "read";
    permission java.util.PropertyPermission "path.separator", "read";
    permission java.util.PropertyPermission "line.separator", "read";

    permission java.util.PropertyPermission "java.specification.version", "read";
    permission java.util.PropertyPermission "java.specification.vendor", "read";
    permission java.util.PropertyPermission "java.specification.name", "read";

    permission java.util.PropertyPermission "java.vm.specification.version", "read";
    permission java.util.PropertyPermission "java.vm.specification.vendor", "read";
    permission java.util.PropertyPermission "java.vm.specification.name", "read";
    permission java.util.PropertyPermission "java.vm.version", "read";
    permission java.util.PropertyPermission "java.vm.vendor", "read";
    permission java.util.PropertyPermission "java.vm.name", "read";
};
```
策略文件的内容格式就是这样，grant授权允许操作某个权限。这个默认的策略文件就指明了jdk扩展包可以有
全部权限，允许代码stop线程，允许监听1099端口等等。

另一个很重要的是参数文件——`java.security`，**这个文件和策略文件在同一个目录下**。这个参数文件
定义了沙箱的一些参数。比如默认的 **沙箱文件** 是这样的（截取部分）：
```ini
# The default is to have a single system-wide policy file,
# and a policy file in the user's home directory.
policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy

# whether or not we expand properties in the policy file
# if this is set to false, properties (${...}) will not be expanded in policy
# files.
policy.expandProperties=true

# whether or not we allow an extra policy to be passed on the command line
# with -Djava.security.policy=somefile. Comment out this line to disable
# this feature.
policy.allowSystemProperty=true
```
**`policy.url.*`这个属性指明了使用的策略文件**，如上文所述，默认的两个位置就在这里配置，用户可
以自行更改顺序和存储位置。**而`policy.allowSystemProperty`指明是否允许用户自行通过命令行指定
policy文件**。

### 2.5.密钥库
保存密钥证书的地方。

## 3.默认沙箱
**通过Java命令行启动的Java应用程序，默认不启用沙箱**。要想启用沙箱，启动命令需要做如下形式的变
更：
```shell
java -Djava.security.manager <other args>
```
沙箱启动后，安全管理器会使用两个默认的策略文件来确定沙箱启动参数。当然也可以通过命令指定：
```shell
java -Djava.security.policy=<URL>
```
如果要求启动时 **只遵循一个策略文件，那么启动参数要加个等号**，如下：
```shell
java -Djava.security.policy==<URL>
```

## 3.如何使用

### 3.1.限制读文件
这个例子很简单，首先写一个`abc.txt`文件，里面的内容是“abcd”，再写个程序如下读取这个`abc.txt`。
```java
package com.fuhd;

import java.io.*;

public class PolicyTest {

    public static void file() {
        File f = new File("/home/fuhd/work/abc");
        InputStream is;
        try {
            is = new FileInputStream(f);
            byte[] content = new byte[1024];
            while (is.read(content) != -1) {
                System.out.println(new String(content));
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        // test read file.
        file();
    }
}
```
发现输出是`abcd`。

接下来修改java启动参数，加入 **-Djava.security.manager，启动了安全沙箱**。再运行，输出变成
了异常：
```
Exception in thread "main" java.security.AccessControlException: access denied ("java.io.FilePermission" "/home/fuhd/work/abc" "read")
	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)
	at java.security.AccessController.checkPermission(AccessController.java:884)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
	at java.lang.SecurityManager.checkRead(SecurityManager.java:888)
	at java.io.FileInputStream.<init>(FileInputStream.java:127)
	at com.fuhd.PolicyTest.file(PolicyTest.java:11)
	at com.fuhd.PolicyTest.main(PolicyTest.java:27)
```
这里已经提示了，**访问被拒绝，说明了沙箱启动，同时也验证了默认沙箱——禁止本地文件访问**。

再来，我们 **构建一个custom.policy文件** 如下：
```java
grant {
  permission java.io.FilePermission "/home/fuhd/work/*", "read";
};
```
这里构建了一条安全策略——允许读取`/home/fuhd/work`目录下的文件。

修改启动命令，添加`-Djava.security.policy=/home/fuhd/work/custom.policy`，再执行，结果
输出了abcd。如上例。我们 **通过自定义policy文件修改了默认沙箱的安全策略，再通过启动参数开启沙箱
模式。这样就可以构造我们自己想要的沙箱效果了**。






























大
