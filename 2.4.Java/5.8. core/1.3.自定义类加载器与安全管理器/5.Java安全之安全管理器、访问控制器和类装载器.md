Java安全之安全管理器、访问控制器和类装载器
================================================================================
## 1.安全管理器：SecurityManager
**安全管理器** 在Java语言中的作用就是检查操作是否有权限执行，**是Java沙箱的基础组件**。我们一
般所说的 **打开沙箱**，也是加 **-Djava.security.manager** 选项。

其实 **日常的很多API都涉及到安全管理器**，它的工作原理一般是：
1. **请求Java API**。
2. **Java API使用安全管理器判断许可权限**。
3. **通过则顺序执行，否则抛出一个Exception**。

我们看下SecurityManager的主要方法列表：
```
checkAccept(String, int)
checkAccess(Thread)
checkAccess(ThreadGroup)
checkAwtEventQueueAccess()
checkConnect(String, int)
checkConnect(String, int, Object)
checkCreateClassLoader()
checkDelete(String)
checkExec(String)
checkExit(int)
checkLink(String)
checkListen(int)
checkMemberAccess(Class<?>, int)
checkMulticast(InetAddress)
checkMulticast(InetAddress, byte)
checkPackageAccess(String)
checkPackageDefinition(String)
checkPermission(Permission)
checkPermission(Permission, Object)
checkPrintJobAccess()
checkPropertiesAccess()
checkPropertyAccess(String)
checkRead(FileDescriptor)
checkRead(String)
checkRead(String, Object)
checkSecurityAccess(String)
checkSetFactory()
checkSystemClipboardAccess()
checkTopLevelWindow(Object)
checkWrite(FileDescriptor)
checkWrite(String)
```
都是check方法，分别囊括了 **文件的读写删除和执行、网络的连接和监听、线程的访问、以及其他包括打印
机剪贴板等系统功能。而这些check代码也基本横叉到了所有的核心Java API上**。

**安全管理器可以自定义**，作为核心API调用的部分，我们可以自己为自己的业务定制安全管理逻辑。举个
例子如下：
```java
package com.fuhd;

public class SecurityManagerTest {
    static class MySM extends SecurityManager {
        @Override
        public void checkExit(int status) {
            throw new SecurityException("no exit");
        }
    }

    public static void main(String[] args) {
        MySM sm = new MySM();
        System.out.println(System.getSecurityManager());
        System.setSecurityManager(sm);//注释掉测一下
        System.exit(0);
    }
}
```
注释掉代码中的注释行，系统打印null，然后正常退出。当我们打开注释，并且自己扩展一个
SecurityManager——MySM，它做的事情很简单，就是覆盖了checkExit方法，在系统退出时抛出一个
“no exit”的异常。

## 2.访问控制器：AccessController
**揭开沙箱面纱，第一步是安全管理器，那么第二步就是访问控制器了。因为沙箱的所有check方法实现，都
是基于AccessController的**。

### 2.1.组成
要了解AccessController，需要理解4个概念：**代码源、权限、策略和保护域**。

#### 2.1.1.代码源（CodeSource）
CodeSource就是一个简单的类，用来声明从哪里加载类。

#### 2.1.2.权限（Permission）
Permission类是AccessController处理的基本实体。**Permission类本身是抽象的，它的一个实例代表
一个具体的权限**。权限有两个作用，一个是允许Java API完成对某些资源的访问。另一个是可以为自定义权
限提供一个范本。**权限包含了权限类型、权限名和一组权限操作**。具体可以看看BasicPermission类的
代码。典型的也可以参看FilePermission的实现。

#### 2.1.3.策略（Policy）
**策略是一组权限的总称，用于确定权限应该用于哪些代码源**。话说回来，代码源标识了类的来源，权限声
明了具体的限制。那么策略就是将二者联系起来，策略类Policy主要的方法就是`getPermissions(CodeSource)`
和`refresh()`方法。**Policy类在老版本中是abstract的，且这两个方法也是。在jdk1.8中已经不再有
abstract方法。这两个方法也都有了默认实现**。

**在JVM中，任何情况下只能安装一个策略类的实例**。安装策略类可以通过`Policy.setPolicy()`方法
来进行，也可以通过`java.security`文件里的`policy.provider=sun.security.provider.PolicyFile`
来进行。jdk1.6以后，Policy引入了PolicySpi，后续的扩展基于SPI进行。

#### 2.1.4.保护域（ProtectionDomain）
保护域可以理解为代码源和相应权限的一个组合。表示指派给一个代码源的所有权限。看概念，感觉和策略很像，
其实策略要比这个大一点，**保护域是一个代码源的一组权限，而策略是所有的代码源对应的所有的权限的关系**。

**JVM中的每一个类都一定属于且仅属于一个保护域，这由ClassLoader在define class的时候决定。但不
是每个ClassLoader都有相应的保护域，核心Java API的ClassLoader就没有指定保护域，可以理解为属于
系统保护域**。

### 2.2.AccessController
了解了组成，再回头看AccessController。**这是一个无法实例化的类——仅仅可以使用其static方法**。
AccessController最重要的方法就是 **checkPermission()方法**，作用是基于已经安装的Policy对
象，能否得到某个权限。示例：
```java
public void checkPermission(Permission perm) {
    java.security.AccessController.checkPermission(perm);
}
```
然而，**AccessController的使用还是重度关联类加载器的**。如果都是一个类加载器且都从一个保护域
加载类，那么你构造的checkPermission的方法将正常返回。

当使用了其他类加载器或者使用了Java扩展包时，这种情况比较普遍。**AccessController另一个比较实
用的功能是doPrivilege（授权）**。假设一个保护域A有读文件的权限，另一个保护域B没有。那么通过
`AccessController.doPrivileged`方法，可以将该权限临时授予B保护域的类。而这种授权是单向的。
也就是说，**它可以为调用它的代码授权，但是不能为它调用的代码授权**。




































dd
