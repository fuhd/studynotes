类型擦除
====================================================================
**类型擦除是Java中泛型的实现方式。泛型是在编译器这个层次来实现的**。在Java源代码中声明的泛型类型信息，
在编译过程中会被擦除，只保留不带类型参数的形式。**被擦除的类型信息包括泛型类型和泛型方法声明时的形式类型参数，
以及参数化类型中的实际类型信息**。经过类型擦除之后，包含泛型类型的代码被转换成不包含泛型类型的代码，
**相当于回到了泛型被引入之前的形式**。Java虚拟机在运行字节码时并不知道泛型类型的存在。虽然为了反射API的需要，
在Java字节码中包含了与泛型类型相关的信息，但这些信息在字节码执行时是不被使用的。与泛型相关的类型检查由编译器
在编译时进行。

### 基本概念
编译器和虚拟机所能区分的类型是不同的：**对于编译器来说，`List<String>`和`List<Integer>`是不同的类型；
而对于虚拟机来说，这两者的类型都是`List`**。在运行时可用的类型被称为 **可具体化类型（`reifiable type`）**。
**Java中的可具体化类型** 包括 **非泛型类型、所有实际类型都是无界通配符的参数化类型、原始类型、基本类型、元素类型为
可具体化类型的数组类型、以及父类型和自身都是可具体化类型的嵌套类型。举例来说，`String`、`List<?>`、`List`、`int`、`String[]`、
和`MyClass<?>.Inner`都是可具体化类型**。

**除了实际类型都是无界通配符的参数化类型外**，Java泛型实现中的最重要的特点是 **几乎所有参数化类型都是不可具体化的**。
如`List<String>`和`List<? extends Number>`等类型都是不可具体化的。虚拟机在执行字节代码时只能使用运行时
可用的可具体化类型。这使Java中与虚拟机相关的语法特性对于不可具体化的参数化类型是不可用的。以异常处理为例，
**Java代码运行时的异常捕获和处理是由虚拟机来完成的。因此异常类型必须是可具体化的。任何泛型类型都不能直接或
间接继承自`Throwable`类**。Java采用这种做法实现泛型的根本出发点是保持Java平台的兼容性，保证泛型引入之前的字节码
在不经过任何修改的情况下就可以在新版本的虚拟机上运行。因此，**Java选择在编译器这个层次来实现泛型，而保持虚拟机不变**。

在类型擦除过程中需要处理形式类型参数和参数化类型中的实际类型。**对于形式类型参数，在泛型类型声明中的部分会被直接删除，
如`ObjectHolder<T>`被替换成`ObjectHolder`；在泛型类型代码中出现的则根据上界替换成具体的类型。如果形式类型参数
声明了上界，则声明中最左边的上界作为进行替换的类型；如果没有上界，则使用`Object`类进行替换。而对于参数化类型的实际
类型，它们在代码中的出现会被直接删除。进行这些替换之后，可能会出现代码逻辑不合法的情况，编译器会通过插入适当的强制类型
转换代码和生成桥接方法（`bridge method`）来解决**。

还是以`ObjectHolder`为例， 经过类型擦除后的形式如下：
```java
// 泛型类型经过类型擦除之后的代码示例
public class ObjectHolder {
    private Object obj;
    public Object getObject() {
        return obj;
    }
    public void setObject(Object obj) {
        this.obj = obj;
    }
}
```
在类型擦除后，`ObjectHolder`类中的`getObject`方法的返回值类型实际上是`Object`类型，因此需要添加强制类型转换
把`getObject`方法的返回值转换成`String`类型。**这些类型转换操作由编译器自动添加**。由于编译器已经确保不允许使用除
`String`类的对象之外的其他对象调用`setObject`方法，因此这个强制类型转换操作始终是合法的。示例：
```java
// 使用泛型类型的代码在类型擦除之后的示例
ObjectHolder holder = new ObjectHolder();
holder.setObject("Hello");
String str = (String) holder.getObject();
```

### 桥接方法
当一个类继承某个参数化类或实现参数化接口时，在经过类型擦除之后，可能造成所继承的方法的类型签名发生改变。
典型的示例是：`java.lang.Comparable`接口的实现类，如下例：
```java
// Comparable接口的实现类
public class Sequence implements Comparable<Sequence> {
    private final int sequenceNumber;
    public Sequence(int sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
    }
    public int compareTo(Sequence sequence) {
        return Integer.compare(sequenceNumber, sequence.sequenceNumber);
    }
}
```
**在经过类型擦除之后，`Comparable`接口的实际类型“`<Sequence>`”被删除。`Sequence`类的声明变成了
实现原始`Comparable`接口**。从接口实现的角度来说，这要求`Sequence`类中包含一个类型签名为 **“`int compareTo(Object)`”**
的方法，否则`Sequence`类的实现是不正确的。**这是由类型擦除造成的，编译器需要添加相应的方法来确保代码实现的正确性。
这些由编译器自动添加的方法被称为桥接方法**。

对`Sequence`类来说，编译器会自动添加一个类型签名为“`int compareTo(Object)`”的方法。在桥接方法的实现中，
只是在进行必要的类型转换之后直接调用`Sequence`类中定义的类型签名为“`int compareTo(Sequence)`”的方法。
下面的代码给出了桥接方法的内部实现：
```java
// 桥接方法的内部实现
public int compareTo(Object obj) {
    return this.compareTo((Sequence) obj);
}
```
**虽然自动添加的桥接方法`compareTo`接受`Object`类型的参数，但是代码中不能直接使用这个方法**。使用除`Sequence`类及
其子类之外的其他类型的对象调用`compareTo`方法会产生编译错误。**由于桥接方法在运行时是可见的，可以通过反射API来查找
并调用桥接方法**。

### 类型擦除对泛型特性的影响
类型擦除机制的存在影响了很多泛型的特性。**同一泛型类型的所有实例化形式在运行时的表示形式是相同的。每个泛型类型只对应一份
字节码。虚拟机并不区分同一泛型类型的不同实例化形式**。`List<String>`和`List<Integer>`类型对于虚拟机来说是相同的，
表示的都是`List`接口。所以无法通过类似“`List<String>.class`”的形式来获取参数化类型的类对象字面量，而只能使用`List.class`。
在运行时并不存在`List<String>`类型，只有`List`类型。

**除了实际类型都是无上界通配符外的泛型类型的其他实例化形式，都不能用在`instanceof`操作符中**。例如，
除了类似`obj instanceof List<?>`之外的其他使用方式，如`obj instanceof List<String>`和
`obj instanceof List<? extends Serializable>`等，**都是非法的**。这是因为 **`instanceof`操作符是根据对象
的运行时类型来进行判断的，只对可具体化类型有意义**。对于参数化类型来说，只能比较类型擦除之后的类型。
在`instanceof`操作符看来，一个`ArrayList<String>`类的对象也是`ArrayList<Integer>`类型的实例。因为这两种参数化
类型在类型擦除之后的类型都是`ArrayList`。

**在泛型类型中定义的静态方法和域是被所有的实例化形式的对象所共享的**。示例：
```java
// 泛型类型中的静态域
public class StaticField <T> {
    public static int count = 0;
    public StaticField() {
        count++;
    }
    public static void main(String[] args) {
        new StaticField<String>();
        new StaticField<Integer>();
        System.out.println(StaticField.count);//输出为2
    }
}
```
上例中，用不同的实际类型实例化了泛型类`StaticField`。对于虚拟机来说，静态变量`count`与类型擦除之后的`StaticField`
类型相对应，与具体的参数化类型无关。在引用泛型类型中定义的静态变量和方法时，直接使用原始类型，不能使用参数化类型。
`StaticField<String>.count`是非法的引用方法。

**泛型类型声明中的形式类型参数不能出现在任何静态上下文中，包括不能出现在静态域的类型声明中、不能出现在静态方法的声明
和实现中、不能出现在静态初始化代码块中，以及不能出现在静态嵌套类型中。静态嵌套类型包括静态嵌套类、嵌套接口和嵌套枚举
类型等**。类型中的静态上下文是与类型关联在一起的，与类型的实例对象无关。由于泛型类型的不同实例化形式在运行时对应的是同
一个类型，在静态上下文中使用形式类型参数并没有意义，反而容易造成开发人员的误解，因此，编译器直接禁止这样的用法。


