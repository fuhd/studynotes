上界和下界
==================================================================
泛型类型和泛型方法与一般类型和方法的区别在于可以声明形式类型参数。在实际的类型声明中，
形式类型参数会被替换成具体的类型。**虽然形式类型参数在源代码中可以使用，但其使用方式是受限的**。
**编译器把形式类型参数当成实际类型的占位符**。编译器不能对实际声明时可能使用的类型做出任何假定，
只能使用最严格的检查方式，以避免出现类型安全错误。

如果希望限制在实际类型声明时可以使用的类型，那么可以为形式类型参数添加上界。**在添加了上界之后，
泛型类型在实例化时只能使用由上界表示的类型及其子类型**。示例：
```java
// 形式类型参数的上界
public class ComparableObjectHolder<T extends Comparable<T>> {
    private T obj;
    public int compareTo(T anotherObj) {
        return obj.compareTo(anotherObj);
    }
}
```
上例中，**通过`extends`关键词为形式类型参数T添加了上界`Comparable<T>`接口。声明泛型类型时的实际类型
必须实现`Comparable`接口**，否则会出现编译错误。**这样可以确保实际类型实现了`Comparable`接口，可以在代码
中调用参数对象的`compareTo`方法**。如果没有显式指定上界，那么默认的上界是`Object`类。**形式类型参数虽然有
上界，但是没有上界**，这是因为下界在实际中几乎没有作用。

**形式类型参数上界的作用是限制泛型类型实例化时可以使用的类型，可以在代码中使用上界类型中提供的公开成员，
包括公开的方法、域和嵌套类型，但是不包括构造方法。这是因为构造方法是不被继承的**。

**除了基本类型和数组类型之外的其他类型都可以作为形式类型参数的上界，其中除了一般的类和接口之外，还包括参数化类型
和形式类型参数。对于`int`和`float`等基本类型，可以使用其对应的包装类来作为上界。对于数组类型，可以使用集合类
框架中的类或接口来替代**。示例：
```java
// 使用形式类型参数作为上界
public class SampleClass<S extends T, T> {
    public void test() {
        SampleClass<String, Comparable<String>> obj = new SampleClass<>();
    }
}
```
上例中，`SampleClass`类使用了两个形式类型参数`S`和`T`，且`T`是`S`的上界。这就要求实例化时第一个类型与
第二个类型相同，或者第一个类型是第二个类型的子类型。类似"`SampleClass<String, Comparable<String>>`"
的实例化形式是合法的。

**一个形式类型参数可以包含多个上界，不同上界之间使用“`&`”来分隔**。在实例化时所能使用的类型是所有上界的子类型。
示例：
```java
// 形式类型参数包含多个上界的示例
public class CloneableSerializable<T extends Cloneable & Serializable> {
    public void serialize(T obj) {
    }
}
```
上例中，类的形式类型参数使用`Cloneable`接口和`java.io.Serializable`接口作为共同的上界。

**这些上界之间的顺序虽然不会对实例化时所能使用的具体类型的范围产生影响，但是会影响类型擦除之后使用的类型。
在类型擦除过程中，形式类型参数会被最左边的上界所替代**。上面示例中，在类型擦除之后，`serialize`方法的
参数的类型是`Cloneable`接口。如果在声明时使用的形式是“`<T extends Serializable & Cloneable>`”，
那么在类型擦除之后，`serialize`方法的参数的类型是`Serializale`接口。不过由于实际类型是所有上界的子类型，
具体使用哪个上界类型来表示实际上是没有差别的。

除了形式类型参数之外，**泛型类型实例化时的实际类型也可以包含上界或下界。参数化类型中的上界或下界是与通配符一
块来使用的**。









