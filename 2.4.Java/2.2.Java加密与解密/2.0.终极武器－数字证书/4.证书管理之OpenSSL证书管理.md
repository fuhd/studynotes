证书管理之OpenSSL证书管理
===============================================================
`OpenSSL`(`http://www.openssl.org/`) 是一个开放源代码软件包，由`Eri A. Young`和`Tim J. Hudson`等人编写，
实现了`SSL`及相关加密技术，是最常用的证书管理工具。**`OpenSSL`功能远胜于`KeyTool`，可用于根证书、
服务器证书和客户证书的管理**。

### 准备工作
首先，我们需要 **构建一个CA工作目录**。
```shell
$ mkdir CA
```
建立`CA`工作目录后，我们需要 **构建一些子目录，用于存放证书、密钥等**，完整命令如下：
```shell
# 构建CA子目录
$ echo 构建已发行证书存放目录 certs
$ mkdir certs
$ echo 构建新证书存放目录 newcerts
$ mkdir newcerts
$ echo 构建私钥存入目录 private
$ mkdir private
$ echo 构建证书吊销列表存放目录 crl
$ mkdir crl
```
我们将在创建证书时用到上述目录，**最终在`certs`目录中获得证书文件**。接下来，
**我们需要构建一些文件**，完整命令如下：
```shell
# 构建相关文件
$ echo 构建索引文件 index
$ echo 0 > index
$ echo 构建序列号文件 serial
$ echo 01 > serial
```
完成上述操作后，我们就可以进行证书的构建和签发工作了。

### 构建根证书
**根证书是`CA`认证中心给自己颁发的证书,是信任链的起始点。安装根证书意味着对这个`CA`认证中心的信任。
从技术上讲，证书其实包含三部分，用户的信息，用户的公钥，还有CA中心对该证书里面的信息的签名。
验证一份证书的真伪（即验证`CA`中心对该证书信息的签名是否有效），需要用`CA`中心的公钥验证，
而`CA`中心的公钥存在于对这份证书进行签名的证书内，故需要下载该证书，但使用该证书验证又需先验证该证书本身的真伪，
故又要用签发该证书的证书来验证，这样一来就构成一条证书链的关系，这条证书链在哪里终结呢？答案就是根证书，
根证书是一份特殊的证书，它的签发者是它本身，下载根证书就表明您对该根证书以下所签发的证书都表示信任，
而技术上则是建立起一个验证证书信息的链条，证书的验证追溯至根证书即为结束。所以说用户在使用自己的数字证书之前必须先下载根证书**。

#### 构建随机数文件
**在构建根证书前，需要构建随机数文件（`.rand`）**，完整命令如下：
```shell
# 构建随机数
$ echo 构建随机数 private/.rand
$ openssl rand -out private/.rand 1000
```
各参数的含义如下：

| 参数 | 描述 |
|:----|:-----|
| **rand** | **随机数命令** |
| **-out** | **输出文件路径，这里将随机数文件输出到private目录下** |

这里的参数1000，指用来产生 **伪随机字节数**。

#### 构建根证书密钥
**`OpenSSL`通常使用`PEM`(`Privacy Enbanced Mail`，隐私增强邮件)编码格式保存私钥**。
接下来，我们需要构建根证书密钥（`ca.key.pem`），完整命令如下：
```shell
# 构建根证书私钥
$ echo 构建根证书私钥 private/ca.key.pem
$ openssl genrsa -aes256 -out private/ca.key.pem 2048
```
各参数的含义如下：

| 参数 | 描述 |
|:-----|:-----|
| **genrsa** | **产生RSA密钥命令** |
| **-aes256** | **使用AES算法（256位密钥）对产生的私钥加密。可选算法包括DES、DESede、IDEA和AES** |
| **-out** | **输出路径，这里指private/ca.key.pem** |

这里的参数2048，指RSA密钥长度位数，**默认长度为512位**。上述的命令执行 **需要输入根证书密码**，如“123456”。

#### 生成根证书签发申请
完成密钥构建操作后，我们需要生成根证书签发申请文件（`ca.csr`），完整命令如下：
```shell
# 生成根证书签发申请
$ echo 生成根证书签发申请 private/ca.csr
$ openssl req -new -key private/ca.key.pem -out private/ca.csr -subj "/C=CN/ST=BJ/O=zlex/OU=zlex
        /CN=*.zlex.org"
```
各参数的含义如下：

| 参数 | 描述 |
|:----|:-----|
| **req** | **产生证书签发申请命令** |
| **-new** | **表示新请求** |
| **-key** | **密钥，这里为private/ca.key.pem文件** |
| **-out** | **输出路径，这里为private/ca.csr文件** |
| **-subj** | **指定用户信息，这里使用泛域名“*.zlex.org”作为用户名** |

执行上述命令后，需要输入根证书密码：“123456”。

**得到根证书签发申请文件后，我们可以将其发送给`CA`机构签发。当然，我们也可以自行签发根证书**。

#### 签发根证书
签发根证书完整命令如下：
```shell
# 签发根证书
$ echo 签发根证书 private/ca.cer
$ openssl x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr 
        -out certs/ca.cer
```
各参数的含义如下：

| 参数 | 描述 |
|:----|:-----|
| **x509** | **签发X.509格式证书命令** |
| **-req** | **表示证书输入请求** |
| **-days** | **表示有效天数，这里为10000天** |
| **-sha1** | **表示证书摘要算法，这里为SHA1算法** |
| **-extensions** | **表示按OpenSSL配置文件v3_ca项添加扩展** |
| **-signkey** | **表示自签名密钥，这里为private/ca.key.pem** |
| **-in** | **表示输入文件，这里为private/ca.csr** |
| **-out** | **表示输出文件，这里为certs/ca.cer** |

上述命令执行，需要输入根证书密码，如“123456”。

#### 根证书转换
**`OpenSSL`产生的数字证书不能在Java语言环境中直接使用，需要将其转化为`PKCS#12`编码格式**。完整命令如下：
```shell
# 根证书转换
$ echo 根证书转换 private/a.p12
$ opeenssl pkcs12 -export -cacerts -inkey private/ca.key.pem -in certs/ca.cer -out certs/ca.p12
```
各参数的含义如下：

| 参数 | 描述 |
|:-----|:----|
| **pkcs12** | **PKCS＃12编码格式证书命令** |
| **-export** | **表示导出证书** |
| **-cacerts** | **表示仅导出CA证书** |
| **-inkey** | **表示输入密钥，这里为private/ca.key.pem** |
| **-in** | **表示输入文件，这里为certs/ca.cer** |
| **-out** | **表示输出文件，这里为certs/ca.p12** |

上述命令执行，需要输入根证书密码，如“123456”。

**个人信息交换文件（`PKCS#12`）可以作为密钥库或信任库使用，我们可以通过`KeyTool`查看该密钥库的详细信息**。命令如下：
```shell
# 查看密钥库信息
$ keytool -list -keystore certs/ca.p12 -storetype pkcs12 -v -storepass 123456
```
**注意，这里参数`-storetype`值为“`pkcs12`”**。上述命令执行结果如下：
```
密钥库类型: PKCS12
密钥库提供方: SunJSSE

您的密钥库包含 1 个条目

别名: 1
创建日期: 2017-9-16
条目类型: PrivateKeyEntry
证书链长度: 1
证书[1]:
所有者: CN=*.zlex.org, OU=zlex, O=zlex
发布者: CN=*.zlex.org, OU=zlex, O=zlex
序列号: d5c072add79d152e
有效期开始日期: Sat Sep 16 18:13:17 CST 2017, 截止日期: Wed Feb 01 18:13:17 CST 2045
证书指纹:
	 MD5: EE:35:85:AE:DA:CF:11:A7:D6:D1:41:E0:30:28:91:3F
	 SHA1: B3:76:43:CD:5A:45:B0:EF:D1:8D:2C:C0:BF:1B:22:FD:56:92:3D:26
	 SHA256: 7D:7F:5B:CE:AA:C8:C3:77:6E:47:0E:58:ED:9C:D8:DC:D2:87:A3:7F:04:82:20:BA:15:2C:7C:70:72:48:B1:BB
	 签名算法名称: SHA1withRSA
	 版本: 1


*******************************************
*******************************************
```
现在，我们已经构建了 **根证书（`ca.cer`）**，我们可以使用根证书签发 **服务器证书**和 **客户端证书**。

### 构建服务器证书
服务器证书的构建与根证书构建相似，首先需要 **构建私钥**：
```shell
#构建服务器私钥
echo 构建服务器私钥 private/server.key.pem
openssl genrsa -aes256 -out private/server.key.pem 2048
```
各参数的含义如下所示：

| 参数 | 描述 |
|:----|:-----|
| **genrsa** | **产生RSA密钥命令** |
| **-aes256** | **使用AES算法（256密钥）对产生的私钥加密。可选算法包括DES、DESede、IDEA和AES** |
| **-out** | **输出路径，这里指private/server.key.pem** |

这里的参数`2048`，指`RSA`密钥长度位数，默认长度为`512`位。

这时我们需要输入服务器证书密码，如“123456”。

完成服务器证书密钥构建后，我们需要产生服务器证书签发申请：
```shell
#生成服务器证书签发申请
echo 生成服务器证书签发申请 private/server.csr
openssl req -new -key private/server.key.pem -out private/server.csr -subj "/C=CN/ST=BJ/L=BJ/O=zlex/OU=zlex/CN=www.zlex.org"
```
各参数的含义如下所示：

| 参数 | 描述 |
|:----|:-----|
| **req** | **产生证书签发申请命令** |
| **-new** | **表示新请求** |
| **-key** | **密钥，这里为private/server.key.pem文件** |
| **-out** | **输出路径，这里为private/server.csr文件** |
| **-subj** | **指定用户信息，这里使用域名“www.zlex.org”作为用户名** |

这时我们需要输入服务器主书密码，如“123456”。

我们已经获得了根证书，可以使用根证书签发服务器证书。完整命令如下：
```shell
#签发服务器证书
echo 签发服务器证书 private/server.cer
openssl x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer 
	-CAkey private/ca.key.pem -CAserial ca.sr1 -CAcreateserial 
	-in private/server.csr -out certs/server.cer
```
各参数的含义如下：

| 参数 | 描述 |
|:-----|:----|
| **x509** | **签发X.509格式证书命令** |
| **-req** | **表示证书输入请求** |
| **-days** | **表示有效天数，这里为3650天** |
| **-sha1** | **表示证书摘要算法，这里为SHA1算法** |
| **-extensions** | **表示按OpenSSL配置文件v3_req项添加扩展** |
| **-CA** | **表示CA证书，这里为certs/ca.cer** |
| **-CAkey** | **表示CA证书密钥，这里为private/ca.key.pem** |
| **-CAserial** | **表示CA证书序列号文件，这里为ca.srl** |
| **-CAcreateserial** | **表示创建CA证书序列号** |
| **-in** | **表示输入文件，这里为private/server.csr** |
| **-out** | **表示输出文件，这里为certs/server.cer** |

这时我们需要输入服务器证书密码，如“123456”。





