证书使用
=====================================================================
**`java`提供了完善的数字证书管理实现**，我们几乎无需关注相关具体算法，**仅通过操作密钥库和数字证书就可完成
相应的加密/解密和签名/验证操作。密钥库管理私钥，数字证书管理公钥，私钥和公钥分属消息传递两方，进行加密消息传递**。

因此，**我们可以将密钥库看做私钥相关操作的入口，数字证书则是公钥相关操作的入口**。

下面以`KeyTool`产生的密钥库和证书为例，演示证书使用相关操作。**加载密钥库** 需要提供密钥库文件路径和密钥库密码，
代码如下：
```java
//加载密钥库
/*
 * 获得KeyStore
 * @param keyStorePath 密钥库路径
 * @param password 密码
 * @return keyStore 密钥库
 */
 private static KeyStore getKeyStore(String keyStorePath, String password) throws Exception {
     //实例化密钥库
     KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
     //获得密钥库文件流
     FileInputStream is = new FileInputStream(keyStorePath);
     //加载密钥库
     ks.load(is, password.toCharArray());
     //关闭密钥库文件流
     is.close();
     return ks;
 }
```
**加载密钥库后，我们就能通过相应的方法获得私钥，也可以获得数字证书**。获得私钥实现如下清单所示：
```java
//由密钥库获得私钥

//获得密钥库
KeyStore ks = getKeyStore(keyStorePath, password);
//获得私钥
PrivateKey privateKey = (PrivateKey) ks.getKey(alias, password.toCharArray());
```
这里通过我们已实现的 **`getKeyStore()`** 获得密钥库，输入别名（参数`alias`）和密码（参数`password`）即可获得私钥。
获得私钥后，可按照前面介绍的`RSA`算法实现进行“私钥加密，公钥解密”和“公钥加密，私钥解密”两项操作。

如果我们需要从密钥库中获得 **签名算法**，只能通过由密钥库中获取的数字证书并强转为 **`X509Certificate`** 实例，
**通过其`getSigAlgName()`方法获得对应的签名算法**。完整代码如下：
```java
//由密钥库获得数字证书构建数字签名对象

//获得密钥库
KeyStore ks = getKeyStore(keyStorePath, password);
//获得证书
X09Certificate x509Certificate = (X09Certificate) ks.getCertificate(alias);
//构建签名，由证书指定签名算法
Signature signature = Signature.getInstance(x509Certificate.getSigAlgName());
```
获得数字签名对象后，我们可使用私钥进行签名操作。相关实现与前面`RSA`算法实现非常相似。

相比于密钥库操作，**数字证书的操作更为简单，我们只需要给出数字证书的路径，并加载它即可**。代码如下所示：
```java
//加载数字证书

/**
 * 获得Certificate
 * @param certificatePath 证书路径
 * @return Certificate 证书
 * @throws Exception
 */
 private static Certificate getCertificate(String certificatePath) throws Exception {
     //实例化证书工厂
     CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
     //取得证书文件流
     FileInputStream in = new FileInputStrea(certificatePath);
     //生成证书
     Certificate certificate = certificateFactory.generateCertificate(in);
     //关闭证书文件流
     in.close();
     return certificate;
 }
```
目前，**`Java6`仅支持`X.509`类型的数字证书**。

通过以上方式加载得到数字证书后，我们可以直接 **获取公钥**，如下代码清单：
```java
//由数字证书获得公钥

//获得证书
Certificate certificate = getCertificate(certificatePath);
//获得公钥
PublicKey publicKey = certificate.getPublicKey();
```
得到公钥后，我们就可以参考前面介绍的`RSA`算法实现进行“公钥加密，私钥解密”和“私钥加密，公钥解密”两项操作。 

如果使用数字证书进行 **验证签名** 操作时，需要将获得的证书对象强转为`X509Certificate`实例。代码示例如下：
```java
//初始化签名对象

//获得证书
X509Certificate x509Certificate = (X509Certificate) getCertificate(certificatePath);
//由证书构建签名
Signature signature = Signature.getInstance(x509Certificate.getSigAlgName());
//由证书初始化签名，实际上是使用了证书中的公钥
signature.initVerify(x509Certificate);
```
**这里需要注意的是，数字签名对象初始化（`initVerify()`方法）时使用了数字证书而非公钥。该方法在内部实际上是使用
数字证书的公钥**。

