证书使用
=====================================================================
**`java`提供了完善的数字证书管理实现**，我们几乎无需关注相关具体算法，**仅通过操作密钥库和数字证书就可完成
相应的加密/解密和签名/验证操作。密钥库管理私钥，数字证书管理公钥，私钥和公钥分属消息传递两方，进行加密消息传递**。

因此，**我们可以将密钥库看做私钥相关操作的入口，数字证书则是公钥相关操作的入口**。

下面以`KeyTool`产生的密钥库和证书为例，演示证书使用相关操作。**加载密钥库** 需要提供密钥库文件路径和密钥库密码，
代码如下：
```java
//加载密钥库
/*
 * 获得KeyStore
 * @param keyStorePath 密钥库路径
 * @param password 密码
 * @return keyStore 密钥库
 */
 private static KeyStore getKeyStore(String keyStorePath, String password) throws Exception {
     //实例化密钥库
     KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
     //获得密钥库文件流
     FileInputStream is = new FileInputStream(keyStorePath);
     //加载密钥库
     ks.load(is, password.toCharArray());
     //关闭密钥库文件流
     is.close();
     return ks;
 }
```
**加载密钥库后，我们就能通过相应的方法获得私钥，也可以获得数字证书**。获得私钥实现如下清单所示：
```java
//由密钥库获得私钥

//获得密钥库
KeyStore ks = getKeyStore(keyStorePath, password);
//获得私钥
PrivateKey privateKey = (PrivateKey) ks.getKey(alias, password.toCharArray());
```
这里通过我们已实现的 **`getKeyStore()`** 获得密钥库，输入别名（参数`alias`）和密码（参数`password`）即可获得私钥。
获得私钥后，可按照前面介绍的`RSA`算法实现进行“私钥加密，公钥解密”和“公钥加密，私钥解密”两项操作。

如果我们需要从密钥库中获得 **签名算法**，只能通过由密钥库中获取的数字证书并强转为 **`X509Certificate`** 实例，
**通过其`getSigAlgName()`方法获得对应的签名算法**。完整代码如下：
```java
//由密钥库获得数字证书构建数字签名对象

//获得密钥库
KeyStore ks = getKeyStore(keyStorePath, password);
//获得证书
X09Certificate x509Certificate = (X09Certificate) ks.getCertificate(alias);
//构建签名，由证书指定签名算法
Signature signature = Signature.getInstance(x509Certificate.getSigAlgName());
```
获得数字签名对象后，我们可使用私钥进行签名操作。相关实现与前面`RSA`算法实现非常相似。

相比于密钥库操作，**数字证书的操作更为简单，我们只需要给出数字证书的路径，并加载它即可**。代码如下所示：
```java
//加载数字证书

/**
 * 获得Certificate
 * @param certificatePath 证书路径
 * @return Certificate 证书
 * @throws Exception
 */
 private static Certificate getCertificate(String certificatePath) throws Exception {
     //实例化证书工厂
     CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
     //取得证书文件流
     FileInputStream in = new FileInputStrea(certificatePath);
     //生成证书
     Certificate certificate = certificateFactory.generateCertificate(in);
     //关闭证书文件流
     in.close();
     return certificate;
 }
```
目前，**`Java6`仅支持`X.509`类型的数字证书**。

通过以上方式加载得到数字证书后，我们可以直接 **获取公钥**，如下代码清单：
```java
//由数字证书获得公钥

//获得证书
Certificate certificate = getCertificate(certificatePath);
//获得公钥
PublicKey publicKey = certificate.getPublicKey();
```
得到公钥后，我们就可以参考前面介绍的`RSA`算法实现进行“公钥加密，私钥解密”和“私钥加密，公钥解密”两项操作。 

如果使用数字证书进行 **验证签名** 操作时，需要将获得的证书对象强转为`X509Certificate`实例。代码示例如下：
```java
//初始化签名对象

//获得证书
X509Certificate x509Certificate = (X509Certificate) getCertificate(certificatePath);
//由证书构建签名
Signature signature = Signature.getInstance(x509Certificate.getSigAlgName());
//由证书初始化签名，实际上是使用了证书中的公钥
signature.initVerify(x509Certificate);
```
**这里需要注意的是，数字签名对象初始化（`initVerify()`方法）时使用了数字证书而非公钥。该方法在内部实际上是使用
数字证书的公钥**。

### 示例
下面代码基于密钥库和数字证书的加密/解密和签名/验证操作。
```java
import java.io.FileInputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import javax.crypto.Cipher;

/**
 * 证书组件
 */
 public abstract class CertificateCoder {

     //类型证书X509
     public static final String CERT_TYPE = "X.509";

     /*
      * 获得私钥
      * @param keyStorePath 密钥库路径
      * @param alias 别名
      * @param password 密码
      * @return PrivateKey 私钥
      */
     private static PrivateKey getPrivateKeyByKeyStore(String keyStorePath, String alias, String password) 
        throws Exception {
        // 获得密钥库
        KeyStore ks = getKeyStore(keyStorePath, password);
        // 获得私钥
        return (PrivateKey) ks.getKey(alias, password.toCharArray());
    }

    /*
     * 获得公钥
     * @param certificatePath 证书路径
     * @return PublicKey 公钥
     */
    private static PublicKey getPublicKeyByCertificate(String certificatePath) throws Exception {
        //获得证书
        Certificate certificate = getCertificate(certificatePath);
        //获得公钥
        return certificate.getPublicKey();
    }

    /*
     * 获得证书
     * @param certificatePath 证书路径
     * @return Certificate 证书
     */
    private static Certificate getCertificate(String certificatePath) throws Exception {
        //实例化证书工厂
        CertificateFactory certificateFactory = CertificateFactory.getInstance(CERT_TYPE);
        //取得证书文件流
        FileInputStream in = new FileInputStream(certificatePath);
        //生成证书
        Certificate certificate = certificateFactory.generateCertificate(in);
        //关闭证书文件流
        in.close();
        return certificate;
    }

    /*
     * 获得证书
     * @param keyStorePath 密钥库路径
     * @param alias 别名
     * @param password 密码
     * @return Certificate 证书
     */
    private static Certificate getCertificate(String keyStorePath, String alias, String password)
        throws Exception {
        //获得密钥库
        KeyStore ks = getKeyStore(keyStorePath, password);
        //获得证书
        return ks.getCertificate(alias);
    }

    /*
     * 获得密钥库
     * @param keyStorePath 密钥库路径
     * @param password 密码
     * @return KeyStore 密钥库
     */
    private static KeyStore getKeyStore(String keyStorePath, String password) throws Exception {
        //实例化密钥库
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        //获得密钥库文件流
        FileInputStream is = new FileInputStream(keyStorePath);
        //加载密钥库
        ks.load(is, password.toCharArray());
        //关闭密钥库文件流
        is.close();
        return ks;
    }

    /*
     * 私钥加密
     * @param data 待加密数据
     * @param keyStorePath 密钥库路径
     * @param alias 别名
     * @param password 密码
     * @return byte[] 加密数据
     */
    public static byte[] encryptByPrivateKey(byte[] data, String keyStorePath, String alias, 
        String password) throws Exception {
        //取得私钥
        PrivateKey privateKey = getPrivateKeyByKeyStore(keyStorePath, alias, password);
        //对数据加密
        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE,privateKey);
        return cipher.doFinal(data);
    }

    /*
     * 私钥解密
     * @param data 待解密数据
     * @param keyStorePath 密钥库路径
     * @param alias 别名
     * @param password 密码
     * @return byte[] 解密数据
     */
    public static byte[] decryptByPrivateKey(byte[] data, String keyStorePath,String alias,
        String password) throws Exception {
        //取得私钥
        PrivateKey privateKey = getPrivateKeyByKeyStore(keyStorePath, alias, password);
        //对数据解密
        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
        cipher.init(Cipher.DECRYPE_MODE, privateKey);
        return cipher.doFinal(data);
    }
 }
```
