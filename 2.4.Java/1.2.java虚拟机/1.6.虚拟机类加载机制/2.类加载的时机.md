类加载的时机
========================================================================
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：**加载（Loading）、
验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、
使用（Using）和卸载（Unloading）** 七个阶段。其中 **验证、准备和解析三个部分统称为连接（Linking）**。

**加载、验证、准备、初始化和缷载这五个阶段的顺序是确定的**，类的加载过程必须按照这种顺序按部就班
地开始，**而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行
时绑定（也称为动态绑定或晚期绑定）**。

什么情况下需要开始类加载过程的第一个阶段：**加载**。虚拟机规范中并没有进行强制约束，这点可以交给虚拟机
的具体实现来自由把握。但是对于 **初始化阶段**，虚拟机规范则是严格规定了 **有且只有四种情况** 必须立即对类进行
“初始化”（而加载、验证、准备自然需要在此之前开始）：
1. 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这4条字节码指令时，**如果类没有进行过
初始化，则需要先触发其初始化**。生成这4条指令的最常见的Java代码场景是：**使用`new`关键字实例化对象的时候、
读取或设置一个类的静态字段（被`final`修饰、已在编译期把结果放入常量池的静态字段除外）的时候、以及调用
一个类的静态方法的时候**。
2. **使用`java.lang.reflect`包的方法对类进行反射调用的时候**，如果类没有进行过初始化，则需要先触发
其初始化。
3. 当初始化一个类的时候，**如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化**。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类。

对于这 **四种会触发类进行初始化的场景**，虚拟机规范中使用了一个很强烈的限定语：“**有且只有**”，
这四种场景中的行为称为对一个类进行 **主动引用**。除此之外所有引用类的方式，都不会触发初始化，
称为 **被动引用**。
```java
/*
 * 被动使用类字段演示一
 *
 * 通过子类引用父类的静态字段，不会导致子类初始化
 */
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

// 非主动使用类字段演示
public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```
上述代码运行之后，只会输出“SuperClass init!“。**对于静态字段，只有直接定义这个字段的类才会被初始化，
因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化**。

