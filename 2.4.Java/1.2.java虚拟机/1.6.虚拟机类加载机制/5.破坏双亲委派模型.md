破坏双亲委派模型
=========================================================================
双亲委派模型并不是一个强制性的约束模型，而是Java设计者们 **推荐** 给开发者们的类加载器实现方式。
在Java的世界里面 **大部分的类加载器都遵循这个模型**，但也有例外的情况，到现在为止，双亲委派模型
主要出现过 **三次较大规模的“被破坏”情况**。

### 第一次“被破坏”
双亲委派模型的第一次“被破坏”其实 **发生在双亲委派模型出现之前**————即JDK1.2发布之前。
由于双亲委派模型在JDK1.2之后才被引入的，而类加载器和抽象类`java.lang.ClassLoader`则
在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，**Java设计者们引入双
亲委派模型时不得不做出一些妥协**。为了向前兼容，JDK1.2之后的 **`java.lang.ClassLoader`** 添加
了一个新的 **`protected`方法`findClass()`**，在此之前，用户去继承`java.lang.ClassLoader`的
**唯一目的就是为了重写`loadClass()`方法**，因为虚拟机在进行类加载的时候会调用加载器的私有方法
`loadClassInternal()`，而这个方法的唯一逻辑就是去调用自己的`loadClass()`。

上一节我们已经看过`loadClass()`方法的代码，双亲委派的具体逻辑就实现在这个方法之中，**JDK1.2之后
已不提倡用户再去覆盖`loadClass()`方法，而应当把自己的类加载逻辑写到`findClass()`方法中，
在`loadClass()`方法的逻辑里如果父类加载失败，则会调用自己的`findClass()`方法来完成加载，
这样就可以保证新写出来的类加载器是符合双亲委派规则的**。



