破坏双亲委派模型
=========================================================================
双亲委派模型并不是一个强制性的约束模型，而是Java设计者们 **推荐** 给开发者们的类加载器实现方式。
在Java的世界里面 **大部分的类加载器都遵循这个模型**，但也有例外的情况，到现在为止，双亲委派模型
主要出现过 **三次较大规模的“被破坏”情况**。

### 第一次“被破坏”
双亲委派模型的第一次“被破坏”其实 **发生在双亲委派模型出现之前**————即JDK1.2发布之前。
由于双亲委派模型在JDK1.2之后才被引入的，而类加载器和抽象类`java.lang.ClassLoader`则
在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，**Java设计者们引入双
亲委派模型时不得不做出一些妥协**。为了向前兼容，JDK1.2之后的 **`java.lang.ClassLoader`** 添加
了一个新的 **`protected`方法`findClass()`**，在此之前，用户去继承`java.lang.ClassLoader`的
**唯一目的就是为了重写`loadClass()`方法**，因为虚拟机在进行类加载的时候会调用加载器的私有方法
`loadClassInternal()`，而这个方法的唯一逻辑就是去调用自己的`loadClass()`。

上一节我们已经看过`loadClass()`方法的代码，双亲委派的具体逻辑就实现在这个方法之中，**JDK1.2之后
已不提倡用户再去覆盖`loadClass()`方法，而应当把自己的类加载逻辑写到`findClass()`方法中，
在`loadClass()`方法的逻辑里如果父类加载失败，则会调用自己的`findClass()`方法来完成加载，
这样就可以保证新写出来的类加载器是符合双亲委派规则的**。

### 第二次“被破坏”
双亲委派模型的第二次“被破坏”是 **由这个模型自身的缺陷所导致的**，双亲委派很好地解决了 **各个类加载
器的基础类的统一问题**（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们
总是作为被用户代码调用的API，但世事往往没有绝对的完美，**如果基础类又要调用回用户的代码，那该怎么办了**？

这并非是不可能的事情，一个典型的例子便是`JNDI`服务，`JNDI`现在已经是Java的标准服务，它的代码
由启动类加载器去加载（在JDK1.3时代放进`rt.jar`中），但`JNDI`的目的就是对资源进行集中管理和查找，
它需要调用由独立厂商实现并部署在应用程序的`ClassPath`下的`JNDI`接口提供者（`SPI，Service Provider Interface`）
的代码，但启动类加载器不可能“认识`这些代码啊！那该怎么办？





