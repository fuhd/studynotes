破坏双亲委派模型
=========================================================================
双亲委派模型并不是一个强制性的约束模型，而是Java设计者们 **推荐** 给开发者们的类加载器实现方式。
在Java的世界里面 **大部分的类加载器都遵循这个模型**，但也有例外的情况，到现在为止，双亲委派模型
主要出现过 **三次较大规模的“被破坏”情况**。

### 第一次“被破坏”
双亲委派模型的第一次“被破坏”其实 **发生在双亲委派模型出现之前**————即JDK1.2发布之前。
由于双亲委派模型在JDK1.2之后才被引入的，而类加载器和抽象类`java.lang.ClassLoader`则
在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，**Java设计者们引入双
亲委派模型时不得不做出一些妥协**。为了向前兼容，JDK1.2之后的 **`java.lang.ClassLoader`** 添加
了一个新的 **`protected`方法`findClass()`**，在此之前，用户去继承`java.lang.ClassLoader`的
**唯一目的就是为了重写`loadClass()`方法**，因为虚拟机在进行类加载的时候会调用加载器的私有方法
`loadClassInternal()`，而这个方法的唯一逻辑就是去调用自己的`loadClass()`。

上一节我们已经看过`loadClass()`方法的代码，双亲委派的具体逻辑就实现在这个方法之中，**JDK1.2之后
已不提倡用户再去覆盖`loadClass()`方法，而应当把自己的类加载逻辑写到`findClass()`方法中，
在`loadClass()`方法的逻辑里如果父类加载失败，则会调用自己的`findClass()`方法来完成加载，
这样就可以保证新写出来的类加载器是符合双亲委派规则的**。

### 第二次“被破坏”
双亲委派模型的第二次“被破坏”是 **由这个模型自身的缺陷所导致的**，双亲委派很好地解决了 **各个类加载
器的基础类的统一问题**（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们
总是作为被用户代码调用的API，但世事往往没有绝对的完美，**如果基础类又要调用回用户的代码，那该怎么办了**？

这并非是不可能的事情，一个典型的例子便是`JNDI`服务，**`JNDI`现在已经是Java的标准服务，它的代码
由启动类加载器去加载**（在JDK1.3时代放进`rt.jar`中），但`JNDI`的目的就是对资源进行集中管理和查找，
**它需要调用由独立厂商实现并部署在应用程序的`ClassPath`下的`JNDI`接口提供者（`SPI，Service Provider Interface`）
的代码，但启动类加载器不可能“认识`这些代码啊！那该怎么办**？

为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器（`Thread Context ClassLoader`）。
这个类加载器可以通过`java.lang.Thread`类的`setContextClassLoader()`方法进行设置，如果创建线程时
还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用
程序类加载器**。

有了线程上下文类加载器，就可以做一些“舞弊”的事情了，`JNDI`服务使用这个线程上下文类加载器去加载所需要的SPI代码，
**也就是父类加载器请求子类加载器去完成类加载的动作**，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用
类加载器，**已经违背了双亲委派模型的一般性原则**，但这也是无可奈何的事情。**Java中所有涉及SPI的加载动作基本上都
采用这种方式，例如：`JNDI`，`JDBC`，`JCE`，`JAXB`和`JBI`等**。

### 第三次“被破坏”
双亲委派模型的第三次“被破坏”是由于 **用户对程序动态性的追求而导致的**，这里所说的“动态性”指的是当前一些
非常“热”门的名词：**代码热替换（`HotSwap`）、模块热部署（`Hot Deployment`）** 等。

在`JSR-297`、`JSR-277`规范从纸上标准变成真正可运行的程序之前，`OSGI`是当前业界“事实上”的Java模块化标准，
**而`OSGI`实现模块化热部署的关键则是它自定义的类加载器机制的实现**。每一个程序模块（`OSGI`中称为`Bundle`）
都有一个自己的类加载器，当需要更换一个`Bundle`时，就把`Bundle`连同类加载器一起换掉以实现代码的热替换。

**在`OSGI`环境下，类加载器不再是双亲委派模型中的树状结构**，而是进一步发展为网状结构，当收到类加载请求时，
`OSGI`将按照下面的顺序进行类搜索：
1. 将以`java.*`开头的类，委派给父类加载器加载。
2. 否则，将委派列表名单内的类，委派给父类加载器加载。
3. 否则，将`Import`列表中的类，委派给`Export`这个类的`Bundle`的类加载器加载。
4. 否则，查找当前`Bundle`的`ClassPath`，使用自己的类加载器加载。
5. 否则，查找类是否在自己的`Fragment Bundle`中，如果在，则委派给`Fragment Bundle`的类加载器加载。
6. 否则，查找`Dynamic Import`列表的`Bundle`，委派给对应`Bundle`的类加载器加载。
7. 否则，类查找失败。

上面的查找顺序中 **只有开头两点仍然符合双亲委派规则**，其余的类查找都是在 **平级** 的类加载器中进行的。

`OSGI`中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在
不少争议，但在Java程序员中基本有一个共识：`OSGI`中对类加载器的使用是很值得学习的，弄懂了`OSGI`的实现，
自然就明白了类加载器的精粹。












