ChannelHandler和ChannelPipeline
=================================================================
### ChannelHandler接口
从应用程序开发人员的角度来看，**Netty的主要组件是`ChannelHandler`，它充当了所有处理入站
和出站数据的应用程序逻辑的容器**。`ChannelHandler`的方法是由网络事件触发的。事实上，
**`ChannelHandler`可专门用于几乎任何类型的动作**，例如将数据从一种格式转换为另外一种格式，
或者处理转换过程中所抛出的异常。

举例来说，`ChannelInboundHandler`是一个你将会经常实现的子接口。这种类型的`ChannelHandler`接收
入站事件和数据，这些数据随后将会被你的应用程序的业务逻辑所处理。当你要给连接的客户端发送响应时，
也可以从`ChannelInboundHandler`flush数据。你的应用程序的业务逻辑通常驻留在一个或多个`ChannelInboundHandler`中。

### ChannelPipeline接口
**`ChannelPipeline`提供了`ChannelHandler`链的容器，并定义了用于在该链上传播入站和出站事件流的API**。
当`Channel`被创建时，它会被自动地分配到它专属的`ChannelPipeline`。

`ChannelHandler`安装到`ChannelPipeline`中的过程如下：
+ **一个`ChannelInitializer`的实现被注册到了`ServerBootstrap`（或者`Bootstrap`）中**；
+ **当`ChannelInitializer.initChannel()`方法被调用时，`ChannelInitializer`将在`ChannelPipeline`中
安装一组自定义的`ChannelHandler`**；
+ **`ChannelInitializer`将它自己从`ChannelPipeline`中移除**；

使得事件流经`ChannelPipeline`是`ChannelHandler`的工作，**它们是在应用程序的初始化或者引导阶段被安装的。
这些对象接收事件、执行它们所实现的处理逻辑，并将数据传递给链中的下一个`ChannelHandler`。它们的执行顺序是由它们
被添加的顺序所决定的**。

**Netty应用程序中入站和出站数据流之间的区别是什么**？从一个客户端应用程序的角度来看，如果事件的运动方向是从客户端到服务器端，
那么我们称这些事件为 **出站** 的，反之则称为 **入站** 的。

