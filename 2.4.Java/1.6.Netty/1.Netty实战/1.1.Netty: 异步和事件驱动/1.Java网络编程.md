Java网络编程
====================================================================
最早的`Java`（1995 ~ 2002）引入了足够多的面向对象`facade`（门面）来隐藏一些棘手的细节问题，
但是创建一个复杂的客户端/服务器协议仍然需要大量的样板代码（以及相当多的底层研究才能使它整个流畅地运行起来）。

那些最早期的`Java API`（`java.net`）只支持由本地系统套接字库提供的所谓的阻塞函数。下面代码清单展示
了一个使用了这些函数调用的服务器代码的普通示例：
```java
//创建一个新的ServerSocket，用以监听指定端口上的连接请求
ServerSocket serverSocket = new ServerSocket(portNumber);
//对accept()方法的调用将被阻塞，直到一个连接建立
Socket socket = serverSocket.accept();
//这些流对象都派生于该套接字的流对象
BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
//如果客户端发送了“Done”，则退出处理循环
String request, response;
while((request = in.readLine()) != null) {
    if("Done".equals(request)) {
        break;
    }
    //请求被传递给服务器的处理方法
    response = processRequest(request);
    //服务器的响应被发送给客户端
    out.println(response);
}
```
上面的代码实现了`Socket API`的基本模式之一。以下是最重要的几点：
+ `ServerSocket`上的 **`accept()`方法将会一直阻塞到一个连接建立**，随后返回一个新的`Socket`用于客户端和服务器
之间的通信。该`ServerSocket`将继续监听传入的连接。
+ `BufferedReader`和`PrintWriter`都衍生自`Socket`的输入输出流。前者从一个字符输入流中读取文本，
后者打印对象的格式化的表示到文本输出流。
+ **`readLine()`方法将会阻塞**，直到一个由换行符或者回车符结尾的字符串被读取。