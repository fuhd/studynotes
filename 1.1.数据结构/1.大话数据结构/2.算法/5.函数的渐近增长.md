函数的渐近增长
==============================================================
### 例一
我们现在来判断一下，两个算法A和B哪个更好。假设两个算法的输入规模都是`n`，算法A要做`2n+3`次操作，
你可以理解为先有一个`n`次的循环，执行完成后，再有一个`n`次循环，最后有3次赋值或运算，共`2n+3`次操作。
算法B要作`3n+1`次操作。你觉得它们谁更快呢？

准确来说，**答案是不一定的**。

![2-8-1](../img/2-8-1.png)

当`n=1`时，算法A效率不如算法B；而当`n=2`时，两者效率相同；当`n>2`时，算法A就开始优于算法B了，
随着`n`的增加，算法A比算法B越来越好了。于是我们可以得出结论，算法A总体上要好过算法B。

此时我们给出这样的定义，输入规模`n`在没有限制的情况下，只要超过一个 **数值N** ，这个函数就总是大于
另一个函数，我们称函数是渐近增长的。

> **函数的渐近增长：给定两个函数`f(n)`和`g(n)`，如果存在一个整数N，使得对于所有的`n>N`，`f(n)`总是
> 比`g(n)`大，那么，我们说`f(n)`的渐近增长快于`g(n)`**。

从中我们发现，随着`n`的增大，后面的`+3`还是`+1`其实是不影响最终的算法变化的，例发算法A'与算法B'，
所以，我们 **可以忽略这些加法常数**。后面的例子，这样的常数被忽略的意义可能会更加明显。

### 例二
我们来看第二个例子，算法C是`4n+8`，算法D是`2n2+1`：

![2-8-2](../img/2-8-2.png)

当`n<=3`的时候，算法C要差于算法D，但当`n>3`后，算法C的优势就越来越优于算法D了，到后来更是远远胜过。
而当后面的常数去掉后，我们发现其实结果没有发生改变。甚至我们再观察发现，哪怕去掉与`n`相乘的常数，
这样的结果也没发生改变，算法C'的次数随着`n`的增长，还是远小于算法D'。也就是说，**与最高次项相乘的常数并不重要**。

### 例三
我们再来看第三个例子。算法E是`2n2+3n+1`，算法F是`2n3+3n+1`：

![2-8-3](../img/2-8-3.png)

当`n=1`的时候，算法E与算法F结果相同，但当`n>1`后，算法E的优势就要开始优于算法F，随着`n`的增大，
差异非常明显。通过观察发现，**最高次项的指数大的，函数随着`n`的增长，结果也会变得增长特别快。**

### 例四
我们来看最后一个例子。算法G是`2n2`，算法H是`3n+1`，算法I是`2n2+3n+1`：

![2-8-4](../img/2-8-4.png)

这组数据应该就看得很清楚。当`n`的值越来越大时，你会发现，`3n+1`已经没法和`2n2`的结果相比较，
最终几乎可以忽略不计。也就是说，随着`n`值变得非常大以后，算法G其实已经很趋近于算法I。于是我们可以得到这样一个结论，
**判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数**。

根据刚才的几个样例，我们发现，如果我们可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：
**某个算法，随着`n`的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法的理论依据，
通过算法时间复杂度来估算算法时间效率**。
