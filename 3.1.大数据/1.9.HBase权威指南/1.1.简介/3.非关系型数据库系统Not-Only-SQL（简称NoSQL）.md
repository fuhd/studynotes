非关系型数据库系统Not-Only-SQL（简称NoSQL）
================================================================================
**NoSQL** 是`Eric Evans`针对`Johan Oskarsson`提出的“为新兴的新数据存储空间命名”问题而创建
的一个名词。正是因为这类新产品还没有合适的名称，NoSQL一举成名。

**标示符号化** 实际上是一个不错的选择：**最新的存储系统不提供通过SQL查询数据的手段，只提供一些
比较简单的、类似于API接口的方式来存取数据**。

但是，**也有一些工具为NoSQL数据存储提供了SQL语言的入口**，用于执行一些关系数据库中常用的复杂条
件查询。因此，**从查询方式上的限制来说，关系型数据库和非关系型数据库并没有严格的区分**。

**实际上两者在底层上是有区别的，尤其涉及到模式或者ACID事务特性时，因为这与实际的存储架构是相关
的**。很多这一类的新系统首先做的事情是：**抛弃一些限制因素以提升扩展性**。例如，它们 **通常不支
持事务或辅助索引**。更重要的是，这一类系统是没有固定模式的，可以随着应用的改变而灵活变化。

各种非关系型数据库有许多共同的特性，同时这其中的许多特性与传统的存储方案也有很多共同点。因此新系
统并不是革命性的产品，从工程的角度来看更像是产品的进化。

假使连Memcached这样的项目都划入到NoSQL范畴的话，那就成了只要不是RDBMS就可以认为是NoSQL。这个
说法导致了错误的二分法，二分法掩盖了这些系统提供的令人振奋的技术可行性。在NoSQL范畴内，还有很多
的维度可以区分系统的特定优势所在。

```
一致性模型

在这本书里，我们经常会提到一致性问题，所以有必要在这里对它稍加介绍。一开始的一致性是保证数据库客户端操作的正确性，数据库必
须保证每一步操作都是从一个一致的状态到下一个一致的状态。系统没有明确地指定如何实现这个功能，以便系统可以有多种选择。最终，
系统要选择是进入下一个一致的状态，还是回退到上一个一致的状态，从而保证一致性。

一致性可以按照严格程度由强到弱分类，或者是按照对客户端的保证程度分类，下面是一个非正式的分类列表：
- 严格一致性：数据的变化是原子的，一经改变即时生效，这是一致性的最高形式。
- 顺序一致性：每个客户端看到的数据依照它们操作执行的顺序而变化。
- 因果一致性：客户端以因果关系顺序观察到数据的改变。
- 最终一致性：在没有更新数据的一段时间里，系统将通过广播保证副本之间的数据一致性。
- 弱一致性：没有做出保证的情况下，所有的更新会通过广播的形式传递，展现给不同客户端的数据顺序可能不一样。

采用最终一致性策略的系统还可以细分为几个子类，并且这些子策略还可以共存。亚马逊的首席技术官Werner Vogels在一篇名为
“Eventually Consistent”的文章中列举了这几个子类。这篇文章还谈到了CAP定理（CAP theorem），其中指出，一个分布式系统
只能同时实现一致性、可用性和分区容忍性（或分区容错性）中的两个。CAP定理是热点话题，不过它不是区分分布式系统的唯一方法，但
CAP定理指出了，开发一套同时满足以上需求的分布式系统是比较困难的。例如，Vogels提到：

"在一系列的研究结果里发现，在较大型分布式系统中，由于网络分隔，一致性与可用性不能同时满足。这意味着三个要素最多只能同时实
现两人个，不可能三者兼顾；放宽一致性的要求会提升系统的可用性......提升一致性意味着系统需要牺牲一定的可用性。"

放宽一致性来提高系统可用性是一个非常有效的提议。不过这种方案会强制让应用层去解决一致性的问题，因此也会增加系统的复杂度。
```

## 1.维度
让我们来挑几种维度简单介绍一下。需要注意的是，**列举的这些维度并不全面**，并且这也不是唯一的区分
方式。

### 数据模型
数据有多种存储的方式，包括 **键/值对**（类似于HashMap）、**半结构化的列式存储** 和 **文档结构
存储**。用户的应用如何存取数据？同时数据模式是否随着时间而变化？

### 存储模型
**内存还是持久化**？坦率来说做出这个决定并不难，其主要原因是，我们可以将其与RDBMS进行对比，它们
通常持久化存储数据到磁盘中。即使需要的是纯粹的内存模式，也仍旧有其他方案。**一旦考虑持久化存储，
就需要考虑选择的方案是否会影响到访问模式**。

### 一致性模型
**严格一致性还是最终一致性**？问题是存储系统如何实现它的目标，必须降低一致性要求吗？虽然这种问题
很粗浅，但是在特定的场景中会产生巨大影响。**因为一致性可能会影响操作延时，即系统响应读写请求的速
度。这需要权衡投入和产出后得到一个折中结果**。

### 物理模型
**分布式模式还是单机模式**？这种架构看起来像什么？是仅仅运行在单个机器上，还是分布在多台机器上，
但分布及扩展规则由客户端管理，换句话说，由用户自己的代码管理？

### 读/写性能
用户必须了解自己的应用程序的访问模式。**是读多写少？还是读写相当？或者是写多读少？是用范围扫描数
据好，还是用随机读请求数据更好？** 有些系统仅仅对这些情况中的一种支持得非常好，有些系统则对各种
情况都提供了很好的支持。

### 辅助索引
**辅助索引支持用户按不同的字段和排序方式来访问表**。这个维度覆盖了某些完全没有辅助索引支持且不保
证数据排序的系统（类似于HashMap），到某些可能通过外部手段简单支持这些功能的系统。如果存储系统不
提供这项功能，用户的应用可以应对或自己模拟辅助索引吗？

### 故障处理
**机器会崩溃是一个客观存在的问题，需要有一套数据迁移方案来应对这种情况（关于这一点可以参考在“一
致性模型”中讨论的CAP定理）**。每个数据存储如何进行服务器故障处理？故障处理完毕之后是否可以正常工
作？如果替换掉故障服务器，那么恢复100%服务的难度有多大？从一个正在提供服务的集群中卸载一台服务器
时，也会遇到类似的问题。

### 压缩
**当用户需要存储TB级的数据时，尤其当这些数据差异性很小或由可读性文本组成时，压缩会带来非常好的效
果，即能节省大量的原始数据存储**。有些压缩算法可以将此类的数据压缩到原始文件大小的十分之一。有可
选择的压缩组件吗？又有哪些压缩算法可用？

### 负载均衡
**假如用户有高读写吞吐率的需求，就要考虑配置一套能够随着负载变化自动均衡处理能力的系统**。虽然这
样不能完全解决该问题，但是也可以帮助用户设计高读写吞吐量的程序。

### 原子操作的读——修改——写
RDBMS提供了很多这类的操作，但这些操作在分布式系统中较难实现，**这些操作可以帮助用户避免多线程造
成的资源竞争，也可以帮助用户完成无共享应用服务器的设计**。有了这些 **比较并交换**（`compare and swap`,
**CAS**）操作，或者说 **检查并设置**（`check and set`）操作，在设计系统的时候可以有效地降低
客户端的复杂度。

## 2.可扩展性
**RDBMS非常适合事务性操作，但不见长于超大规模的数据分析处理，因为超大规模的查询需要进行大范围的
数据记录扫描或全表扫描**。分析型数据库可以存储数百或数千TB的数据，在一台服务器上做查询工作的响应
时间，会远远超过用户可接受的合理响应时间。垂直扩展服务器性能，即增加CPU核数和磁盘数目，也并不能很
好地解决该问题。

更糟糕的是，**RDBMS的等待和死锁的出现频率，与事务和并发的增加并不是线性关系，准确地说，与并发数
目的平方及事务规模的3次方甚至5次方相关**。分区通常是一个不切合实际的解决方案，因为它需要客户端采
用非常复杂的方式和较高的代价来维护分区信息。

一些商业RDBMS也解决过类似的问题，但它们往往只是特定地解决了问题的某几个方面，更重要的是，它们非
常非常昂贵。**而一些开源的RDBMS解决方案中，往往放弃了其中的一些甚至全部的关系型特性，如辅助索引，
来换取更高的性能拓展能力**。

问题是，**为了性能而一直放弃以上关系型特性是否值得？用户可以反范式化数据模型来避免等待，并且可以
通过降低锁粒度的方式来尽量避免死锁。数据增长时，无需重新分区迁移数据并内嵌水平扩展性的方法。最后，
用户还要面对容错和数据可用性问题，采用提高扩展性的机制，用户最终会得到一个NoSQL的解决方案，更确
切地说，HBase可以满足以上多种需求**。

## 3.数据库的范式化和反范式化





















































dd
