分区表、管理表
=================================================================================
数据分区的一般概念存在已久。其可以有多种形式，但是 **通常使用分区来水平分散压力**。

**Hive中有分区表的概念**。我们可以看到 **分区表具有重要的性能优势**，而且分区表还可以将数据以一种
符合逻辑的方式进行组织，比如分层存储。

我们首先讨论一下 **分区管理表**。重新来看之前的那张emplyees表，并假设我们在一个非常大的跨国公司
工作。我们的HR人员 **经常会执行一些带WHERE语句的查询**，这样可以将结果限制在某个特定的国家或者某个
特定的第一级细分（为简单起见我们将只使用到state（州））。那么，**让我们先按照country（国家）再按
照state（州）来对数据进行分区吧**：
```sql
CREATE TABLE employees (
    name            STRING,
    salary          FLOAT,
    subordinates    ARRAY<STRING>,
    deductions      MAP<STRING, FLOAT>,
    address         STRUCT<street:STRING, city:STRING, state:STRING, zip:INT>)
PARTITIONED BY (country STRING, state STRING);
```
**分区表改变了Hive对数据存储的组织方式**。如果我们是在mydb数据库中创建的这个表，那么对于这个表只
会有一个employees目录与之对应：
```
hdfs://master_server/user/hive/warehouse/mydb.db/employees
```
但是，**Hive现在将会创建好可以反映分区结构的子目录**。例如：
```
...
.../employees/country=CA/state=AB
.../employees/country=CA/state=BC
...
.../employees/country=US/state=AL
.../employees/country=US/state=AK
...
```
是的，**那些是实际的目录名称**。州目录下将会包含有零个文件或者多个文件，这些文件中存放着那些州的雇
员信息。

**分区字段**（这个例子中就是country和state）一旦创建好，表现得就得变通的字段一样。事实上，**除非
需要优化查询性能**，否则使用这些表的用户不需要关心这些“字段”是否是分区字段。

例如，下面这个查询语句将会查找出在美国伊利诺斯州的所有雇员：
```sql
SELECT * FROM employees WHERE country = 'US' AND state = '1L';
```
需要注意的是，**因为country和state的值已经包含在文件目录名称中了，所以也就没有必要将这些值存放到
它们目录下的文件中了**。事实上，数据只能从这些文件中获得，因此用户需要在表的模式中说明这点，而且这
个数据浪费空间。

**对数据进行分区，也许最重要的原因就是为了更快地查询**。在前面那个将结果范围限制在伊利诺斯州的雇员
的查询中，**仅仅需要扫描一个目录下的内容即可**。即使我们有成千上万个国家和州目录，除了一个目录其他
的都可以忽略不计。对于非常大的数据集，分区可以显著地搞高查询性能，除非对分区进行常见的范围筛选（例如，
按照地理位置范围或按照时间范围等）。

**当我们在WHERE子句中增加谓词来按照分区值进行过滤时，这此谓词被称为分区过滤器**。

如果表中的数据以及分区个数都非常大的话，执行这样一个包含有所有分区的查询可能会触发一个巨大的MapReduce
任务。**一个高度建议的安全措施就是将Hive设置为“strict（严格）”模式，这样如果对分区表进行查询而WHERE
子句没有加分区过滤的话，将会禁止提交这个任务**。用户也可以按照下面的语句将属性值设置为 **“nostrict
（非严格）”**：
```sql
hive> set hive.mapred.mode=strict;

hive> SELECT e.name, e.salary FROM employees e LIMIT 100;
FAILED: Error in semantic analysis: No partition predicate found for Alias "e" Table "employees"

hive> set hive.mapred.mode=nonstrict;

hive> SELECT e.name, e.salary FROM employees e LIMIT 100;
John Doe 100000.0
...
```
**可以通过SHOW PARTITIONS命令查看表中存在的所有分区**：
```sql
hive> SHOW PARTITIONS employees;
...
country=CA/state=AB
country=CA/state=BC
...
country=US/state=AL
country=US/state=AK
...
```
如果表中现在存在很多的分区，**而用户只想查看是否存储某个特定分区键的分区的话，用户还可以在这个命令
上增加一个指定了一个或者多个特定分区字段值的PARTITION子句，进行过滤查询**：
```sql
hive> SHOW PARTITIONS employees PARTITION(country='US');
country=US/state=AL
country=US/state=AK
...
hive> SHOW PARTITIONS employees PARTITION(country='US',state='AK');
country=US/state=AK
```
**DESCRIBE EXTENDED employees命令也会显示出分区键**：
```sql
hive> DESCRIBE EXTENDED employees;
name            string,
salary          float,
...
address         struct<...>,
country         string,
state           string,

Detailed Table Infomation...
partitionKeys: [FieldSchema(name:country, type:string, comment:null),
    FieldSchema(name:state, type:string, comment:null)],
...
```
输出信息中的模式信息部分会将country和state以及其他字段列在一起，因为就查询而言，它们就是字段。
**Detailed Table Infomation（详细表信息）将country和state作为分区键处理**。这两个键当前的
注释都是null，我们也可以像给普通的字段增加注释一样给分区字段增加注释。

**在管理表中用户可以通过载入数据的方式创建分区**。如下例中的语句在从一个本地目录（$HOME/california-employees）
载入数据到表中的时候，将会创建一个US/CA（表示加利福尼亚州）分区。**用户需要为每个分区字段指定一个值**。
**请注意我们在HiveQL中是如何引用HOME环境变量的**：
```sql
LOAD DATA LOCAL INPATH '${env:HOME}/califormia-employees'
INTO TABLE employees
PARTITION (country='US', state='CA')
```
**Hive将会创建这个分区对应的目录** .../employees/country=US/state=CA，而且$HOME/california-employees
这个目录下的文件将会 **被拷贝到上述分区目录下**。

### 1.外部分区表
**外部表同样可以使用分区**。事实上，用户可能会发现，这是管理大型生产数据集最常见的情况。这种结合
给用户 **提供了一个可以和其他工具共享数据的方式，同时也可以优化查询性能**。

我们举一个新例子，非常适合这种场景，**即日志文件分析**。对于日志信息，大多数的组织使用一个标准的
格式，其中记录有时间戳、严重程序（例如ERROR、WARTING、INFO），也许还包含有服务器名称和进程ID，
然后跟着一个可以为任何内容的文本信息。

我们可以按照如下方式来定义对应的Hive表：
```sql
CREATE EXTERNAL TABLE IF NOT EXISTS log_messages (
    hms           INT,
    severity      STRING,
    server        STRING,
    process_id    INT,
    message       STRING)
PARTITIONED BY (year INT, month INT, day INT)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t';
```
我们现在假定将日志数据按照天进行划分，划分数据尺寸合适，而且按天这个粒度进行查询速度也足够快。

回想下，之前我们创建过一个 **非分区外部表**，是一个股票交易表，那时 **要求使用一个LOCATION子句**。
对于 **外部分区表则没有这样的要求**。有一个 **ALTER TABLE语句可以单独进行增加分区。这个语句需要为
每一个分区键指定一个值**，本例中，也就是需要为year、month和day这3个分区键都指定值。下面是一个例子，
演示如何增加一个2012年1月2日的分区：
```sql
ALTER TABLE log_messages ADD PARTITION(year=2012,month=1,day=2)
    LOCATION 'hdfs://master_server/data/log_messages/2012/01/02';
```
**我们使用的目录组织习惯完全由我们自己定义**。这里，我们按照分层目录结构组织，因为这是一个合乎逻辑
的数据组织方式，但是并非要求一定如此。我们可以遵从Hive的目录命名习惯（例如，.../exchange=NASDAQ/symbol=AAPL），
**但是也并非要求一定如此**。


### 2.自定义表的存储格式



















































ddd
