使用Hadoop来分析数据
===============================================================================
**为了充分利用`Hadoop`提供的并行处理优势，我们需要将查询表示成`MapReduce`作业**。完成某种本地端的小规模测试之后，
就可以把作业部署到在集群上运行。

### map和reduce
**`MapReduce`任务过程分为两个处理阶段。`map`阶段和`reduce`阶段**。每阶段都以 **键/值对** 作为输入和输出，其类型
由程序员来选择。程序员还需要写两个函数：**`map`函数** 和 **`reduce`函数**。

**`map`阶段的输入是`NCDC`原始数据**。我们选择 **文本格式** 作为输入格式，将数据集的 **每一行** 作为文本输入。键是
某一行起始位置相对于文件起始位置的偏移量，不过我们不需要这个信息，所以将其忽略。

我们的`map`函数很简单。由于我们只对 **年份** 和 **气温** 属性感兴趣，所以只需要取出这两个字段数据。**在本例中，`map`函数
只是一个数据准备阶段**，通过这种方式来准备数据，使`reduce`函数能够继续对它进行处理：即找出每年的最高气温。**`map`函数还是一
个比较适合去除已损记录的地方**：此处，我们筛掉缺失的、可疑的或错误的气温数据。

为了全面了解`map`的工作方式，我们考虑以下输入数据的示例数据（考虑到篇幅，去除了一些未使用的例，并用省略号表示）：
```
0067011990999991950051507004...9999999N9+00001+99999999999...
0043011990999991950051512004...9999999N9+00221+99999999999...
0043011990999991950051518004...9999999N9-00111+99999999999...
......
```
这些行以键/值对的方式作为`map`函数的输入：
```
(0,0067011990999991950051507004...9999999N9+00001+99999999999...)
(106,0043011990999991950051512004...9999999N9+00221+99999999999...)
(212,0043011990999991950051518004...9999999N9-00111+99999999999...)
......
```
键（`key`）是文件中的行偏移量，`map`函数并不需要这个信息，所以将其忽略。`map`函数的功能仅限于提取年份和气温信息，
并将它们作为输出（气温值已用整数表示）：
```
(1950,0)
(1950,22)
(1950,-11)
......
```
**`map`函数的输出经由`MapReduce`框架处理后，最后发送到`reduce`函数。这个处理过程基于键来对键/值对进行排序和分组**。
因此，在这一示例中，`reduce`函数看到的是如下输入：
```
(1949,[111,78])
(1950,[0,22,-11])
```
每一年份后紧跟着一系列气温数据。`reduce`函数现在要做的是遍历整个列表并从中找出最大的读数：
```
(1949,111)
(1950,22)
```
这是最终输出结果，每一年的全球最高气温记录。

### Java MapReduce
下面写代码实现它，我们需要三样东西：一个`map`函数、一个`reduce`函数和一些用来运行作业的代码。**`map`函数由`Mapper`
类来表示，后者声明一个抽象的`map()`方法**。下面范例显示了我们的`map`函数实现：
```java
import java.io.IOException;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class MaxTemperatureMapper extends MapReduceBase implements Mapper<LongWritable,Text,IntWritable> {

    private static final int MISSING = 9999;

    @Override
    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
        String line = value.toString();
        String year = line.substring(15, 19);
        int airTemperature;
        if(line.charAt(87) == '+') {
            airTemperature = Integer.parseInt(line.substring(88, 92));
        } else {
            airTemperature = Integer.parseInt(line.substring(87, 92));
        }
        String quality = line.substring(92, 93);
        if(airTemperature != MISSING && quality.matches("[01459]")) {
            context.write(new Text(year), new IntWritable(airTemperauture));
        }
    }
}
```





