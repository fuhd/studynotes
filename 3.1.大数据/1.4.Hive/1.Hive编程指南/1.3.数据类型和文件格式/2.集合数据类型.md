集合数据类型
=================================================================================
Hive中的列支持使用 **struct，map和array** 集合数据类型。

集合数据类型：

| 数据类型 | 描述 |
| :------------- | :------------- |
| **STRUCT** | 和C语言中的 **struct或者“对象”** 类似，都可以 **通过”点“符号访问元素内容**。例如，如果某个列的数据类型是 **STRUCT<first:STRING, last:STRING>**，那么第1个元素可以通过 **字段名.first** 来引用 |
| **MAP** | MAP是一组键/值对集合，**使用数组表示法（例如['key']）** 可以访问元素。例如，如果某个列的数据类型是MAP，其中键/值对是：'first':'John'和'last':'Doe'，那么可以通过 **字段名['last']** 获取最后1个元素 |
| **ARRAY** | 数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，**编号从零开始**。例如，数组值为['John','Doe']，那么第2个元素可以通过 **数组名[1]** 进行引用 |

和基本数据类型一样，**这些类型的名称同样是保留字**。

**大多数的关系型数据库并不支持这些集合数据类型，因为使用它们会趋向于破坏标准格式**。例如，在传统数据模型中，
struct可能需要由多个不同的表拼装而成，表间需要适当地使用外键来进行连接。

**破坏标准格式所带来的一个实际问题是会增大数据冗余的风险，进而导致消耗不必要的磁盘空间，还有可能造成数据
不一致，因为当数据发生改变时冗余的拷贝数据可能无法进行相应的同步**。

然而，**在大数据系统中，不遵循标准格式的一个好处就是可以提供更高吞吐量的数据。当处理的数据的数量级是T或者P
时，以最少的“头部寻址”来从磁盘上扫描数据是非常必要的。按数据集进行封装的话可以通过减少寻址次数来提供查询
的速度。而如果根据外键关系关联的话则需要进行磁盘间的寻址操作，这样会有非常高的性能消耗**。
```
提示：Hive中并没有键的概念。但是，用户可以对表建立索引。
```
这里有一个用于演示如何使用这些数据类型的表结构声明语句，这是一张虚拟的人力资源应用程序中的员工表：
```sql
CREATE TABLE employees (
    name            STRING,
    salary          FLOAT,
    subordinates    ARRAY<STRING>,
    deductions      MAP<STRING, FLOAT>,
    address         STRUCT<street:STRING, city:STRING, atate:STRING, zip:INT>
);
```
其中，name是一个简单的字符串；对于大多数雇员来说，salary（薪水）使用float浮点数类型来表示就已经足够了；
subordinates（下属员工）列表是一个字符串值数组。在该数组中，我们可以认为name是“主键”，因此subordinates
中的每一个元素都将会引用这张表中的另一条记录。对于没有下属的雇员，这个字段对应的值就是一个空的数组。
在传统的模型中，将会以另外一种方式来表示这种关系，也就是雇员和雇员的经理这种对应关系。

字段deductions是一个由键/值对构成的map，其记录了每一次的扣除额，这些钱将会在发薪水的时候从员工工资
中扣除掉。map中的键是扣除金额项目的名称（例如“国家税收”），而且键可以是一个百分比值，也可以完全就是一个
数值。在传统数据模型中，这个扣除额项目的名称可能存在于不同的表中。这些表在存放特定扣除额值的同时，
还有一个外键指向对应的雇员记录。

最后，每名雇员的家庭住址使用struct数据类型存储，其中的每个域都被作了命名，并且具有一个特定的类型。

**注意：STRUCT中一旦声明好结构，那么其元素位置就不可以再改变**。
