类型系统
===================================================================================
## 总览
**Atlas允许用户为他们要管理的元数据对象定义模型**。该模型由称为“**类型**”的定义组成。称为“**实
体**”的“类型”的实例表示所管理的实际 **元数据对象**。类型系统是允许用户定义和管理类型和实体的组件。
开箱即用的Atlas管理的所有元数据对象（例如，像Hive表）**都使用类型进行建模并表示为实体**。为了在Atlas
中存储新类型的元数据，需要了解类型系统组件的概念。

## 类型
Atlas中的“类型”是对如何存储和访问特定类型的元数据对象的定义。**类型代表一个或一组属性，这些属性定
义元数据对象的属性**。具有开发背景的用户将认识到类型与 **面向对象编程语言的“类”定义**或关系数据库
的“表模式”相似。

**Hive表是Atlas本地定义的一种类型的示例**。配置单元表具有以下属性：
```yaml
Name:         hive_table
TypeCategory: Entity
SuperTypes:   DataSet
Attributes:
    name:             string
    db:               hive_db
    owner:            string
    createTime:       date
    lastAccessTime:   date
    comment:          string
    retention:        int
    sd:               hive_storagedesc
    partitionKeys:    array<hive_column>
    aliases:          array<string>
    columns:          array<hive_column>
    parameters:       map<string,string>
    viewOriginalText: string
    viewExpandedText: string
    tableType:        string
    temporary:        boolean
```
从上面的示例可以注意到以下几点：
+ Atlas中的类型由`name`唯一标识
+ 类型具有 **元类型**。Atlas具有以下亚型： 
    - 基本元类型：boolean, byte, short, int, long, float, double, biginteger, bigdecimal, string, date
    - 枚举元类型
    - 集合元类型：array（数组）， map（映射）
    - 复合元类型：Entity（实体）, Struct（结构）, Classification（分类）, Relationship（关系）
+ **Entity和Classification类型可以从称为“超类型”的其他类型“扩展”**，因此，它也将包括在超类型中定
义的属性。 这使建模者可以在一组相关类型中定义公共属性。这再次类似于面向对象语言如何为类定义超类的
概念。 **Atlas中的类型也可以从多个超级类型扩展**。在此示例中，每个配置单元表都从称为“ DataSet”的
预定义超类型扩展。稍后将提供有关此预定义类型的更多详细信息。
+ **具有“Entity”,“Struct”，“Classification”或“Relationship”的元类型的类型可以具有属性的集合**。
每个属性都有一个名称（例如“name”）和一些其他关联的属性。**可以使用表达式type_name.attribute_name
来引用属性。还要注意，属性本身是使用Atlas元类型定义的**。在此示例`hive_table.name`是一个字符串，
`hive_table.aliases`是一个字符串数组，`hive_table.db`引用了一个名为hive_db的类型的实例，依此类推。
+ 属性中的 **类型引用**（例如`hive_table.db`）特别有趣。注意，使用这样的属性，我们可以在Atlas中定义
的两种类型之间定义任意关系，从而构建丰富的模型。请注意，还可以收集作为属性类型的引用列表（例如
`hive_table.columns`，它表示从`hive_table`到`hive_column`类型的引用列表）。

## 实体
Atlas中的“**实体**”是“类型”的特定值或 **实例**，因此表示现实世界中的特定元数据对象。回到我们的
面向对象编程语言的类比，**“实例”是某个“类”的“对象”**。

实体的示例将是特定的配置hive表。说Hive在“default”数据库中有一个名为“customers”的表。该表将成为
`hive_table`类型的Atlas中的“entity”。由于是Entity类型的实例，它将为属于Hive表“类型”的每个属性具有
值，例如：
```yaml
guid:     "9ba387dd-fa76-429c-b791-ffc338d3c91f"
typeName: "hive_table"
status:   "ACTIVE"
values:
    name:             “customers”
    db:               { "guid": "b42c6cfc-c1e7-42fd-a9e6-890e0adf33bc", "typeName": "hive_db" }
    owner:            “admin”
    createTime:       1490761686029
    updateTime:       1516298102877
    comment:          null
    retention:        0
    sd:               { "guid": "ff58025f-6854-4195-9f75-3a3058dd8dcf", "typeName": "hive_storagedesc" }
    partitionKeys:    null
    aliases:          null
    columns:          [ { "guid": ""65e2204f-6a23-4130-934a-9679af6a211f", "typeName": "hive_column" }, { "guid": ""d726de70-faca-46fb-9c99-cf04f6b579a6", "typeName": "hive_column" }, ...]
    parameters:       { "transient_lastDdlTime": "1466403208"}
    viewOriginalText: null
    viewExpandedText: null
    tableType:        “MANAGED_TABLE”
    temporary:        false
```
从上面的示例可以注意到以下几点：
+ 实体类型的每个实例都由 **唯一标识符GUID** 标识。定义对象时，此GUID由Atlas服务器生成，并且在实体的
整个生命周期内保持不变。**在任何时间点，都可以使用其GUID访问此特定实体**。在此示例中，default数据
库中的“customers”表由GUID“ 9ba387dd-fa76-429c-b791-ffc338d3c91f”唯一标识。
+ 实体具有给定的类型，并且该类型的名称随实体定义一起提供。在此示例中，“customers”表是“ hive_table”。
+ 该实体的值是hive_table类型定义中定义的所有属性名称及其属性值的映射。
+ 属性值将取决于属性的数据类型。实体类型属性的值将为AtlasObjectId类型。

有了关于实体的想法，**我们现在可以看到Entity和Struct元类型之间的区别。 实体和结构都构成其他类型的属
性。 但是，实体类型的实例具有标识（具有GUID值），并且可以从其他实体引用（例如，从hive_table实体引
用hive_db实体）。 Struct类型的实例没有自己的标识。 Struct类型的值是“嵌入”在实体本身内部的属性的集
合**。

## 属性
我们已经看到 **属性是在诸如Entity，Struct，Classification和Relationship的元类型内部定义的**。但是我
们毫不客气地将属性称为具有名称和元类型值。但是，**Atlas中的属性具有更多的属性，这些属性定义了更多与
类型系统有关的概念**。

属性具有以下属性：
```yaml
 name:        string,
typeName:    string,
isOptional:  boolean,
isIndexable: boolean,
 isUnique:    boolean,
cardinality: enum
```
上面的属性具有以下含义：
+ name-属性名称
+ daypeName - 属性的元类型名称（native,集合或复合）
+ isComposite - 此标志指示建模的方面。**如果将属性定义为复合属性，则意味着它不能具有独立于其所包含实
体的生命周期**。此概念的一个很好的示例是构成hive表一部分的一组列。由于列在hive表之外没有意义，因此
将它们定义为复合属性；必须在Atlas中创建复合属性及其包含的实体，即，必须与hive表一起创建hive列。
+ isIndexable - 此标志指示 **是否应为此属性建立索引，以便可以使用属性值作为谓词执行查找，并且可以高效
执行查找**。
+ isUnique - 该标志再次与索引相关。如果指定为 **唯一**，则意味着在JanusGraph中为此属性创建了一个特殊
索引，该索引允许基于相等的查找；将此标志的值为true的任何属性都被视为主键，以将该实体与其他实体区分
开。因此，应确保此属性确实在现实世界中建模了唯一属性。例如，考虑hive_table的name属性。孤立地，名称
不是hive_table的唯一属性，因为具有相同名称的表可以存在于多个数据库中。如果Atlas在多个群集中存储配置
单元表的元数据，那么即使一对（数据库名称，表名称）也不是唯一的。在实际环境中，只能将集群位置，数据库名称和表名称视为唯一。