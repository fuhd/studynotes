类型系统
===================================================================================
## 总览
**Atlas允许用户为他们要管理的元数据对象定义模型**。该模型由称为“**类型**”的定义组成。称为“**实
体**”的“类型”的实例表示所管理的实际 **元数据对象**。类型系统是允许用户定义和管理类型和实体的组件。
开箱即用的Atlas管理的所有元数据对象（例如，像Hive表）**都使用类型进行建模并表示为实体**。为了在Atlas
中存储新类型的元数据，需要了解类型系统组件的概念。

## 类型
Atlas中的“类型”是对如何存储和访问特定类型的元数据对象的定义。**类型代表一个或一组属性，这些属性定
义元数据对象的属性**。具有开发背景的用户将认识到类型与 **面向对象编程语言的“类”定义**或关系数据库
的“表模式”相似。

**Hive表是Atlas本地定义的一种类型的示例**。配置单元表具有以下属性：
```yaml
Name:         hive_table
TypeCategory: Entity
SuperTypes:   DataSet
Attributes:
    name:             string
    db:               hive_db
    owner:            string
    createTime:       date
    lastAccessTime:   date
    comment:          string
    retention:        int
    sd:               hive_storagedesc
    partitionKeys:    array<hive_column>
    aliases:          array<string>
    columns:          array<hive_column>
    parameters:       map<string,string>
    viewOriginalText: string
    viewExpandedText: string
    tableType:        string
    temporary:        boolean
```
从上面的示例可以注意到以下几点：
+ Atlas中的类型由`name`唯一标识
+ 类型具有 **元类型**。Atlas具有以下亚型： 
    - 基本元类型：boolean, byte, short, int, long, float, double, biginteger, bigdecimal, string, date
    - 枚举元类型
    - 集合元类型：array（数组）， map（映射）
    - 复合元类型：Entity（实体）, Struct（结构）, Classification（分类）, Relationship（关系）
+ **Entity和Classification类型可以从称为“超类型”的其他类型“扩展”**，因此，它也将包括在超类型中定
义的属性。 这使建模者可以在一组相关类型中定义公共属性。这再次类似于面向对象语言如何为类定义超类的
概念。 **Atlas中的类型也可以从多个超级类型扩展**。在此示例中，每个配置单元表都从称为“ DataSet”的
预定义超类型扩展。稍后将提供有关此预定义类型的更多详细信息。
+ **具有“Entity”,“Struct”，“Classification”或“Relationship”的元类型的类型可以具有属性的集合**。
每个属性都有一个名称（例如“name”）和一些其他关联的属性。**可以使用表达式type_name.attribute_name
来引用属性。还要注意，属性本身是使用Atlas元类型定义的**。在此示例`hive_table.name`是一个字符串，
`hive_table.aliases`是一个字符串数组，`hive_table.db`引用了一个名为hive_db的类型的实例，依此类推。
+ 属性中的 **类型引用**（例如`hive_table.db`）特别有趣。注意，使用这样的属性，我们可以在Atlas中定义
的两种类型之间定义任意关系，从而构建丰富的模型。请注意，还可以收集作为属性类型的引用列表（例如
`hive_table.columns`，它表示从`hive_table`到`hive_column`类型的引用列表）。

## 实体
Atlas中的“**实体**”是“类型”的特定值或 **实例**，因此表示现实世界中的特定元数据对象。回到我们的
面向对象编程语言的类比，**“实例”是某个“类”的“对象”**。

实体的示例将是特定的配置hive表。说Hive在“default”数据库中有一个名为“customers”的表。该表将成为
`hive_table`类型的Atlas中的“entity”。由于是Entity类型的实例，它将为属于Hive表“类型”的每个属性具有
值，例如：
```yaml
guid:     "9ba387dd-fa76-429c-b791-ffc338d3c91f"
typeName: "hive_table"
status:   "ACTIVE"
values:
    name:             “customers”
    db:               { "guid": "b42c6cfc-c1e7-42fd-a9e6-890e0adf33bc", "typeName": "hive_db" }
    owner:            “admin”
    createTime:       1490761686029
    updateTime:       1516298102877
    comment:          null
    retention:        0
    sd:               { "guid": "ff58025f-6854-4195-9f75-3a3058dd8dcf", "typeName": "hive_storagedesc" }
    partitionKeys:    null
    aliases:          null
    columns:          [ { "guid": ""65e2204f-6a23-4130-934a-9679af6a211f", "typeName": "hive_column" }, { "guid": ""d726de70-faca-46fb-9c99-cf04f6b579a6", "typeName": "hive_column" }, ...]
    parameters:       { "transient_lastDdlTime": "1466403208"}
    viewOriginalText: null
    viewExpandedText: null
    tableType:        “MANAGED_TABLE”
    temporary:        false
```
从上面的示例可以注意到以下几点：
+ 实体类型的每个实例都由 **唯一标识符GUID** 标识。定义对象时，此GUID由Atlas服务器生成，并且在实体的
整个生命周期内保持不变。**在任何时间点，都可以使用其GUID访问此特定实体**。在此示例中，default数据
库中的“customers”表由GUID“ 9ba387dd-fa76-429c-b791-ffc338d3c91f”唯一标识。
+ 实体具有给定的类型，并且该类型的名称随实体定义一起提供。在此示例中，“customers”表是“ hive_table”。
+ 该实体的值是hive_table类型定义中定义的所有属性名称及其属性值的映射。
+ 属性值将取决于属性的数据类型。实体类型属性的值将为AtlasObjectId类型。

有了关于实体的想法，**我们现在可以看到Entity和Struct元类型之间的区别。 实体和结构都构成其他类型的属
性。 但是，实体类型的实例具有标识（具有GUID值），并且可以从其他实体引用（例如，从hive_table实体引
用hive_db实体）。 Struct类型的实例没有自己的标识。 Struct类型的值是“嵌入”在实体本身内部的属性的集
合**。

## 属性
我们已经看到 **属性是在诸如Entity，Struct，Classification和Relationship的元类型内部定义的**。但是我
们毫不客气地将属性称为具有名称和元类型值。但是，**Atlas中的属性具有更多的属性，这些属性定义了更多与
类型系统有关的概念**。

属性具有以下属性：
```yaml
 name:        string,
typeName:    string,
isOptional:  boolean,
isIndexable: boolean,
 isUnique:    boolean,
cardinality: enum
```
上面的属性具有以下含义：
+ name-属性名称
+ daypeName - 属性的元类型名称（native,集合或复合）
+ isComposite - 此标志指示建模的方面。**如果将属性定义为复合属性，则意味着它不能具有独立于其所包含实
体的生命周期**。此概念的一个很好的示例是构成hive表一部分的一组列。由于列在hive表之外没有意义，因此
将它们定义为复合属性；必须在Atlas中创建复合属性及其包含的实体，即，必须与hive表一起创建hive列。
+ isIndexable - 此标志指示 **是否应为此属性建立索引，以便可以使用属性值作为谓词执行查找，并且可以高效
执行查找**。
+ isUnique - 该标志再次与索引相关。如果指定为 **唯一**，则意味着在JanusGraph中为此属性创建了一个特殊
索引，该索引允许基于相等的查找；将此标志的值为true的任何属性都被视为主键，以将该实体与其他实体区分
开。因此，应确保此属性确实在现实世界中建模了唯一属性。例如，考虑hive_table的name属性。孤立地，名称
不是hive_table的唯一属性，因为具有相同名称的表可以存在于多个数据库中。如果Atlas在多个群集中存储hive
表的元数据，那么即使一对（数据库名称，表名称）也不是唯一的。在实际环境中，只能将集群位置，数据库名
称和表名称视为唯一。
+ multiplicity - 指示此属性是必需的、可选的还是可以是多值的。 如果实体的属性值定义与类型定义中的多重性
声明不匹配，则将违反约束，实体添加将失败。 因此，该字段可用于定义对元数据信息的一些约束。

使用上面的内容，让我们扩展下面的hive表的属性之一的属性定义。 让我们看一下名为“ db”的属性，该属性
代表hive表所属的数据库：
```yaml
db:
    "name":        "db",
    "typeName":    "hive_db",
    "isOptional":  false,
    "isIndexable": true,
    "isUnique":    false,
    "cardinality": "SINGLE"
```
注意“ isOptional = true”约束-如果没有数据库引用，则无法创建表实体。
```yaml
columns:
    "name":        "columns",
    "typeName":    "array<hive_column>",
    "isOptional":  optional,
    "isIndexable": true,
    “isUnique":    false,
    "constraints": [ { "type": "ownedRef" } ]
```
注意列的“ ownedRef”约束。 通过这样做，我们指示已定义的列实体应始终绑定到定义它们的表实体。

通过此描述和示例，您将能够认识到可以使用属性定义来影响要由Atlas系统实施的特定建模行为（约束，索引
等）。

## 系统特定类型及其意义
Atlas带有一些预定义的系统类型。在前面的部分中，我们看到了一个示例（`DataSet`）。在本节中，我们将看
到更多这些类型并了解它们的重要性。

### Referenceable（可引用）
此类型表示可以使用称为`qualifiedName`的唯一属性搜索所有实体。

### Asset（资产）
此类型扩展了`Referenceable`，并添加了诸如name，description和owner之类的属性。name是必填属性
（isOptional = false），其他是可选属性。

Referenceable和Asset的目的是为建模者提供一种在定义和查询自己类型的实体时强制保持一致性的方法。拥有
这些固定的属性集后，应用程序和用户界面就可以根据约定对默认情况下可以期望的类型做出哪些假设。

### Infrastructure（基础结构）
此类型扩展Asset（资产），通常可以用作基础结构元数据对象（如群集，主机等）的通用超级类型。

### DataSet
此类型扩展了Referenceable。从概念上讲，**它可以用来表示存储数据的类型。在Atlas中，hive表，
hbase_tables等都是从DataSet扩展的所有类型**。从某种意义上说，扩展DataSet的类型应该具有Schema，因
为它们将具有定义该数据集属性的属性。例如，hive_table中的columns属性。扩展DataSet的类型的实体也参
与数据转换，Atlas可以通过血缘（或出处）图捕获此转换。

### Process（过程）
此类型扩展Asset（资产）。从概念上讲，它可以用来表示任何数据转换操作。例如，将带有原始数据的hive表转
换为存储某些聚合的另一个hive表的ETL流程可以是扩展Process（过程） 类型的特定类型。Process 类型具有两
个特定的属性，输入和输出。输入和输出都是DataSet实体的数组。因此，Process类型的实例可以使用这些输入
和输出来捕获DataSet血缘的演变方式。在