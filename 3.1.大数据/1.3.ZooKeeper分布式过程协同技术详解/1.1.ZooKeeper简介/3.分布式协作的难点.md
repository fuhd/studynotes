分布式协作的难点
================================================================================
**当开发分布式应用时，其复杂性会立即突显出来**。例如，当我们的应用启动后，所有不同的进程通过某种
方法，需要知道 **应用的配置信息**，一段时间以后，配置信息也许发生了变化，我们可以停止所有进程，
重新分发配置信息的文件，然后重新启动，但是重新配置就个延长应用的停机时间。

与配置信息问题相关的是 **组成员关系的问题**，当负载变化时，我们希望增加或减少新机器和进程。

当你自己实现分布式应用时，这个问题仅仅被描述为功能性问题，你可以设计解决方案，部署前你测试了你的
解决方案，并非常确定地认为你已经正确解决了问题。**当你在开发分布式应用时，你就会遇到真正困难的问
题，你就不得不面对故障，如崩溃、通信故障等各种情况。这些问题会在任何可能的点突然出现，甚至无法列
举需要处理的所有的情况**。

在独立主机上运行的应用与分布式应用发生的故障存在显著的区别：**在分布式应用中，可能会发生局部故障**，
当独立主机崩溃，这个主机上运行的所有进程都会失败，如果是独立主机上运行多个进程，一个进程执行的失
败，其他进程可以通过操作系统获得这个故障，操作系统提供了健壮的多进程消息通信的保障。在分布式环境
中这一切发生了改变：**如果一个主机或进程发生故障，其他主机继续运行，并会接管发生故障的进程，为了
能够处理故障进程，这些仍在运行的进程必须能够检测到这个故障，无论是消息丢失或发了时间偏移**。

理想的情况下，我们基于异步通信的假设来设计系统，即我们使用的主机有可能发生时间偏移或通信故障。我
们做出这个假设是因为这一切的确会发生，时间偏移时常会发生，我们偶尔就会遇到网络问题，甚至更不幸的，
发生故障。我们可以做什么样的限制呢？

我们来看一个最简单的情况。**假设我们有一个分布式的配置信息发生了改变，这个配置信息简单到仅仅只有
一个比特位（bit），一旦所有运行中的进程对配置位的值达成一致，我们应用中的进程就可以启动**。

这个例子原本是一个在分布式计算领域非常著名的定律，被称为 **FLP**（由其作者命名：Fischer, Lynch,
Patterson），**这个结论证明了在异步通信的分布式系统中，进程崩溃，所有进程可能无法在这个比特位的
配置上达成一致**。类似的定律称为 **CAP**，表示一致性（`Comsistency`）、可用性（`Availability`）
和分区容错性（`Partition-tolerance`），该定律指出，当设计一个分布式系统时，








