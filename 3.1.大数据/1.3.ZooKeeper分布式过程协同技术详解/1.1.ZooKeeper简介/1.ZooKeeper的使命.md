ZooKeeper的使命
================================================================================
多个独立的程序协同工作是一件非常困难的事情。开发这样的应用，很容易让很多开发人员陷入如何使多个程序
协同工作的逻辑中，最后导致没有时间更好地思考和实现他们自己的应用程序逻辑。

**`ZooKeeper`从文件系统`API`得到启发**，提供一组简单的`API`，使得开发人员可以实现 **通用的协
作任务**，包括 **选举主节点、管理组内成员关系、管理元数据** 等。`ZooKeeper`包括一个 **应用开发库**
（主要提供`Java`和`C`两种语言的`API`）和一个用 **`Java`实现的服务组件。`ZooKeeper`的服务组件
运行在一组专用服务器之上，保证了高容错性和可扩展性**。

**当你决定使用`ZooKeeper`来设计应用时，最好将应用数据和协同数据独立开**。

关于 **`ZooKeeper`这样的系统功能** 的讨论都围绕着一条主线：**它可以在分布式系统中协作多个任务。
一个协作任务是指一个包含多个进程的任务。这个任务可以是为了协作或者是为了管理竟争。协作意味着多个进
程需要一同处理某些事情，一些进程采取某些行动使得其他进程可以继续工作**。比如，**在典型的主-从
（`master-worker`）工作模式中**，从节点处于空闲状态时会通知主节点可以接受工作，于是主节点就会分
配任务给从节点。**竟争则不同，它指的是两个进程不能同时处理工作的情况**，一个进程必须等待另一个进程。
同样在主-从工作模式的例子中，我们想有一个主节点，但是很多进程也许都想成为主节点，因此我们需要实现
 **互斥排他锁（`mutual exclustion`）**。实际上，我们可以认为获取主节点身份的过程其实就是获取锁
 的过程，获得主节点控制权锁的进程即主节点进程。

**协同并不总是采取像群首选举或者加锁等同步原语的形式。配置元数据也是一个进程通知其他进程需要做什么
的一种常用方式**。比如，在一个主-从系统中，从节点需要知道任务已经分配到它们。即使在主节点发生崩溃的
情况下，这些信息也需要有效。

让我们看一些`ZooKeeper`的使用实例，以便更直观地理解其用处：
+ **`Apache HBase`**：`HBase`是一个通常与`Hadoop`一起使用的数据存储仓库。**在`HBase`中，
`ZooKeeper`用于选举一个集群内的主节点，以便跟踪可用的服务器，并保存集群的元数据**。
+ **`Apache Kafka`**：`Kafka`是一个基于发布-订阅（`pub-sub`）模型的消息系统。**其中`ZooKeeper`
用于检测崩溃，实现主题（`topic`）的发现，并保持主题的生产和消费状态**。
+ **`Apache Solr`**： `Solr`是一个企业级的搜索平台。`Solr`的分布式版本命名为`SolrCloud`，
**它使用`ZooKeeper`来存储集群的元数据，并协作更新这些元数据**。

当开发人员使用`ZooKeeper`进行开发时，开发人员设计的那些应用往往可以看成一组 **连接到`ZooKeeper`
服务器端的客户端**，它们通过`ZooKeeper`的客户端`API`连接到`ZooKeeper`服务器端进行相应的操作。
**`ZooKeeper`的客户端`API`功能强大**，其中包括：
+ **保障强一致性，有序性和持久性**。
+ **实现通用的同步原语的能力**。
+ **在实际分布式系统中，并发往往导致不正确的行为。`ZooKeeper`提供了一种简单的并发处理机制**。
```
注：ZooKeeper由雅虎研究院开发。
```

### ZooKeeper改变了什么
`ZooKeeper`之前的其他一些系统采用分布式锁管理器或者分布式数据库来实现协作。实际上，`ZooKeeper`
也从这些系统中借鉴了很多概念。但是，**`ZooKeeper`的设计更专注于任务协作，并不提供任何锁的接口或
通用存储数据接口**。同时，`ZooKeeper`没有给开发人员强加任何特殊的同步原语，使用起来非常灵活。

虽然我们也可以不使用`ZooKeeper`来构建分布式系统，但是 **使用`ZooKeeper`可以让开发人员更专注于
其应用本身的逻辑而不是神秘的分布式概念**。

### ZooKeeper不适用的场景
**`ZooKeeper`不适合用作海量数据存储**。对于需要存储海量的应用数据的情况，我们有很多备选方案，
比如说数据库和分布式文件系统等。因为不同的应用有不同的需求，如对一致性和持久性的不同需求，所以在设
计应用时，**最佳实践还是应该将应用数据和协同数据独立开**。

### 通过ZooKeeper构建分布式系统
对于本书的目的，我们对分布式系统的定义为：分布式系统是同时跨越多个物理主机，独立运行的多个软件组件
所组成的系统。

软件组件以操作系统的 **进程方式** 运行，很多时候还涉及多线程的执行。因此 **`ZooKeeper`的服务端
和客户端也是以进程的方式运行**。

**分布式系统中的进程通信有两种选择：直接通过网络进行信息交换，或读写某些共享存储。`ZooKeeper`使用
共享存储模型来实现应用间的协作和同步原语**。

在真实的系统中，我们需要特别注意以下问题：
+ **消息延迟**：消息传输可能会发生任意延迟，比如，因为网络拥堵。这种任意延迟可能会导致不可预期的
后果，比如，根据基准时钟，进程`P`先发送了一个消息，之后另一个进程`Q`发送了消息，但是进程`Q`的消
息也许会先完成传送。
+ **处理器性能**：操作系统的调度和超载也可能导致消息处理的任意延迟。当一个进程向另一个进程发送消息
时，整个消息的延时时间约等于发送端消耗的时间、传输时间、接收端的处理时间的总和。如果发送或接收过程
需要调度时间进行处理，消息延时会更高。
+ **时钟偏移**：使用时间概念的系统并不少见，比如，确定某一时间系统中发生了哪些事件。处理器时钟并不
可靠，它们之间也会发生任意的偏移。因此，依赖处理器时钟也许会导致错误的决策。

关于这些问题的一个重要结果是，在实际情况中，我们很难判断一个进程是崩溃了还是某些因素导致了延时。
没有收到一个进程发送的消息，可能是该进程已经崩溃，或是最新消息发生了网络延迟，或是其他情况导致进程
延迟，或者是进程时钟发生了偏移。我们无法确定一个被称为异步（`asynchronous`）的系统中的这些区别。

`ZooKeeper`的精确设计简化了这些问题的处理，**`ZooKeeper`并不是完全消除这些问题，而是将这些问题
在应用服务层面上完全透明化，使得这些问题更容易处理**。`ZooKeeper`实现了重要的分布式计算问题的解决
方案，直观为开发人员提供某种程度上实现的封装。
