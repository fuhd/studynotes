ZooKeeper基础
================================================================================
**很多用于协作的原语常常在很多应用之间共享**。因此，设计一个用于协作需求的服务的方法往往是提供原
语列表。暴露出每个原语的实例化调用方法，并直接控制这些实例。**比如，我们可以说分布式锁机制组成一
个重要的原语**，同时暴露出创建（`create`）、获取（`acquire`）和释放（`release`）三个调用方法。

**这种设计存在一些重大的缺陷**：首先，我们要么预先提出一份详尽的原语列表，要么提供API的扩展，以
便引入新的原语；其次，以这种方式实现原语的服务使得应用丧失了灵活性。

因此，**在ZooKeeper中我们另辟蹊径。ZooKeeper并不直接暴露原语，取而代之，它暴露了由一小部分调
用方法组成的类似文件系统的API，以便允许应用实现自己的原语**。我们通常使用菜谱（`recipes`）来表
示这些原语的实现。**菜谱包括ZooKeeper操作和维护一个小型的数据节点，这些节点被称为`znode`，采用
类似于文件系统的层级树状结构进行管理**。下图描述了一个 **znode树的结构**，根节点包含4个子节点，
其中三个子节点拥有下一级节点，叶子节点存储了数据信息。

![zookeeper数据树结构示例](img/1.jpeg)

**针对一个znode，没有数据常常表达了重要的信息**。比如，**在 *主－从* 模式的例子中，主节点的znode
没有数据，表示当前还没有选举出主节点**。而图中涉及的一些其他znode节点在 *主－从* 模式的配置中非
常有用：
+ **`/workers`节点作为父节点，其下每个znode子节点保存了系统中一个可用从节点信息**。如上图所示，
有一个从节点（`foot.com:2181`）。
+ **`/tasks`节点作为父节点，其下每个znode子节点保存了所有已经创建并等待从节点执行的任务的信息**，
*主－从* 模式的应用的客户端在`/tasks`下添加一个znode子节点，用来表示一个新任务，并等待任务状态
的znode节点。
+ **`/assign`节点作为父节点，其下每个znode子节点保存了分配到某个从节点的一个任务信息**，当主
节点为某个从节点分配了一个任务，就会在`/assign`下增加一个子节点。

## 1.API概述
znode节点可能含有数据，也可能没有。**如果一个znode节点包含任何数据，那么数据存储为字组数组。字
节数据的具体格式特定于每个应用的实现，ZooKeeper并不直接提供解析的支持**。我们可以使用如 **Protocol 
Buffers、Thrift、Avro或MessagePack等序列化包** 来方便地处理保存于znode节点的数据格式，**不
过有些时候，以UTF8或ASCII编码的字符串已经够用了**。

ZooKeeper的API暴露了以下方法：
+ **create /path data**：创建一个名为`/path`的znode节点，并包含数据data。
+ **delete /path**：删除名为`/path`的znode。
+ **exists /path**：检查是否存在名为`/path`的节点。
+ **setData /path data**：设置名为`/path`的znode的数据为data。
+ **getData /path**：返回名为`/path`节点的数据信息。
+ **getChildren /path**：返回所有`/path`节点的所有子节点列表。

需要注意的是，**ZooKeeper并不允许局部写入或读取znode节点的数据。当设置一个znode节点的数据或读
取时，znode节点的内容会被整个替换或全部读取进来**。

ZooKeeper客户端连接到ZooKeeper服务，通过API调用来建立会话（`session`）。

## 2.znode的不同类型
**当新建znode时，还需要指定该节点的类型（`mode`），不同的类型决定了znode节点的行为方式**。

### 2.1.持久节点和临时节点
**znode节点可以是持久节点，还可以是临时节点。持久的znode，如`/path`，只能通过调用delete来进
行删除。临时节点与之相反，当创建该节点的客户端崩溃或关闭了与ZooKeeper的连接时，这个节点就会被删
除**。

**持久znode是一种非常有用的znode，可以通过持久类型的znode为应用保存一些数据**，即使znode的创
建者不再属于应用系统时，数据也可以保存下来而不丢失。例如，在 *主－从* 模式例子中，需要保存从节点
的任务分配情况，即使分配任务的主节点已经崩溃了。

**临时znode传达了应用某些方面的信息，仅当创建者的会话有效时这些信息必须有效保存**。例如，在主从
模式的例子中，当主节点创建的znode为临时节点时，该节点的存在意味着现在有一个主节点，且主节点状态
处于正常运行中。如果主znode消失后，该znode节点仍然存在，那么系统将无法监测到主节点崩溃。这样就
可以阻止系统继续进行，因此这个znode需要和主节点一起消失。我们也在从节点中使用临时的znode，如果
一个从节点失效，那么会话将会过期，之后znode `/workers`也将自动消失。

一个临时znode，在以下两种情况下将会被删除：
1. **当创建该znode的客户端的会话因超时或主动关闭而中止时**。
2. **当某个客户端（不一定是创建者）主动删除该节点时**。

**因为临时的znode在其创建者的会话过期时被删除，所以我们现在不允许临时节点拥有子节点**。在社区讨
论中，**已经讨论过关于允许临时znode拥有子节点的问题，其想法是使其子节点也均为临时节点**。这个功
能也许会出现在未来的发布版本中，但现在还是不可用的。

### 2.2.有序节点
**一个znode还可以设置为有序节点。一个有序znode节点被分配唯一一个单调递增的整数。当创建有序节点
时，一个序号会被追加到路径之后**。例如，如果一个客户端创建了一个有序znode节点，其路径为`/tasks/task-`，
那么ZooKeeper将会分配一个序号，如1，并将这个数字追加到路径之后，最后该znode节点为`/tasks/task-1`。
有序znode通过提供了创建具有唯一名称的znode的简单方式。同时也通过这种方式可以直观地查看znode的
创建顺序。

总之，**znode一共有4种类型：持久的（`persistent`）、临时的（`ephemeral`）、持久有序的（
`persistent_sequential`）和临时有序的（`ephemeral_sequential`）**。

## 3.监视与通知



























