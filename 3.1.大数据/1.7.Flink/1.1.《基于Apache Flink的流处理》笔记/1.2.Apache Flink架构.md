Apache Flink架构
================================================================================
## 1.系统架构 
Flink并没有依靠自身实现所有功能，而是在已有集群基础设施和服务之上专注于它的核心功能——**分布式数
据流处理。Flink和很多集群管理器（如：`Apache Mesos`、`YARN`及`Kubernetes`）都能很好地集成**；
同时它也可以通过配置，作为独立集群来运行。**Flink没有提供分布式持久化存储，而是利用了现有的分布
式文件系统（如`HDFS`）** 或对象存储 （如`S3`）。**它依赖`Apache ZooKeeper`来完成高可用性设
置中的领导选举工作**。

### 1.1.搭建Flink所需组件
Flink的搭建需要 **四个不同组件**，它们相互协作，共同执行流式应用。这些组件是，**JobManager、
ResourceManager、TaskManager和Dispatcher**。
+ **作为主进程（`master process`），JobManager控制着单个应用程序的执行。换句话说，每个应用
都由一个不同的JobManager掌控。JobManager可以接收需要执行的应用，该应用会包含一个所谓的JobGraph，
即逻辑Dataflow图，以及一个打包了全部所需类、库以及其他资源的JAR文件**。JobManager将JobGraph
转化成名为ExecutionGraph的物理Dataflow图。该图包含了那些可以并行执行的任务。JobManager从
ResourceManager申请执行任务的必要资源（**TaskManager处理槽**）。一旦它收到了足够数量的
TaskManager处理槽（`slot`），就会将ExecutionGraph中的任务分发给TaskManager来执行。在执行
过程中，JobManager还要负责所有需要集中协调的操作，如创建检查点。
+ **针对不同的环境和资源提供者（`resource provider`）（如YARN、Mesos、Kubernetes或独立部
署），Flink提供了不同的ResourceManager。ResourceManager负责管理Flink的计算资源单元——
TaskManager处理槽**。当JobManager申请TaskManager处理槽时，ResourceManager会指示一个拥有
空闲处理槽的TaskManager将其处理槽提供给JobManager。如果ResourceManager的处理槽数无法满足
JobManager的请求，则ResourceManager可以和资源提供者通信，让它们提供额外容器来启动更多
TaskManager进程。同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。
+ **TaskManager是Flink的工作进程（`worker process`）。通常在Flink搭建过程中要启动多个
TaskManager。每个TaskManager提供一定数量的处理槽。处理槽的数目限制了一个TaskManager可执行的
任务数。TaskManager在启动后，会向ResourceManager注册它的处理槽**。当接收到ResourceManager
的指示时，TaskManager会向JobManager提供一个或多个处理槽。之后，JobManager就可以向处理槽中分
配任务来执行。在执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。
+ **Dispatcher会跨多个作业运行，它提供了一个REST接口来让我们提交需要执行的应用。一旦某个应用提
交执行，Dispatcher会启动一个JobManager并将应用转交给它**。REST接口意味着Dispatcher这一集群
的HTTP入口可以受到防火墙的保护。Dispatcher同时还会启动一个Web UI，用来提供有关作业执行的信息。

下图展示了应用提交执行过程中Flink各组件之间的交互过程：

![应用提交及组件交互](img/19.png)

### 1.2.应用部署
Flink应用可以通过 **两种模式** 进行部署。

#### 框架模式
在该模式下，**Flink应用会打包成一个JAR文件，通过客户端提交到运行的服务上**。这里的服务可以是
Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。无论哪种情况，运行的服务都
会接收Flink应用并确保其执行。如果应用提交到JobManager，会立即开始执行；如果应用提交到Dispatcher
或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责执
行该应用。

#### 库模式 
在该模式下，**Flink应用会绑定到一个特定应用的容器镜像（如Docker镜像）中。镜像中还包含着运行
JobManager以及ResourceManager的代码。当容器从镜像启动后会自动加载ResourceManager和
JobManager，并将绑定的作业提交执行。另一个和作业无关的镜像负责部署TaskManager容器**。容器通过
镜像启动后会自动运行的TaskManager，后者可以连接ResourceManager并注册处理槽。通常情况下，外部
资源管理框架（如 **Kubernates**）负责启动镜像，并确保在发生故障时容器能够重启。

**基于框架的模式采用的是传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；而在库模式中，
Flink不是作为服务，而是以库的形式绑定到应用所在的容器镜像中**。后者常用于微服务架构。

### 1.3.任务执行
**一个TaskManager允许同时执行多个任务。这些任务可以属于同一个算子（数据并行），也可以是不同算
子（任务并行），甚至还可以来自不同的应用（作业并行）**。下图展示了TaskManager、处理槽 、任务以
及算子之间的关系：

![算子、任务以及处理槽](img/20.png)

左侧的JobGraph（应用的非并行化表示）包含了5个算子，其中算子A和C是数据源，算子E是数据汇。算子C
和E的并行度为2，其余算子的并行度为4。由于算子最大并行度是4，因此应用若要执行则至少需要4个处理槽。
如果每个TaskManager内有两个处理槽，则运行两个TaskManager即可满足该需求。JobManager将
JobGraph“展开成”ExecutionGraph并把任务分配到4个空闲处理槽。对于并行度为4的算子，其任务会每个
处理槽分配一个。其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中。将任务以切片
的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须 
访问网络。

**TaskManager会在同一个JVM进程内以多线程的方式执行任务**。和独立进程相比，线程更加轻量并且通
信开销更低，**但无法严格地将任务彼此隔离**。因此只要有一个任务运行异常，就有可能“杀死”整个
TaskManager进程，导致它上面运行的所有任务都停止。**如果将每个TaskManager配置成只有一个处理槽，
则可以限制应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务**。通过在
TaskManager内部采用线程并行以及在每个主机上部署多个TaskManager进程，**Flink为部署应用时性能
和资源隔离的取舍提供了极大的自由度**。

## 2.Flink中的数据传输









## 3.事件时间处理










## 4.状态管理 











## 5.检查点、保存点及状态恢复 


