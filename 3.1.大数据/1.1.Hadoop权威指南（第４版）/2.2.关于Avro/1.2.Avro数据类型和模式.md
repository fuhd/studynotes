Avro数据类型和模式
================================================================================
**Avro定义了少量的基本数据类型**，通过编写模式的方式，它们可被用于构建应用特定的数据结构。考虑
到互操作性，实现必须支持所有的Avro类型。

| 类型 | 描述 | 模式示例 |
|:-----|:----|:--------|
| null | 空值 | "null" |
| boolean | 二进制值 | "boolean" |
| int | 32位带符号整数 | "int" |
| long | 64位带符号整数 | "long" |
| float | 单精度（32位)IEEE 754浮点数 | "float" |
| double | 双精度（64位）IEEE 754浮点数 | "double" |
| bytes | 8位无符号字节序列 | "bytes" |
| string | Unicode字符序列 | "string" |

上表列举了Avro的基本类型。每个基本类型也可以使用 **type属性** 来指定，其结果是形式更加冗长，示
例如下：
```json
{"type": "null"}
```
每个Avro语言的API都包含该语言特定的Avro类型表示。例如，Avro的double类型可以用C、C++和Java语
言的double类型，Python的float类型以及Ruby的Float类型来表示。

下表列举了Avro的复杂类型，并为每种类型给出相应的模式示例：

| 类型 | 描述 | 模式示例 |
|:-----|:----|:--------|
| array | 一个排过序的对象集合。特定数组中的所有对象必须模式相同 | {"type": "array", "items": "long"} |
| map | 未排过序的键/值对。键必须是字符串，值可以是任何一种类型，但一个特定map中所有值必须模式相同 | {"type": "map", "values": "string"} |
| record | 一个任意类型的命名字段集合 | {"type": "record", "name": "WeatherRecord", "doc": "A weather reading.", "fields": [{"name": "year", "type": "int"}, {"name": "temperature", "type": "int"}, {"name": "stationId", "type": "string"}]} |
| enum | 一个命名的值集合 | {"type": "enum", "name": "Cutlery", "doc": "An eating utensil.", "symbols": ["KNIFE","FORK", "SPOON"]} |
| fixed | 一组固定数量的8位无符号字节 | {"type": "fixed", "name": "MD5Hash", "size": 16} |
| union | 模式的并集。并集可用JSON数组表示，其中每个元素为一个模式。并集表示的数据必须与其内的某个模式相匹配 | ["null", "string", {"type": "map", "values": "string"} |

而且，一种语言可能有多种表示或映射。**所有的语言都支持动态映射，即使运行前并不知道具体模式**，也
可以使用动态映射。对此，Java称为 **通用映射**（generic mapping）。

另外，Java和C++实现 **可以自动生成代码** 来表示符合某种Avro模式的数据。如果在读/写数据之前就有
模式备份的话，代码生成（code generation）能优化数据处理，这在Java中被称为
**特殊映射（specific mapping）**。同时，为用户代码生成的类与为通用代码生成的类相比，前者提供
的API更贴近问题域。

Java还有第三类映射，即 **反映射**（`reflect mapping`，将Avro类型映射到已有的Java类型）。
**它的速度比通用映射和特殊映射都慢**，但不失为定义一个类型的方便途径，原因在于Avro能够自动推断
模式。


































dd
