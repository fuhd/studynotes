Avro数据类型和模式
================================================================================
**Avro定义了少量的基本数据类型**，通过编写模式的方式，它们可被用于构建应用特定的数据结构。考虑
到互操作性，实现必须支持所有的Avro类型。

| 类型 | 描述 | 模式示例 |
|:-----|:----|:--------|
| null | 空值 | "null" |
| boolean | 二进制值 | "boolean" |
| int | 32位带符号整数 | "int" |
| long | 64位带符号整数 | "long" |
| float | 单精度（32位)IEEE 754浮点数 | "float" |
| double | 双精度（64位）IEEE 754浮点数 | "double" |
| bytes | 8位无符号字节序列 | "bytes" |
| string | Unicode字符序列 | "string" |

上表列举了Avro的基本类型。每个基本类型也可以使用 **type属性** 来指定，其结果是形式更加冗长，示
例如下：
```json
{"type": "null"}
```
每个Avro语言的API都包含该语言特定的Avro类型表示。例如，Avro的double类型可以用C、C++和Java语
言的double类型，Python的float类型以及Ruby的Float类型来表示。

下表列举了Avro的复杂类型，并为每种类型给出相应的模式示例：

| 类型 | 描述 | 模式示例 |
|:-----|:----|:--------|
| array | 一个排过序的对象集合。特定数组中的所有对象必须模式相同 | {"type": "array", "items": "long"} |
| map | 未排过序的键/值对。键必须是字符串，值可以是任何一种类型，但一个特定map中所有值必须模式相同 | {"type": "map", "values": "string"} |
| record | 一个任意类型的命名字段集合 | {"type": "record", "name": "WeatherRecord", "doc": "A weather reading.", "fields": [{"name": "year", "type": "int"}, {"name": "temperature", "type": "int"}, {"name": "stationId", "type": "string"}]} |
| enum | 一个命名的值集合 | {"type": "enum", "name": "Cutlery", "doc": "An eating utensil.", "symbols": ["KNIFE","FORK", "SPOON"]} |
| fixed | 一组固定数量的8位无符号字节 | {"type": "fixed", "name": "MD5Hash", "size": 16} |
| union | 模式的并集。并集可用JSON数组表示，其中每个元素为一个模式。并集表示的数据必须与其内的某个模式相匹配 | ["null", "string", {"type": "map", "values": "string"} |

而且，一种语言可能有多种表示或映射。**所有的语言都支持动态映射，即使运行前并不知道具体模式**，也
可以使用动态映射。对此，Java称为 **通用映射**（generic mapping）。

另外，Java和C++实现 **可以自动生成代码** 来表示符合某种Avro模式的数据。如果在读/写数据之前就有
模式备份的话，代码生成（code generation）能优化数据处理，这在Java中被称为
**特殊映射（specific mapping）**。同时，为用户代码生成的类与为通用代码生成的类相比，前者提供
的API更贴近问题域。

Java还有第三类映射，即 **反映射**（`reflect mapping`，将Avro类型映射到已有的Java类型）。
**它的速度比通用映射和特殊映射都慢**，但不失为定义一个类型的方便途径，原因在于Avro能够自动推断
模式。

下表列举了 **Java的类型映射**。如表中所示，**除非有特别说明，否则特殊映射和通用映射相同**，类
似地，**除非有特别说明，否则自反映射与特殊映射相同**。特殊映射与通用映射仅有record、enum和fixed
三个类型上有区别，它们的特殊映射都有自动生成的类，类名由name属性和可选的namespace属性决定。

| Avro类型 | Java通用映射 | Java特殊映射 | Java自反映射 |
| :------------- | :------------- | :------------- | :------------ |
| null | null类型 |  |  |
| boolean | boolean |  |  |
| int | int |  | short 或 int |
| long | long |  |  |
| float | float |  |  |
| double | double |  |  |
| bytes | java.nio.bytebuffer |  | 字组数组 |
| string | org.apache.avro.util.utf8 |  | java.lang.String |
| array | org.apache.avro.generic.GenericArray |  | 数组或java.util.Collection |
| map | java.util.map |  |  |
| record | org.apache.avro.generic.genericrecord | 生成实现org.apache.avro.specific.SpecificRecord类的实现 | 具有零参数构造函数的任意用户类。继承了所有不传递的实例字段 |
| enum | java.lang.string | 生成Java enum类型 | 任意Java enum类型 |
| fixed | org.apache.avro.generic.genericfixed | 生成实现org.apache.avro.specific.SpecificFixed的类 | org.apache.avro.generic.genericFixed |
| union | java.lang.Object |  |  |

```
说明：

Avro string类型既可以通过Java String类型来表示，也可以通过Avro Utf8 Java类型来表示。选择使用Utf8的原因在于其高效率：
因为Avro Utf8类型是易变的，单个Utf8实例可以重用，并可对一系列值进行读/写操作。另外，Java String在新建对象时就要进行
Utf8解码，而Avro执行Utf8解码较晚一些，在某些情况下，这样做可以提高系统性能。

Utf8实现了Java的java.lang.CharSequence接口，该接口可以与Java类库实现互操作。在其他情况下可能需要通过调用toString()
方法将Utf8实例转化成String对象。

在通用映射和特殊映射中，Utf8都是默认的，但是对于特定的映射也可以使用String。有两个方法可以达到该目的。第一个方法是将模
式中的avro.java.string属性设置成String：
{"type": "string", "avro.java.string": "String"}
另外一个方法是，对于一些特定的映射操作，你可以构建基于String的get()和set()方法的类。如果使用Avro Maven插件，该功能
可以通过将stringType属性设置成String来实现（在12.2.1节中有一个相关的例子）

最后，请注意，Java自反映射始终使用Java的String对象，其主要原因是Java的兼容性，而非性能。
```
