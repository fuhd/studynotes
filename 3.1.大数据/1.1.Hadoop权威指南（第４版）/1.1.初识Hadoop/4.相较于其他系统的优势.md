相较于其他系统的优势
==============================================================================
 ### 关系型数据库管理系统
 **为什么不能用配有大量硬盘的数据库来进行大规模数据分析？我们为什么需要`Hadoop`？**

 这两个问题的答案来自于计算机硬盘的另一个发展趋势：**寻址时间的提升远远不敌于传输速率的提升。寻址是将磁头
 移动到特定硬盘位置进行读/写操作的过程。它是导致硬盘操作延迟的主要原因，而传输速率取决于硬盘的带宽**。

 如果数据访问模式中包含大量的硬盘寻址，那么读取大量数据集就必然会花更长的时间（相较于流数据读取模式，
 流读取主要取决于传输速率）。另一方面，如果数据库系统只更新一小部分记录，那么传统的`B`树（关系型数据库中
 使用的一种数据结构，受限于寻址的速率）就更有优势。**但数据库系统如果有大量数据更新时，`B`树的效率就明显落
 后于`MapReduce`，因为需要使用“排序/合并”（`sort/merge`）来重建数据库**。

 在许多情况下，可以将`MapReduce`视为关系型数据库管理系统的补充。两个系统之间的差异如下表：

 | | 传统的关系型数据库 | MapReduce |
 |:--|:--------------|:----------|
 | 数据大小 | GB | PB |
 | 数据存取 | 交互式和批处理 | 批处理 |
 | 更新 | 多次读/写 | 一次写入，多次读取 |
 | 事务 | ACID | 无 |
 | 结构 | 写时模式 | 读时模式 |
 | 完整性 | 高 | 低 |
 | 横向扩展 | 非线性的 | 线性的 |

 **`MapReduce`比较适合解决需要以批处理方式分析整个数据集的问题**，尤其是一些特定目的的分析。**`RDBMS`适用于
 索引后数据集的点查询（`point query`）和更新**，建立索引的数据库系统能够提供对小规模数据的低延迟数据检索
 和快速更新。**`MapReduce`适合一次写入、多次读取数据的应用，关系型数据库则更适合持续更新的数据集**。

 **`Hadoop`和关系型数据库的另一个区别在于它们所操作的数据集的结构化程度。结构化数据（`structured data`）是具有
 既定格式的实体化数据**，如 **`XML`文档** 或 **满足特定预定义格式的数据库表**。这是 **`RDBMS`** 包括的内容。
 另一方面，**半结构化数据比较松散，虽然可能有格式，但经常被忽略，所以它只能作为对数据结构的一般性指导。例如电子表格，
 它在结构上是由单元格组成的网格，但是每个单元格内可以保存任何形式的数据。非结构化数据没有什么特别的内部结构，例如纯文本或图像数据**。
 **`Hadoop`对非结构化或半结构化数据非常有效**，因为它是在处理数据时才对数据进行解释（即所谓的“ **读时模式** ”）。
 这种模式在 **提供灵活性的同时避免了`RDBMS`数据加载阶段带来的高开销**，因为在`Hadoop`中仅仅是一个文件拷贝操作。

 ### 网格计算
 **高性能计算（`High Performance Computing, HPC`）和网格计算（`Grid Computing`）组织** 多年以来一直在研究大规模数据处理，
 主要使用 **类似于消息传递接口（`Message Passing Interface, MPI`）的`API`**。从广义上讲，**高性能计算采用的方法是将作业
 散到集群的各台机器上，这些机器访问存储区域网络（`SAN`）所组成的共享文件系统**。这比较适用于 **计算密集型的作业**，但如果节点
 需要访问的数据量更庞大（高达几百`GB`，`Hadoop`开始施展它的魔法），很多计算节点就会因为网络带宽的瓶颈问题而不得不闲下来等数据。

 **`Hadoop`尽量在计算节点上存储数据，以实现数据的本地快速访问。数据本地化（`data locality`）特性是`Hadoop`数据处理的核心，
 并因此而获得良好的性能**。意识到网络带宽是数据中心环境最珍贵的资源（到处复制数据很容易耗尽网络带宽）之后，`Hadoop`通过显式网络
 拓扑结构来保留网络带宽。注意，这种排列方式并没有降低`Hadoop`对计算密集型数据进行分析的能力。

 **在大规模分布式计算环境下**，协调各个进程的执行是一个很大的挑战。**最困难的是合理处理系统的部分失效问题**（在不知道一个远程进
 程是否挂了的情况下）同时还需要继续完成整个计算。**有了`MapReduce`这样的分布式处理框架，程序员不必操心系统失效的问题，因为框架
 能够检测到失败的任务并重新在正常的机器上执行**。正因为采用的是无共享（`shared-nothing`）框架，`MapReduce`才能够呈现出这种特性，
 这意味着各个任务之间是彼此独立的。
