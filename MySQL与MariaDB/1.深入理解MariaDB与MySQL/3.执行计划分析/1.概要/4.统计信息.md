统计信息
==============================================
基于代价的优化中，统计信息是最重要的依据。

### MySQL5.6的统计信息
由于MariaDB10.0包含MySQL5.6的功能，所以掌握MySQL 5.6管理统计信息的方法将有助于理解MariaDB10.0
管理统计信息的方法。MySQL5.6中，使用`InnoDB`存储引擎的数据表的统计信息可以永久（Persistent）管理。
从MySQL5.6开始在`mysql`数据库的`innodb_index_stats`数据表与`innodb_table_stats`数据表中
也可以访问索引。
```sql
SHOW TABLES LIKE '%_stats';
```
显示：
```
+---------------------------+
| Tables_in_mysql (%_stats) |
+---------------------------+
| column_stats              |
| index_stats               |
| innodb_index_stats        |
| innodb_table_stats        |
| table_stats               |
+---------------------------+
5 rows in set (0.00 sec)
```
在MySQL5.6中创建数据表时，可以设置`STATS_PERSISTENT`选项，根据其设置值确定是否以数据表为单位永久保存统计信息。
示例：
```sql
CREATE TABLE tab_test(
  fd1 INT,
  fd2 VARCHAR(20),
  PRIMARY KEY(fd1)
)ENIGNE = InnoDB STATS_PERSISTENT=1;
```
+ **STATS_PERSISTENT＝0**：采用MySQL5.5以前的方式管理数据表的统计信息，不保存于`mysql`数据库
的`innodb_index_stats`与`innodb_table_stats`数据表。
+ **STATS_PERSISTENT=1**：将数据表的统计信息保存到`mysql`数据库的`innodb_index_stats`与
`innodb_table_stats`数据表。
+ **STATS_PERSISTENT=DEFAULT**：其效果与创建数据表时不设置`STATS_PERSISTENT`选项相同，
是否永久管理数据表的统计信息由`innodb_stats_presistent`系统变量设置值决定。

**`innodb_stats_presistent`系统变量的默认值为ON(1)**，创建数据表时，若不使用`STATS_PERSISTENT`
选项，则使用永久统计信息，并将统计信息保存到`innodb_index_stats`与`innodb_table_stats`数据表。

示例，创建`tab_persistent`与`tab_transient`两个数据表时，使用`STATS_PERSISTENT`选项，
并且分别设置为1与0：
```sql
CREATE TABLE tab_persistent(fd1 INT PRIMARY KEY,fd2 INT)ENGINE=InnoDB STATS_PERSISTENT=1;
CREATE TABLE tab_transient(fd1 INT PRIMARY KEY,fd2 INT)ENGINE=InnoDB STATS_PERSISTENT=0;
```
再执行：
```sql
SELECT * FROM mysql.innodb_table_stats WHERE table_name IN ('tab_persistent','tab_transient') \G
```
显示：
```
*************************** 1. row ***************************
           database_name: firstdb
              table_name: tab_persistent
             last_update: 2016-05-27 17:59:32
                  n_rows: 0
    clustered_index_size: 1
sum_of_other_index_sizes: 0
1 row in set (0.00 sec)
```
创建数据表后，访问`mysql`数据库的`innodb_table_stats`数据表的统计信息。可以看到，只能访问
`tab_persistent`数据表（采用`STATS_PERSISTENT=1`选项创建）的统计信息。当然，也可以使用
`ALTER TABLE`命令将数据表的统计信息更改为永久状态（`STATS_PERSISTENT=1`）或短期状态（`STATS_PERSISTENT=0`）。

### MariaDB10.0的统计信息
**MariaDB10.0提供了综合统计信息管理功能，使用时不受存储引擎限制**。从MariaDB10.0开始，
不仅可以管理非索引列的统计信息，而且这些综合管理的统计信息也可以永久使用。因此，MariaDB也可以像其他RDBMS一样，
将具有较高准确度的统计信息单独备份，或者将其再次恢复使用。统计信息不准确时，管理员可以直接修改，
这样MariaDB优化器就可以用更准确的信息制定更好的执行计划。

MariaDB的综合统计信息由`table_stats`，`column_stats`，`index_stats`数据表进行管理，
这些数据表位于MariaDB服务器的默认数据库`mysql`，并且都使用 **MyISAM存储引擎**。
```sql
SHOW TABLES LIKE '%_stats';
```
显示：
```
+---------------------------+
| Tables_in_mysql (%_stats) |
+---------------------------+
| column_stats              |
| index_stats               |
| innodb_index_stats        |
| innodb_table_stats        |
| table_stats               |
+---------------------------+
5 rows in set (0.00 sec)
```

**table_stats表**：

| 数据列 | 含义 |
| :------------- | :------------- |
| db_name | 目标数据表所属的数据库名 |
| table_name | 目标数据表名 |
| cardinality | 数据表的记录数 |

**column_stats表**：

| 数据列 | 含义 |
| :------------- | :------------- |
| db_name | 目标数据表所属的数据库名 |
| table_name | 目标数据表名 |
| column_name | 目标数据列名 |
| min_value | 相应列的最小值 |
| max_value | 相应列的最大值 |
| nulls_ratio | NULL值的比率（0：无NULL，0.5：拥有NULL值的记录50%，1:所有记录为NULL）|
| avg_length | 列值的平均字节数 |
| avg_frequency | 拥有重复值的平均记录数（1：无重复值）

**index_stats表**：

| 数据列 | 含义 |
| :------------- | :------------- |
| db_name | 目标数据表所属的数据库名 |
| table_name | 目标数据表名 |
| index_name | 目标索引名 |
| prefix_arity | 索引键区号，INDEX(fd1,fd2)时，若prefix_arity=1，则对fd1列统计，若prefix_arity=2，则对(fd1,fd2)统计|
|avg_frequency | 拥有重复值平均记录数（1：无重复值）|

前面已经讲解了MySQL5.6中的两种统计信息管理方法（永久，短期），与此不同的是，MariaDB10.0引入了与
存储引擎无关的综合型统计信息，并提供了三种管理方法。事实上，MariaDB10.0的综合统计信息与MySQL5.6的
永久统计信息是同时使用的，执行查询时，系统变量 **`use_stat_tables`** 设置值决定使用哪种统计信息，其取值为：
+ **never**：采用MySQL5.6的统计信息管理方式，统计信息不会收集到`mysql`数据库的`table_stats`，
`column_stats`，`index_stats`数据表。**MariaDB10.0也将`use_stat_tables`设置为`never`**，
直接使用MySQL5.6的永久统计信息。
+ **complementary**：将系统变量`use_stat_tables`设置为`complementary`后，优先使用各存储引擎
提供的统计信息。但存储引擎未提供信息或提供的信息不足时，就会使用MariaDB的综合统计信息。若数据表使用
的是MySQL5.6的`InnoDB`存储引擎，则有关于数据表全部记录数与索引列基数信息，但非索引列的统计信息
不会得到管理。此外，若使用`MyISAM`或`MEMORY`存储引擎，则不会有任何统计信息。为了克服这一弱点，
可以使用`complementary`模式，该模式将使用MariaDB的综合统计信息。
+ **preferably**：将系统变量`use_stat_tables`设置为`preferably`后，MariaDB引擎会优先使用
MariaDB的综合统计信息，然后再使用各存储引擎管理的统计信息。若MariaDB综合统计信息不存在，则使用存储引擎
提供的统计信息制定查询执行计划。

默认值为：`never`；

将系统变量`innodb_stats_auto_recalc`设置为`ON`之后，数据表结构发生变化或有大量数据变化时，
MariaDB10.0的InnoDB存储引擎会自动收集统计信息。但此时收集的统计信息与MariaDB的综合统计信息无关，
仅用于更新InnoDB存储引擎的统计信息。
```sql
SHOW GLOBAL VARIABLES like 'innodb_stats_auto_recalc';
```
显示：
```
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_stats_auto_recalc | ON    |
+--------------------------+-------+
1 row in set (0.00 sec)
```
如果创建表并插入数据后，可以发现MariaDB的综合统计表不存在任何信息，而InnoDB的统计表中存在相应统计信息。
若将系统变量`innodb_stats_auto_recalc`设置为`OFF`，则InnoDB的统计表不会保存任何值。

由上可知，**MariaDB10.0的综合统计信息不会自动收集。若想收集，则要执行`ANALYZE TABLE`命令**。
示例：
```sql
--Shohin是我自定义的表，里面有数据
ANALYZE TABLE Shohin;
```
显示：
```
+----------------+---------+----------+----------+
| Table          | Op      | Msg_type | Msg_text |
+----------------+---------+----------+----------+
| firstdb.Shohin | analyze | status   | OK       |
+----------------+---------+----------+----------+
1 row in set (0.02 sec)
```
```sql
--查看table_stats表
SELECT * FROM mysql.table_stats WHERE table_name = 'Shohin';
SELECT * FROM mysql.innodb_table_stats WHERE table_name = 'Shohin'\G
```
由于MariaDB10.0的`ANALYZE TABLE`命令执行时会 **进行全表扫描** 与 **索引全扫描**，所以最后
收集到的数据是相当准确的。

**注意：**
> 让人遗憾的是，**MariaDB10.0.8中，只要执行ANALYZE TABLE命令就必须进行全表扫描或索引全扫描**。
> 因此，MariaDB的综合统计信息收集起来会相当消耗资源，使用时一定要小心。

> 实际应用环境中，使用MariaDB时通常会架设 **主/从** 服务器。主MariaDB服务器主要用于向外提供服务，
> 很难收集统计信息时，可以通过从服务器收集统计信息，然后复制给主MariaDB服务器。这也是一种比较好的方法。

**重要知识点：系统变量`use_stat_tables`设置为`never`状态下，在MariaDB10.0中执行`ANALYZE TABLE`命令后，
会一直收集存储引擎级别的统计信息，但不会收集MariaDB的综合统计信息。而将`use_stat_tables`设置为
`complementary`或`preferably`时，执行`ANALYZE TABLE`命令后，会同时收集存储引擎级别的统计信息
和MariaDB的综合统计信息**。

此外，MariaDB10.0对`ANALYZE TABLE`命令的语法进行了一些扩充，以更好地适应综合统计信息的收集工作。
```sql
--对tb1数据表收集统计信息，且仅针对col1,col2数据列以及idx1,idx2
ANALYZE TABLE tb1 PERSISTENT FOR COLUMNS (col1,col2) INDEXES (idx1,idx2);
--对tb1数据表收集统计信息，且仅针对col1,col2数据列
ANALYZE TABLE tb1 PERSISTENT FOR COLUMNS (col1,col2) INDEXES ();
--对tb1数据表收集统计信息，且仅针对idx1,idx2
ANALYZE TABLE tb1 PERSISTENT FOR COLUMNS () INDEXES (idx1,idx2);
--仅收集tb1数据表的统计信息
ANALYZE TABLE tb1 PERSISTENT FOR COLUMNS () INDEXES ();
--对数据表，所有列，所有索引收集统计信息，效果与ANALYZE TABLE tb1命令相同
ANALYZE TABLE tb1 PERSISTENT FOR ALL;
```
