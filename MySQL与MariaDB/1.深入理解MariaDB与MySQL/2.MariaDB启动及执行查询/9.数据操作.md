数据操作
=============================================
使用SQL语句查询或修改数据表中的内容时，一定要明确指出目标数据库名与数据表名。但每次运行SQL语句都
进行该操作十分麻烦，为了解决这一问题，MariaDB提供了`USE`命令，使用它可以选定一个数据库，
以后进行的所有操作都将只针对该数据库。
```sql
USE test;
```
下面讲解在MariaDB中进行数据操作的SQL语句。

### INSERT
使用`INSERT`语句可以将记录保存到指定数据表。执行`INSERT`语句前，必须先存在目标数据表。
下面先简单创建一个用于测试的数据表：
```sql
--使用firstdb数据库
USE firstdb;
--创建数据表
CREATE TABLE tab_test (
  fd1 INT NOT NULL,
  fd2 VARCHAR(50),
  PRIMARY KEY (fd1)
) ENGINE = InnoDB;
```
下面两个示例中，第一个`INSERT`语句将数据表的各列与值都罗列出来，而第二个`INSERT`语句中 **只给出了列值**，
并没有明确列出对应的数据列。使用第二种`INSERT`语句插入数据时，在`VALUES`之后一定要 **为数据表的所有数据
列给出要存储的值**。
```sql
--第一个
INSERT INTO tab_test (fd1,fd2) VALUES (1, 'Matt');
--第二个
INSERT INTO tab_test VALUES (2,'Toto');
```
通常，使用第二种方式向数据表插入数据时，由于没有明确列出数据表的数据列，那么数据表结构发生变化后，
执行时将极有可能引发错误。因此，**开发应用程序时，建议各位采用第一种方式**。

`INSERT`语句经常使用 **`ON DUPLICATE KEY UPDATE`选项**，启用该选项后，数据表中已经存在重复记录时，
就会执行`UPDATE`操作，否则执行`INSERT`操作：
```sql
INSERT INTO tab_test (fd1,fd2) VALUES (3,'Lee') ON DUPLICATE KEY UPDATE fd2 = 'Lee';
INSERT INTO tab_test (fd1,fd2) VALUES (3,'SeongUck') ON DUPLICATE KEY UPDATE fd2 = 'SeongUck';
```
执行第一条`INSERT`语句时，由于不存在与fd1列（主键）值重复的记录，所以`ON DUPLICATE KEY UPDATE`
之后的部分忽略，(3,‘Lee’)会保存到数据表。而执行第二条`INSERT`语句时，由于数据表中已经存在fd1=3的记录，
所以`INSERT INTO ... VALUES ...`部分忽略，将执行`UPDATE fd2='SeongUK'`，将记录(3,'Lee')更新为(3,'SeongUck')。

### SELECT
使用`SELECT`语句可以检索数据表中存储的记录。
```sql
--例1
SELECT * FROM tab_test;
--例2
SELECT * FROM tab_test WHERE fd1 = 1;
--例3
SELECT fd2 FROM tab_test;
```
若使用mysql客户端连接数据库，查询时可以使用 **“\G”选项**，按列输出数据表中的记录，如下所示。
```sql
SELECT * FROM tab_test \G
```
显示如下：
```
MariaDB [firstdb]> SELECT * FROM tab_test \G
*************************** 1. row ***************************
fd1: 1
fd2: Matt
*************************** 2. row ***************************
fd1: 2
fd2: Toto
*************************** 3. row ***************************
fd1: 3
fd2: kkkk
3 rows in set (0.00 sec)
```
**请注意，在SQL语句中使用“\G”选项时，句末不要再使用分号（;）**。

### UPDATE
`UPDATE`语句对记录的部分数据列进行修改。
```sql
UPDATE tab_test SET fd2 = 'Brandon' WHERE fd1 = 1;
```
**注意，`UPDATE`语句中不使用`WHERE`条件子句时，列值的修改将针对数据表中的所有记录**。

### REPLACE
前面讲过`INSERT INTO ... ON DUPLICATE KEY UPDATE ...`语句，从表面上看，`REPLACE`语句的处理
过程与之类似。也就是说，**指定的记录不存在时，执行`INSERT`操作，否则执行`UPDATE`操作**。
```sql
REPLACE tab_test SET fd1 = 1, fd2 = 'Matt';
```
由于tab_test数据表中存在fd1为1的记录，所以将进行UPDATE操作，仅将fd2的列值修改为“Matt”。
但是，实际执行`REPLACE`语句时，若数据表中存在主键或唯一键重复的记录，会先删除记录，然后执行`INSERT`
操作插入新记录。对用户而言，整个处理过程看上去与`UPDATE`非常相似，但实际上，`REPLACE`语句执行前的记录
与执行后的记录从内部来看是完全不同的。

**数据表中存在重复记录时，执行`REPLACE`语句会先将记录删除，然后再次执行`INSERT`操作，
所以`INSERT INTO ... ON DUPLICATE KEY UPDATE ...`语句相比，它造成的系统负荷更高，消耗的系统
资源也列多。如果可能，请各位尽量使用`INSERT INTO ... ON DUPLICATE KEY UPDATE ...`语句，
而不要使用`REPLACE`语句**。

### DELETE
