函数
==============================================
main函数示例：
```rust
fn main() {
}
```
这可能是最简单的函数声明。`fn`表示 **这是一个函数**，后跟 **函数名**，接着是小括号包括的 **参数列表**，
然后是一对大括号代表 **函数体**。那么有参数是什么样子呢？示例：
```rust
fn print_sum(x: i32, y: i32) {
  println!("sum is: {}", x + y);
}
//函数使用
fn main() {
  print_sum(5, 6);
}
```
如你所见，**函数参数** 与`let`声明非常相似：**参数名加上冒号再加上参数类型**。与`let`不同，**你必须为
函数参数声明类型**。这是一个有意为之的设计决定。即使像`haskell`这样的能够全程序推断的语言，注明类型也经常
作为一个最佳实践被建议。**我们认为即使允许在函数体中推断，也要强制函数声明参数类型。这是一个全推断与无推断的
最佳平衡**。

如果我们需要一个返回值呢？示例：
```rust
fn add_one(x: i32) -> i32 {
  x + 1
}
```
Rust函数 **只能返回一个值**，并且你需要 **在一个箭头后面声明类型**，它是一个破折号（-）后跟一个大于号（>）。
**注意：示例中，`x+1`后并没有分号，要不然后得到一个错误！！！**。这揭露了关于Rust两个有趣的地方：
**它是一个基于表达式的语言，并且分号与其它基于“大括号和分号”的语言不同！！！！**

### 表达式 VS 语句
`Rust`主要是一个 **基于表达式的语言**。**只有两种语句**，其它的一切都是表达式。然而这又有什么区别呢？
**表达式返回一个值，而语句不是**。Rust中有两种类型的语句：**“声明语句”和“表达式语句”**，其余的一切是表达式。
#### 声明语句
Rust中，使用`let`引入一个绑定并不是一个表达式。下面的示例会报错的：
```rust
//这是错误的，let y = 5不是一个表达式，也就不能用来赋值了
let x = (let y = 5);
```
编译器会告诉我们，这里它期望看到表达式的开头，**而`let`只能开始一个语句，不是表达式**。注意：**赋值一个已经
绑定过的变量（例如，`y = 5`）仍是一个表达式**，即使它的（返回）值并不是特别有用。在Rust中赋值的值是一个 **空的
元组()**：
```rust
let mut y = 5;
let x = (y = 6); //值为空的元组()，不是6
```
#### 表达式语句
它的目的是 **把任何表达式变为语句**。在实践环境中，Rust语法期望语句后跟其它语句。这意味着你用 **分号** 来分隔各个表达
式。这意味着Rust看起来很像大部分其它使用 **分号** 做为语句结尾的语言，并且你会看到 **分号** 出现在 **几乎** 每一行你看到的Rust代码。

**那么我们说“几乎”的例外是什么呢？** 你已经见过它了：
```rust
fn add_one(x: i32) -> i32 {
  x + 1 //这里没有分号
}
```
我们的函数声称它返回一个`i32`，**不过带有一个分号，它会返回一个()**。

### 提早返回（Early returns）
如果提早返回，有关键字，`return`：
```rust
fn foo(x: i32) -> i32 {
  return x;
  //下面这句代码永远不会运行
  x + 1
}
```
使用`return`作为函数的最后一行是可行的，不过被认为是一个 **糟糕** 的风格：
```rust
fn foo(x:i32) -> i32 {
  return x + 1;
}
```

### 发散函数（Diverging functions）
Rust有些特殊的语法叫 **“发散函数”**，这些函数 **并不返回**：
```rust
fn diverges() -> ! {
  panic!("This function never returns!");
}
```
`panic!()`是一个宏，类似我们已经见过的`println!()`。与`println!()`不同的是，`panic!()` **导致当前
的执行线程崩溃并返回指定的信息**。因为这个函数会崩溃，所以它不会返回，所以它拥有一个类型`!`，它代表 **“发散”**。
输出结果类似：
```
thread '<main>' panicked at 'This function never returns!',hello.rs:2
```
如果你想要更多信息，你可以设定`RUST_BACKTRACE`环境变量来获取`backtrace`：
```powershell
$ RUST_BACKTRACE=1 ./diverges
```
控制台打印：
```
thread '<main>' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - <unknown>
  13:                0x0 - <unknown>
```
`RUST_BACKTRACE`也可以用于`Cargo`的`run`命令：
```powershell
$ RUST_BACKTRACE=1 cargo run
```
控制台打印：
```
thread '<main>' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - <unknown>
  13:                0x0 - <unknown>
```
**发散函数可以被用作任何类型**：
```rust
fn diverges() -> ! {
  panic!("This function never returns!");
}
let x: i32 = diverges();
let x: String = diverges();
```

### 函数指针
我们也可以创建 **指向函数的变量绑定**：
```rust
let f: fn(i32) -> i32;
```
`f`是一个指向一个获取`i32`作为参数并返回`i32`的函数的变量绑定。例如：
```rust
fn plus_one(i: i32) -> i32 {
  i + 1
}
//没有类型推断
let f: fn(i32) -> i32 = plus_one;
//有类型推断
let f = plus_one;
```
你可以用`f`来调用这个函数：
```rust
let six = f(5);
```
