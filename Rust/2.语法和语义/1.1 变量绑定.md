变量绑定
=============================
`let`被用来声明一个 **变量绑定**，像这样：
```rust
fn main() {
  let x = 5;
}
```
### 模式（Patterns）
Rust的变量绑定有一些不同的巧妙之处。例如`let表达式`的左侧是一个“**模式**”，而不仅仅是一个变量。
这意味着我们可以这样写：
```rust
let (x, y) = (1, 2);
```
表达式被计算后，`x`将会是1，而`y`将会是2。**模式** 非常强大，后面再讲述。

### 类型注解（Type annotations）
Rust有一个叫做 **类型推断** 的功能。如果它能确认这是什么类型，Rust不需要你明确地指出来。若你愿意，
我们也可以加上类型。类型写在一个 **冒号（:）** 后面：
```rust
let x: i32 = 5;
```
例子中我们选择`x`代表一个32位的有符号整数。Rust有许多不同的原生整数类型。以 **i** 开头的代表 **有符号整数**
而 **u** 开头的代表 **无符号整数** 。可能的整数大小是8，16，32和64位。

### 可变性（Mutability）
**变量绑定默认是不可变的（immutable）**。如果你想一个绑定是 **可变** 的，使用`mut`：
```rust
let mut x = 5; //mut x: i32
x = 10;
```
### 初始化绑定（Initializing bindings）
**绑定要求在可以使用它之前必须初始化**。Rust是不会让我们使用一个没有经过初始化的值的。示例：
```rust
//这个示例是错误的！！
fn main() {
  let x: i32;
  println!("The value of x is: {}", x);
}
```
### 作用域和隐藏（Scope and shadowing）
变量绑定有一个 **作用域** ，他们被限制只能在他们 **被定义的块中存在** 。**一个块是一个被{和}包围的语句集合。
函数定义也是块！**。示例，`x`和`y`，他们位于不同的作用域中。`x`可以在`fn main() {}`块中被访问，
而`y`只能在内部块内访问：
```rust
fn main() {
  let x: i32 = 17;
  {
    let y: i32 = 3;
    println!("The value of x is {} and value of y is {}", x, y);
  }
  println!("The value of x is {} and value of y is {}", x, y); //这里是错误的！！
}
```
另外，**变量可以被隐藏**。这意味着 **一个后声明的并位于同一作用域的相同名字的变量绑定将会覆盖前一个变量绑定**：
```rust
let x: i32 = 8;
{
  println!("{}", x); //Prints "8"
  let x = 12;
  println!("{}", x); //Prints "12"
}
println!("{}", x); //Prints "8"
let x = 42;
println!("{}", x); //Prints "42"
```
**隐藏和可变绑定** 可能作为同一枚硬币的两面出现，不过他们是两个并不总是能交替使用的不同的概念。作为其中之一，
**隐藏允许我们重绑定一个值为不同的类型。它也可以改变一个绑定的可变性**：
```rust
let mut x: i32 = 1;
x = 7;
let x = x; //x现在是不可变的，并且绑定到７
let y = 4;
let y = "I can also be bound to text!"; //y现在是不同的类型
```
