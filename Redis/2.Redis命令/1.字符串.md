字符串
=====================================================
Redis的字符串就是一个由 **字节** 组成的 **序列**，它们和很多编程语言里面的字符串没有什么明显的不同。
在Redis里面，字符串可以存储以下3种类型的值：
+ **字节串**（byte string)；
+ **整数**；
+ **浮点数**；

用户可以通过给定一个任意的数值，对存储着 **整数** 或者 **浮点数** 的字符串执行 **自增** 或者 **自减** 操作，
在有需要的时候，Redis还会 **将整数转换成浮点数**。整数的取值范围和系统的长整数的取值范围相同（在32位系统上，
整数就是32位有符号整数，在64位系统上，整数就是64位有符号整数），而浮点数的取值范围和精度则与`IEEE754`标准
的 **双精度浮点数**（double）相同。

### Redis中的自增命令和自减命令
| 命令 | 用例和描述 |
| :---- | :---- |
| **INCR** | **INCR key-name** --- 将键存储的值加上`1` |
| **DECR** | **DECR key-name** --- 将键存储的值减去`1` |
| **INCRBY** | **INCRBY key-name amount** --- 将键存储的值加上整数`amount` |
| **DECRBY** | **DECRBY key-name amount** --- 将键存储的值减去整数`amount` |
| **INCRBYFLOAT** | **INCRBYFLOAT key-name amount** --- 将键存储的值加上浮点数`amount`，这个命令在Redis2.6或以上的版本可用 |

当用户将一个值存储到Redis字符串里面的时候，如果这个值可以 **被解释（`interpret`）为十进制整数或者浮点数**，
那么Redis会察觉到这一点，并允许用户对这个字符串执行各种 **`INCR＊`和`DECR＊`** 操作。

如果用户对一个 **不存在的键** 或者一个保存了 **空串** 的键执行 **自增** 或者 **自减** 操作，
那么Redis在执行操作时会将这个键的值当作 **0** 来处理。

如果用户尝试对一个值 **无法被解释为整数或者浮点数的字符串键** 执行 **自增** 或者 **自减** 操作，那么Redis将向用户 **返回一个错误**。

### 处理子串和二进制位的命令
| 命令 | 用例和描述 |
| :---- | :---- |
| **APPEND** | **APPEND key-name value** --- 将值`value`追加到给定键`key-name`当前存储的值的末尾 |
| **GETRANGE** | **GETRANGE key-name start end** --- 获取一个由偏移量`start`至偏移量`end`范围内所有字符组成的子串，**包括`start`和`end`在内** |
| **SETRANGE** | **SETRANGE key-name offset value** --- 将从`offset`偏移量开始的子串设置为给定值 |
| **GETBIT** | **GETBIT key-name offset** --- 将字节串看作是二进制位串，并返回位串中偏移量为`offset`的二进制位的值 |
| **SETBIT** | **SETBIT key-name offset value** --- 将字节串看作是二进制位串，并将位串中偏移量为`offset`的二进制位的值设置为`value` |
| **BITCOUNT** | **BITCOUNT key-name [start end]** --- 统计二进制位串里面值为`1`的二进制位的数量，如果给定了可选的`start`偏移量和`end`偏移量，那么只对偏移量指定范围内的二进制位进行统计 |
| **BITOP** | **BITOP operation dest-key key-name [key-name ...]** --- 对一个或多个二进制位串执行包括并（**AND**）、或（**OR**）、异或（**XOR**）、非（**NOT**）在内的任意一种按位运算操作，并将计算得出的结果保存在`dest-key`键里面 |
