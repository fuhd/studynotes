登录和Cookie缓存
================================================
每当我们登录互联网服务的时候，这些服务都会使用`cookie`来记录我们的身份。`cookie`由少量数据组成，
网站会要求我们的浏览器存储这些数据，并在每次发送请求时将这些数据传回给服务。对于用来登录的`cookie`，
有两种常见了的方法可以将登录信息存储在`cookie`里面：一种是签名（signed）cookie，另一种是令牌（token）cookie.

**签名cookie** 通常会存储用户名，可能还有用户ID，用户最后一次成功登录的时间，以及网站觉得有用的其他任何信息。
除了用户的相关信息之外，签名cookie还包含一个签名，服务器可以使用这个签名来验证浏览器发送的信息是否未经改动。

**令牌cookie** 会在cookie里面存储一串随机字节作为令牌，服务器可以根据令牌在数据库中查找令牌的拥有者。
随着时间的推移，旧令牌会被新令牌取代。

| cookie | 优点 | 缺点 |
| :----- | :-- | :----|
| 签名cookie | 验证cookie所需的一切信息都存储在cookie里面。cookie可以包含额外的信息，并且对这些信息进行签名也很容易 | 正确地处理签名很难。很容易忘记对数据进行签名，或者忘记验证数据的签名，从而造成安全漏洞 |
| 令牌cookie | 添加信息非常容易。cookie的体积非常小，因此移动终端和速度较慢的客户端可以更快地发送请求 | 需要在服务器中存储更多信息。如果使用的是关系数据库，那么载入和存储cookie的代价可能会很高 |

这里，我们选择使用令牌cookie来引用关系数据库表中负责存储用户登录信息的条目。除了用户登录信息之外，
`Fake Web Retailer`还可以将用户的访问时长和已浏览商品的数量等信息存储到数据库里面，
这样便于将来通过分析这些信息来学习如何更好地向用户推销商品。

一般来说，用户在决定购买某个或某些商品之前，通常都会先浏览多个不同的商品，而记录用户浏览过的所有商品
以及用户最后一次访问页面的时间等信息，通常会导致大量的数据库写入。从长远来看，用户的这些浏览数据的确
非常有用，但问题在于，即使经过优化，大多数关系数据库在每台数据库服务器上面每秒也只能插入，更新或删除
**200~2000** 个数据库行。尽管批量插入，批量更新和批量删除等操作可以以更快的速度执行，但因为客户端
每次浏览网页都只更新少数几个行，所以高速的批量插入在这里并不适用。

因为`Fake Web Retailer`目前一天的负载量相对比较大————平均情况下每秒大约1200次写入，高峰时期每秒
接近6000次写入，所以它必须部署10台关系数据库服务器才能应对高峰时期的负载量。

**而我们要做的就是使用Redis重新实现登录cookie功能，取代目前由关系数据库实现的登录cookie功能**。

首先，我们将使用一个散列来存储登录cookie令牌与已登录用户之间的映射。要检查一个用户是否已经登录，
需要根据给定的令牌来查找与之对应的用户，并在用户已经登录的情况下，返回该用户的ID。
