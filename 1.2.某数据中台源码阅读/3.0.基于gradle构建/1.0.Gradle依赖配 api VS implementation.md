Gradle 依赖配置 api VS implementation
================================================================================
Gradle3.4引入了新的依赖配置，新增了`api`和`implementation`来代替`compile`依赖配置。**其中
api和以前的compile依赖配置是一样的。使用implementation依赖配置，会显著提升构建时间**。

接下来，我们举例说明`api`和`implementation`的区别。

假如我们一个名`MyLibrary`的module类库和一个名为`InternalLibrary`的module类库。里面的代码
类似这样：
```java
//internal library module
public class InternalLibrary {
    public static String giveMeAString(){
        return "hello";
    }
}

//my library module
public class MyLibrary {
    public String myString(){
        return InternalLibrary.giveMeAString();
    }
}
```
MyLibrary中`build.gradle`对InternalLibrary的依赖如下：
```gradle
dependencies {
    api project(':InternalLibrary')
}
```
然后在主module的`build.gradle`添加对MyLibrary的依赖：
```gradle
dependencies {
    api project(':MyLibrary')
}
```
**在主module中，使用api依赖配置，MyLibrary和InternalLibrary都可以访问**：
```java
//so you can access the library (as it should)
MyLibrary myLib = new MyLibrary();
System.out.println(myLib.myString());

//but you can access the internal library too (and you shouldn't)
System.out.println(InternalLibrary.giveMeAString());
```
**使用这种方法，会泄露一些不应该被使用的实现**。

为了阻止这种情况，Gradle新增了`implementation`配置。

如果我们在MyLibrary中使用`implementation`配置：
```gradle
dependencies {
    implementation project(':InternalLibrary')
}
```
然后在主module的`build.gradle`文件中使用`implementation`添加对MyLibrary的依赖：
```gradle
dependencies {
    implementation project(':MyLibrary')
}
```
使用这个`implementation`依赖配置在应用中无法调用`InternalLibrary.giveMeAString()`。**如
果MyLibrary使用`api`依赖InternalLibrary，无论主module使用`api`还是`implementation`依赖
配置，主module中都可以访问`InternalLibrary.giveMeAString()`**。

**使用这种封箱策略，如果你只修改了InternalLibrary中的代码，Gradle只会重新编译MyLibrary，它
不会触发重新编译整个应用，因为你无法访问InternalLibrary。当你有大量的嵌套依赖时，这个机制会显
著提升构建速度**。

其它配置说明如下表所示:

| 新配置 | 废弃配置 | 说明 |
|:------|:--------|:-----|
| compileOnly | provided | gradle添加依赖到编译路径，编译时使用。（不会打包到APK） |
| runtimeOnly | apk | gradle添加依赖只打包到APK，运行时使用。（不会添加到编译路径） |

