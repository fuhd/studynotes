分布式事务之二阶段提交
==================================================================

![全局事务－DTP模型](img/p11.png)

![两阶段提交](img/p12.png)

![跨域的全局事务－DTP模型](img/p13.png)

![Java企业平台中的分布事务实现](img/p14.png)

### 两阶段提交协议
**两阶段提交协议是协调所有分布式原子事务参与者，并决定提交或取消（回滚）的分布式算法**。

![两阶段提交](img/p15.png)

#### 协议参与者
在两阶段提交协议中，系统一般包含 **两类机器（或节点）**：一类为 **协调者（`coordinator`）**，
通常一个系统中 **只有一个**；另一类为 **事务参与者**（`participants`，`cohorts`或`workers`），**一般包含多个**。

#### 两阶段的执行
1. **请求阶段**（`commit-request phase`，或称 **表决阶段**，`voting phase`）
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：
同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。

2. **提交阶段**（`commit phase`）
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，
否则协调者将通知所有的参与者取消事务。参与者在接收到协调者发来的消息后将执行响应的操作。

#### 两阶段提交的缺点
1. **同步阻塞问题**。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，
其他第三方节点访问公共资源不得不处于阻塞状态。

2. **单点故障**。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，
那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，
但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3. **数据不一致**。在二阶段提交的阶段二中，当协调者向参与者发送`commit`请求之后，发生了局部网络异常或者在发送
`commit`请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了`commit`请求。而在这部分参与者接到`commit`请求之后
就会执行`commit`操作。但是其他部分未接到`commit`请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

### 建议
**尽量不要使用`2PC`，使用`BASE`来回避**。